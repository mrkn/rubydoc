= class Vector < Object

#@# [2002-04-03]  by [[unknown:すす|URL:mailto:sugawah@attglobal.net]]

数 [[c:Numeric]] を要素とするベクトルを扱うクラスです。

#@# ((-Vectorクラスには英語のドキュメントがほとんどないので、英語の方も補ってみました。とりあえず対訳にしておいて、そのうち、英語版を分離します。-))

#@#=== 使い方　Usage

#@#Vectorクラスを使うためには、require 'matrix'する必要があります。

#@#  require 'matrix'

=== Complexクラスとの併用 Working with Complex class

require 'complex' することによって、
Vector オブジェクトの要素は [[c:Complex]] クラスに拡張されます。
多くのメソッドは、この拡張されたVectorクラスでも、期待通りに動作します。

次の例は、各要素を共役複素数に置換するメソッド (Vector#conjugate)です。

  require 'matrix'
  require 'complex'
  
  class Vector
    def conjugate
      collect{|e| e.conjugate }
    end
  end
  
  v1 = Vector[Complex(1,1),Complex(2,2),Complex(3,3)]
  v2 = v1.conjugate
  p v2 #=> Vector[Complex(1,-1),Complex(2,-2),Complex(3,-3)]
  v3 = v1+v2
  p v3 #=> Vector[Complex(1,0),Complex(2,0),Complex(3,0)]


しかし、Complex 要素に拡張された Vector クラスで、
期待通りに動作しないメソッドもあります。
例えば、ベクトルの絶対値を求める [[m:Vector#r]] メソッドは、
各要素の2乗和の平方根 [[m:Math#sqrt]] を求めますが、
このとき例外を発生させる可能性があります。

複素数を要素とするベクトルの絶対値を求めるためには、
各要素の絶対値の2乗和をとらなくてはなりません(次の例 Vector#absメソッド）。

  require 'matrix'
  require 'complex'
  
  class Vector
    def abs
      r=0
      @elements.each{|e| r += e.abs2 }
      Math.sqrt(r)
    end
  end
  
  v = Vector[Complex(1,1),Complex(2,2),Complex(3,3)}
  p v.abs #=> 5.291502622 # Math.sqrt(28)
  p v.r   #=> 'sqrt': undefined method `Rational'

#@#=== ChangeLog
#@#
#@#  *[2002-04-03] by [[unknown:すす|URL:mailto:sugawah@attglobal.net]]
#@#    * 使い方の節を追加
#@#    * Working with Complex classの節を追加
#@#    * []=メソッドを追加
#@#    * イテレータ関係を同じ節にまとめた collect, map, each2, collect2, map2
#@#    * 誤りを訂正し、説明を直した。 とくにeach2, collect2, map2
#@#    * 他クラスへのリンクを追加 Numeric, Matrix
#@#  *[2002-04-02] 初版 by [[unknown:すす|URL:mailto:sugawah@attglobal.net]]

== Class Methods

--- [](a)
#@todo

配列 a を要素とするベクトルを生成します。

--- elements(a, copy = true)
#@todo

配列 a を要素とするベクトルを生成します。
ただし、オプション引数 copy が偽 (false) ならば、複製を行いません。

== Instance Methods

--- [](i)
#@todo

i 番目の要素を返します。インデックスは 0 から開始します。

--- size
#@todo

ベクトルの大きさを返します。

#@#--- []=(i, x)
#@#
#@#i 番目の要素を x に変更します。
#@#
#@#このメソッドは、matrix.rb に定義されていません。
#@#以下に、その定義と使用例を示します。
#@#
#@#  require 'matrix'
#@#  
#@#  class Vector
#@#    def []=(i,x)
#@#      @elements[i]=x
#@#    end
#@#  end
#@#  
#@#  v=Vector[1,2,3]
#@#  v[2]=-1
#@#  p v #=> Vector[1,2,-1]

--- *(a)
#@todo

数 a を乗じたベクトルを返します。

--- *(m)
#@todo

列ベクトル(行列)に変換して (実際には [[m:Matrix#column_vector]](self) を適用) から、行列 m を右から乗じた行列 ([[c:Matrix]] クラス) を返します。

--- +(v)
#@todo

ベクトル v を加えたベクトルを返します。

--- -(v)
#@todo

ベクトル v を減じたベクトルを返します。

--- inner_product(v)
#@todo

ベクトル v との内積を返します。

--- r
#@todo

ベクトルの絶対値を返します。
ベクトルの絶対値は、各要素の２乗の和の平方根を取ったものです。

--- collect {|x| ... }
--- map {|x| ... }
#@todo

ベクトルの各要素に対してブロックを評価した結果を、要素として持つベクトルを生成します。

--- each2(v) {|x, y| ... }
#@todo

ベクトルの各要素と、それに対応するインデックスを持つ引数 v の要素との組に対して (2引数の) ブロックを繰返し評価します。`v' は size メソッドと [] メソッドを持つオブジェクトです。
#@# sizeメソッドと[]メソッドを持つことをもってArrayクラスの定義としてよいのでしょうか?  単純に配列クラスと書けるとうれしいです。

--- collect2(v) {|x, y| ... }
#@todo

ベクトルの各要素と、それに対応するインデックスを持つ引数 v の要素との組に対して (2引数の) ブロックを評価し、その結果を要素として持つ配列を生成します。

--- map2(v) {|x, y| ... }
#@todo

ベクトルの各要素と、それに対応するインデックスを持つ引数 (配列) の要素との組に対して (2引数の) ブロックを評価した結果を、要素として持つベクトルを返します。

次の例は、二つのベクトルの要素毎の積をとります。

  require 'matrix'
  
  v = Vector[2,3,5]
  w = Vector[7,9,11]
  z1 = v.collect2(w){|x,y| x*y }
  z2 = v.map2(w) {|x,y| x*y }
  
  p z1 #=> [14, 27, 55]
  p z2 #=> Vector[14, 27, 55]

--- covector
#@todo

列ベクトル (行列)、すなわち、(n,1) 型の行列に変換します。
実際には [[m:Matrix#row_vector]](self) を適用します。

--- to_a
#@todo

配列 ([[c:Array]]) に変換します。

--- to_f
#@todo

各要素を浮動小数点数 ([[c:Float]]) に変換します。

--- to_i
#@todo

各要素を整数 ([[c:Integer]]) に変換します。

--- to_r
#@todo

各要素を有理数 ([[c:Rational]]) に変換します。

= class Vector::ErrDimensionMismatch < StandardError
= class Vector::ErrNotRegular < StandardError
= class Vector::ErrOperationNotDefined < StandardError
