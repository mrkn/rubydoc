= class Zlib::GzipReader < Zlib::GzipFile

include Enumerable

gzip 形式の圧縮ファイルを読み込むラッパークラスです。
IO クラスのインスタンス (又は IO クラスのインスタンスと同じメソッドを
持つオブジェクト) と関連付けて使用します。

  require 'zlib'
  =begin
  # hoge.gz がない場合は下記で作成できる。
  Zlib::GzipWriter.open('hoge.gz') { |gz|
    gz.puts 'hoge'
  }
  =end

  Zlib::GzipReader.open('hoge.gz') {|gz|
    print gz.read
  }
  
  f = File.open('hoge.gz')
  gz = Zlib::GzipReader.new(f)
  print gz.read
  gz.close

== Class Methods

--- new(io)
#@todo

io と関連付けられた GzipReader オブジェクトを作成します。
GzipReader オブジェクトは io からデータを逐次リードして
解析/展開を行います。io には少なくとも、[[m:IO#read]] と
同じ動作をする read メソッドが定義されている必要があります。

ヘッダーの解析に失敗した場合 Zlib::GzipFile::Error 例外が
発生します。

@param io IO オブジェクト、もしくは少なくとも[[m:IO#read]]と同じ動作をするreadメソッドが定義されているオブジェクト

@raise Zlib::GzipFile::Error ヘッダーの解析に失敗した場合発生します。

  File.open('hoge.txt', "w") { |fp|
    fp.puts 'hoge'
  }

  f = File.open('hoge.txt')
  begin
    Zlib::GzipReader.new(f)
  rescue Zlib::GzipFile::Error => err
    puts "error", err #=> error
                      #=> not in gzip format
  end

--- wrap(io) {|gz| ... }
#@todo

io と関連付けられた GzipReader オブジェクトを作成し、
それを引数としてブロックを実行します。
ブロックの実行が終了すると、GzipReader オブジェクトは自動的に
クローズされます。関連付けられている IO オブジェクトまで
クローズしたくない時は、ブロック中で [[m:Zlib::GzipFile#finish]]
メソッドを呼び出して下さい。

@param io IO オブジェクトを指定します。

  require 'zlib'

  =begin
  # hoge.gz がない場合はこれで作成する。
  Zlib::GzipWriter.open('hoge.gz') { |gz|
    gz.puts 'hoge'
  }
  =end

  f = File.open('hoge.gz')
  Zlib::GzipReader.wrap(f){|gz|
    print gz.read
  }
  p f.closed? #=> true

  f = File.open('hoge.gz')
  Zlib::GzipReader.wrap(f){|gz|
    print gz.read
    gz.finish
  }
  p f.closed? #=> false

--- open(filename)
--- open(filename) {|gz| ... }

filename で指定されるファイルを gzip ファイルとして
オープンします。GzipReader オブジェクトを返します。
その他詳細は [[m:Zlib::GzipReader.new]] や [[m:Zlib::GzipReader.wrap]] と
同じです。

@param filename gzip ファイル名を文字列で指定します。

  require 'zlib'

  =begin
  # hoge.gz がない場合はこれで作成する。
  Zlib::GzipWriter.open('hoge.gz') { |gz|
    gz.puts 'hoge'
  }
  =end

  Zlib::GzipReader.open('hoge.gz'){|gz|
    print gz.read
  }

== Instance Methods

--- eof -> bool
--- eof? -> bool

圧縮データの終端に達した場合真を返します。
フッターが読み込まれていなくても真を返すことに注意して下さい。

  =begin
  # hoge.gz がない場合はこれで作成する。
  Zlib::GzipWriter.open('hoge.gz') { |gz|
    gz.puts 'hoge'
    gz.puts 'fuga'
    gz.puts 'foga'
  }
  =end

  Zlib::GzipReader.open('hoge.gz'){|gz|
    gz.each_line{|line|
      puts line
    }
    p gz.eof? #=> true
  }

--- pos -> Fixnum
--- tell -> Fixnum

現在までに展開したデータの長さの合計を返します。
ファイルポインタの位置ではないことに注意して下さい。

  Zlib::GzipWriter.open('hoge.gz') { |gz|
    gz.puts 'hoge'
  }

  Zlib::GzipReader.open('hoge.gz'){|gz|
    while c = gz.getc
      printf "%c, %d\n", c, gz.pos
    end
  }
  # 実行例
  #=> h, 1
  #=> o, 2
  #=> g, 3
  #=> e, 4
  #=>  
  #=> , 5

--- each([rs])
--- each_line([rs])
--- each_byte([rs])
--- gets([rs])
--- getc
--- lineno
--- lineno=(num)
--- read([length])
--- readchar
--- readline([rs])
--- readlines([rs])
#@since 1.9.0
--- readpartial(maxlen[, outbuf])
#@end
--- ungetc(char)
#@todo

IO クラスの同名メソッドと同じですが、gzip ファイル中に
エラーがあった場合 [[c:Zlib::Error]] 例外や
Zlib::GzipFile::Error 例外が発生します。

gzip ファイルのフッターの処理に注意して下さい。
gzip ファイルのフッターには圧縮前データのチェックサムが
記録されています。GzipReader オブジェクトは、次の時に展開した
データとフッターの照合を行い、エラーがあった場合は
Zlib::GzipFile::NoFooter, Zlib::GzipFile::CRCError,
Zlib::GzipFile::LengthError 例外を発生させます。

  * EOF (圧縮データの最後) を越えて読み込み要求を受けた時。
    すなわち [[m:Zlib::GzipReader#read]],
    [[m:Zlib::GzipReader#gets]] メソッド等が nil を返す時。
  * EOF まで読み込んだ後、[[m:Zlib::GzipFile#close]] メソッドが
    呼び出された時。
  * EOF まで読み込んだ後、[[m:Zlib::GzipReader#unused]] メソッドが
    呼び出された時。

--- rewind -> 0

ファイルポインタを [[m:Zlib::GzipReader.new]] を呼び出した直後の
時点に戻します。関連付けられている IO オブジェクトに
seek メソッドが定義されている必要があります。

  =begin
  # hoge.gz がない場合はこれで作成する。
  Zlib::GzipWriter.open('hoge.gz') { |gz|
    gz.puts 'hoge'
    gz.puts 'fuga'
  }
  =end

  gz = Zlib::GzipReader.open('hoge.gz')
  puts gz.gets #=> hoge
  puts gz.gets #=> fuga
  gz.rewind  #=> 0
  puts gz.gets #=> hoge
  gz.close

--- unused
#@todo

gzip フォーマットの解析のために読み込んだ余剰のデータを返します。
gzip ファイルが最後まで解析されていない場合は nil を返します。
