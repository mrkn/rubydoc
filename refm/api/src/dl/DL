= module DL

モジュール DL は 3 つのクラスから成っています。

: [[c:DL::Symbol]] 
  ダイナミックライブラリの関数のラッパークラスです。
: [[c:DL::PtrData]] 
  C のポインタのようなメモリブロックを表すクラスです。
: [[c:DL::Handle]] 
  オープンされたダイナミックライブラリを表すクラスです。

#@#また、現在 dl2 の Ruby 1.8 版も開発されています。
#@#Ruby 1.9 にはすでに dl2 が dl として添付されています。
#@#dl2 のドキュメントは、
#@#[[url:http://rubyforge.org/cgi-bin/viewcvs.cgi/ruby-dl2/doc/?root=ruby-dl2]]
#@#を参照。

=== Type specifiers

プロトタイプは以下の型修飾子から成ります。プロトタイプの最初の要素は戻り値
の型を意味します。残りの要素は各引数の型を意味します。

: C
    文字 (char)
: c
    文字を指すポインタ (char *)
: H
    short 整数  (short)
: h
    short 整数を指すポインタ (short *)
: I
    整数 (char, short, int)
: i
    整数を指すポインタ (char *, short *, int *)
: L
    long int
: l
    long int へのポインタ (long *)
: F
    実数 (float)
: f
    実数へのポインタ (float *)
: D
    実数 (double)
: d
    実数へのポインタ(double *)
: S
    不変 (immutable) の文字列 (const char *)
: s
    変更可能(mutable)な文字列 (char *)
: A
    配列 (const type[])
: a
    変更可能 (mutable) な配列 (type[])
: P
    ポインタ (void *)
: p
    変更可能 (mutable) なポインタ (void *)
: 0
    void 関数 (これはプロトタイプの最初の文字でなければならない)

cbtype は型修飾子 0, C, I, H, L, F, D, S そして P から成ります。
例えば,

  DL.callback('IPP'){|ptr1,ptr2|
    str1 = ptr1.ptr.to_s
    str2 = ptr2.ptr.to_s
    str1 <=> str2
  }

== Singleton Methods

--- last_error
--- last_error=
#@todo

--- win32_last_error
--- win32_last_error=
#@todo

== Constants

--- FuncTable
#@todo

--- RTLD_GLOBAL
#@todo

--- RTLD_LAZY
#@todo

--- RTLD_NOW
#@todo

--- ALIGN_INT
#@todo

--- ALIGN_LONG
#@todo

--- ALIGN_FLOAT
#@todo

--- ALIGN_SHORT
#@todo

--- ALIGN_DOUBLE
#@todo

--- ALIGN_VOIDP
#@todo

--- MAX_ARG
#@todo

--- DLSTACK
#@todo

--- FREE
#@todo

== Module Functions

--- dlopen(lib)
--- dlopen(lib) {|handle| ... }
#@todo

ダイナミックライブラリ lib をロードし、それに対応する
[[c:DL::Handle]] を返します。

ブロックが与えられている場合は、[[c:DL::Handle]] 引数として
与えられたブロックを実行します。[[c:DL::Handle]] を返します。

[[m:DL::Handle.new]](lib) と等価です。

@param lib ロードしたいライブラリを文字列で与えます。

--- callback(type)
--- define_callback(type)
#@todo

Cレベルのコールバック関数を定義し、その関数(へのポインタ)を保持した
[[c:DL::Symbol]] を返します。

@param type コールバック関数の型指定子を与えます。

@raise DL::DLError 定義できるコールバック関数の数には制限があります。それを越えると、DL::DLError が
発生します。

 require 'dl/import'
 strlast = DL.callback('IS'){|s|
   s[-1]
 }
 
 module M
   extend DL::Importable
   dlload "./libtest.so"
   extern "int call(void *, const char*)"
 end
 p LIBC.call(strlast, "abcd").chr #=> "d"


//emlist{
 /* libtest.so */ 
 int call(int (*cb)(const char*), const char* s){
   return (*cb)(s);
 }
//}

--- remove_callback(sym)    -> nil
#@todo

コールバック関数 sym を [[m:DL::FuncTable]] から削除します。
#@#sym は以後 GC の対象になり得ます。
以後 sym.call を呼ぶことができなくなります。

@param sym [[c:DL::Symbol]] オブジェクトを与えます。

--- malloc(size)
#@todo

size バイトのメモリ領域を確保し、
その領域を指す [[c:DL::PtrData]] オブジェクトを返します。

@param size 必要なメモリ領域のサイズを指定します。

--- sizeof(type)    -> Integer
#@todo

型のサイズを返します。

sizeof("C") + sizeof("L") は、sizeof("CL") と等価ではありません。
後者は構造体 struct foo { char c; long l; } の
十分なサイズを返すと推定されますが、
そのサイズは C の sizeof(foo) と同じではないかもしれません。
つまり、sizeof メソッドは独自にアラインメントを考慮してサイズを決定
しますが、 C 言語のそれとは異なるかもしれません。

sizeof("L3") のように型の後に数字を付けることもできます。
指定できる型については [[m:DL#Type specifiers]] を参照してください。

@param type 型指定子を与えます。

--- strdup(str)
#@todo

文字列 str を複製した新しい文字列へのポインタに相当する
[[c:DL::PtrData]] オブジェクトを返します。

@param str 文字列を与えます。

= class DL::DLError < StandardError
DL に関する一般的なエラーが発生したときに投げられます。

= class DL::DLTypeError < DL::DLError
型に関するエラーが発生したときに投げられます。

= reopen String

== Instance Methods

--- to_ptr
#@todo

自身を複製し、複製した文字列を指す [[c:DL::PtrData]] を返します。

 s = 'abc'
 sp = s.to_ptr
 p sp.size #=> 3
 p sp.to_s #=> "abc"
 p sp[0] = 'A'
 p sp.to_s #=> "Abc"
 p s       #=> "abc"

= reopen Array

== Instance Methods

--- to_ptr
--- to_ptr(type)
#@todo

自身を [[c:DL::PtrData]] に変換して返します。
これは、Cレベルでは各要素を指すポインタの配列です。

selfのすべての要素は同じクラスでなければいけません。

 require 'dl/import'
 
 ptr = ['a', 'b', 'c'].to_ptr
 p ptr.size #=> 12
 p ptr.to_a('P').map{|s| s.to_s } #=> ["a", "b", "c"]

@param type self の要素のクラスを明示的に指定します。[[c:DL]] の Type specifiers を参照して下さい。

= reopen IO

== Instance Methods

--- to_ptr
#@todo

