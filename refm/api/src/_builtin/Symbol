= class Symbol < Object
#@since 1.9.0
include Comparable
#@end
シンボルを表すクラス。シンボルは任意の文字列と一対一に対応するオブジェ
クトです。
#@#シンボルとはなにか
#@#同値なシンボルは必ず同一
#@#
#@#

Ruby スクリプトからは

  :symbol #シンボルのリテラル表記
  'symbol'.intern
  %s!symbol! # %記法
  
#@#リストにする？
のようにして得られます。実際にシンボルが生成されるのはコンパイル時です。
リテラルでシンボルを表す場合、`:' の後に
は識別子、メソッド名(`!',`?' などの接尾辞を含む)、変数名
(`$'などの接頭辞を含む)、再定義できる演算子のいずれかに適合する
ものしか書くことはできません(そうでなければ文法エラーになります)。

=== シンボルの用途
#@#シンボルを使うことが推薦される場面（とその理由）

== Class Methods
#@since 1.9.0
--- intern(str) -> Symbol
#@#うまく動かない。質問すること

#@end
#@since 1.8.0
--- all_symbols -> [Symbol]

定義済みの全てのシンボルオブジェクトの配列を返します。

  p Symbol.all_symbols  # => [:RUBY_PLATFORM, :RUBY_VERSION, ...]

シンボルの生成はコンパイル時に行われるので以下のようにしても結果に
差はありません。

  a = Symbol.all_symbols
  :foo
  b = Symbol.all_symbols
  
  p a == b # => true

#@end

== Instance Methods

#@since 1.8.0
--- to_sym -> self
#@since 1.9.0
--- intern -> self
#@end
self を返します。
#@end

--- id2name -> String
--- to_s -> String

シンボルに対応する文字列を返します。

逆に、文字列に対応するシンボルを得るには
[[m:String#intern]] を使います。

  p :foo.id2name
  #=> "foo"
  
  p :foo.id2name.intern == :foo
  #=> true

--- to_i -> Integer
#@todo

シンボルに対応する整数を返します。

#@if ("1.8.0" > version)
逆にこの整数から対応するシンボルを得るには
[[m:Fixnum#id2name]] を使って一旦文字列を得る必要が
あります。
#@else
逆にこの整数から対応するシンボルを得るには
[[m:Fixnum#to_sym]] が使えます
#@end

   id = :foo.to_i
   p id                  # => 8881
#@if ("1.8.0" > version)
   p id.id2name.intern   # => :foo
#@else
   p id.to_sym           # => :foo
#@end

Rubyの実装では予約語、変数名、メソッド名などをこの整数で管理してい
ます。オブジェクトに対応する整数([[m:Object#__id__]] で得ら
れます)と Symbol に対応する整数は別のものです。
#@#詳しく。場所を移動？


#@since 1.9.0
#@#追加たくさん
    新規
    rb_define_method(rb_cSymbol, "==", sym_equal, 1);
    rb_define_method(rb_cSymbol, "to_proc", sym_to_proc, 0);
    
    ダンプする
    rb_define_method(rb_cSymbol, "dump", rb_str_dump, 0);
    

    Stringみたい レシーバをStringに変換
    rb_define_method(rb_cSymbol, "=~", sym_match, 1);
    rb_define_method(rb_cSymbol, "match", sym_match, -1);
    rb_define_method(rb_cSymbol, "===", sym_eqq, 1);
    Stringみたい 返り値は Stringの時と一緒（String）
    rb_define_method(rb_cSymbol, "[]", sym_aref, -1);
    rb_define_method(rb_cSymbol, "slice", sym_aref, -1);
    Stringみたい 返り値は Stringの時と一緒
    rb_define_method(rb_cSymbol, "length", sym_length, 0);
    rb_define_method(rb_cSymbol, "size", sym_length, 0);
    rb_define_method(rb_cSymbol, "empty?", sym_empty, 0);
    rb_define_method(rb_cSymbol, "<=>", sym_cmp, 1);
    rb_define_method(rb_cSymbol, "casecmp", sym_casecmp, 1);
    Stringみたい 返り値は Symbol
    rb_define_method(rb_cSymbol, "swapcase", sym_swapcase, 0);
    rb_define_method(rb_cSymbol, "upcase", sym_upcase, 0);
    rb_define_method(rb_cSymbol, "downcase", sym_downcase, 0);
    rb_define_method(rb_cSymbol, "capitalize", sym_capitalize, 0);
    rb_define_method(rb_cSymbol, "succ", sym_succ, 0);
    rb_define_method(rb_cSymbol, "next", sym_succ, 0);

#@end
