= class Symbol < Object
#@since 1.9.0
include Comparable
#@end

#@#インターンされた文字列
シンボルを表すクラス。シンボルは任意の文字列と一対一に対応するオブジェクトで、
同じ内容のシンボルはかならず同一のオブジェクトです。
文字列の代わりに用いることもできますが、必ずしも文字列と同じ振る舞いをするわけではありません。

Ruby スクリプトからは

  :symbol # 基本のシンボルリテラル
  :'symbol'
  'symbol'.intern
  %s!symbol! # %記法

のようにして得られます。実際にシンボルが生成されるのはコンパイル時です。
一番目のリテラルでシンボルを表す場合、`:' の後に
は識別子、メソッド名(`!',`?' などの接尾辞を含む)、変数名
(`$'などの接頭辞を含む)、再定義できる演算子のいずれかに適合する
ものしか書くことはできません(そうでなければ文法エラーになります)。
そうでない文字列をシンボルにしたい場合は他の表記を使用してください。
#@#↑リストにすべき？
#@# 1.9では空文字列もシンボルにできる

=== シンボルの実装と用途
==== 実装
Rubyの内部実装では、メソッド名や変数名、定数名、クラス名など
の`名前'を整数で管理しています。これは名前を直接文字列として処理するよりも
速度面で有利だからです。そしてその整数をRubyのコード上で表現したものがシンボルです。

シンボルは、ソース上では文字列のように見え、内部では整数として扱われる、両者を仲立ちするような存在です。
#@#表現？

名前を管理するという役割上、シンボルと文字列は一対一に対応します。
また、文字列と違い、immutable(変更不可)であり、同値ならば必ず同一です。

  p "abc" == "abc" #=> true
  p "abc".equal?("abc") #=> false
  p :abc == :abc #=> true
  p :abc.equal?(:abc) #=> true ←同値ならば同一

==== 用途
実用面では、シンボルは文字の意味を明確にします。`名前'を指し示す時など、
文字列そのものが必要なわけではない時に用います。

#@#プログラム内部でしか使わない文字列

  * ハッシュのキー { :key => "value" }
  * アクセサの引数で渡すインスタンス変数名 attr_reader :name
  * メソッド引数で渡すメソッド名 __send__ :to_s
  * C の enum 的な使用 

シンボルを使うメリットは

  * 新しく文字列を生成しない分やや効率がよく、比較も高速。
  * 文字の意味がはっきりするのでコードが読みやすくなる
  * immutableなので内容を書き換えられる心配がない
#@#タイプ量が少ない

大抵のメソッドはシンボルの代わりに文字列を引数として渡すこともできるようになっています。

#@since 1.9.0
Symbolクラスのメソッドには、Stringクラスのメソッドに類似のものもあります。
#@end

== Class Methods

#@since 1.8.0
--- all_symbols -> [Symbol]

定義済みの全てのシンボルオブジェクトの配列を返します。

  p Symbol.all_symbols  # => [:RUBY_PLATFORM, :RUBY_VERSION, ...]

シンボルの生成はコンパイル時に行われるので以下のようにしても結果に
差はありません。

  a = Symbol.all_symbols
  :foo
  b = Symbol.all_symbols
  
  p a == b #=> true
  
  #コンパイル時に不定なシンボルになんらかの操作をすると、違った結果になる。
  a = Symbol.all_symbols
  s = :"#{gets.chomp}"  #unknown と入力
  b = Symbol.all_symbols
  
  p(b - a) #=> [:unknown]

#@end

== Instance Methods

#@since 1.9.0
--- intern -> self
#@end
#@since 1.8.0
--- to_sym -> self
self を返します。

@see [[m:String#intern]]
#@end


--- id2name -> String
--- to_s -> String

シンボルに対応する文字列を返します。

逆に、文字列に対応するシンボルを得るには
[[m:String#intern]] を使います。

  p :foo.id2name
  #=> "foo"
  
  p :foo.id2name.intern == :foo
  #=> true
  
@see [[m:String#intern]]

--- to_i -> Integer

シンボルに対応する整数を返します。

このメソッドで得られる整数は、内部実装で名前の管理に使われています。
オブジェクトに対応する整数([[m:Object#object_id]] で得ら
れます)と Symbol に対応する整数は別のものです。

#@if ("1.8.0" > version)
逆にこの整数から対応するシンボルを得るには
[[m:Fixnum#id2name]] を使って一旦文字列を得る必要が
あります。
#@else
逆にこの整数から対応するシンボルを得るには
[[m:Fixnum#to_sym]] が使えます
#@end

   id = :foo.to_i
   p id                  # => 8881
#@if ("1.8.0" > version)
   p id.id2name.intern   # => :foo
#@else
   p id.to_sym           # => :foo
#@end

#@if ("1.8.0" > version)
@see [[m:Fixnum#id2name]]
#@else
@see [[m:Fixnum#to_sym]]
#@end


#@#編集中
#@since 3.0.0
    新規
    rb_define_method(rb_cSymbol, "to_proc", sym_to_proc, 0);
--- to_proc -> Proc
    Stringみたい レシーバをStringに変換
    rb_define_method(rb_cSymbol, "=~", sym_match, 1);
    rb_define_method(rb_cSymbol, "match", sym_match, -1);
    rb_define_method(rb_cSymbol, "===", sym_eqq, 1);
    Stringみたい 返り値は Stringの時と一緒（String）
    rb_define_method(rb_cSymbol, "[]", sym_aref, -1);
    rb_define_method(rb_cSymbol, "slice", sym_aref, -1);
    Stringみたい 返り値は Stringの時と一緒
    rb_define_method(rb_cSymbol, "length", sym_length, 0);
    rb_define_method(rb_cSymbol, "size", sym_length, 0);
    rb_define_method(rb_cSymbol, "empty?", sym_empty, 0);
    rb_define_method(rb_cSymbol, "<=>", sym_cmp, 1);
    rb_define_method(rb_cSymbol, "casecmp", sym_casecmp, 1);
    Stringみたい 返り値は Symbol
    rb_define_method(rb_cSymbol, "swapcase", sym_swapcase, 0);
    rb_define_method(rb_cSymbol, "upcase", sym_upcase, 0);
    rb_define_method(rb_cSymbol, "downcase", sym_downcase, 0);
    rb_define_method(rb_cSymbol, "capitalize", sym_capitalize, 0);
    rb_define_method(rb_cSymbol, "succ", sym_succ, 0);
    rb_define_method(rb_cSymbol, "next", sym_succ, 0);
#@end
