= class Hash < Object
include Enumerable

ハッシュテーブル(連想配列とも呼ぶ)のクラス。ハッシュは任意の種類のオブ
ジェクト(キー)から任意の種類のオブジェクト(値)への関連づけを行うことができます。
ハッシュ生成は以下のようなハッシュ式で行われます。

  {a => b, ... }   #aはキー、bは値となる
#@if (version >= "1.9.0")
  {s: b , ... }    #{ :s => b, ... } と同じ。キーがシンボルの場合の省略した書き方
#@end

ハッシュの格納に用いられるハッシュ値の計算には、
[[m:Object#hash]] メソッドが使われ、キーの同一性判定には、
[[m:Object#eql?]] メソッドが使われます。キーには任意の種類のオブジェクトを用いることができますが、
この２つのメソッドが適切に定義してある必要があります。

キーとして与えたオブジェクトの内容が変化し、Object#hashの返す
値が変わるとハッシュから値が取り出せなくなりますから、[[c:Array]]、
[[c:Hash]] などのインスタンスはキーに向きません。[[m:Hash#rehash]]を参照。
ただし、文字列をキーとして与えると、文字列をコピーし、コピーを更新不可に設定([[m:Object#freeze]])してキーとして
使用します。キーとして使われている文字列を更新しようとすると例外
[[c:TypeError]] が発生します。

ハッシュにはデフォルト値を設定することができます。存在しないキーを探索したときに返す値で、未設定時はnilです。
実際にデフォルト値がどのように扱われるかは各メソッドの説明を参照してください。

== Class Methods

--- [](hash) -> Hash

新しいハッシュを生成します。

引数hashと同一のキーと値を持つ新たなハッシュを生成して返しま
す。(生成されたハッシュのデフォルト値は nil です。)

@param hash 生成元となるハッシュです。

  h = {1=>2}
  g = Hash[h]
  p g #=> {1=>2}

--- [](key,value,...)  -> Hash

新しいハッシュを生成します。
引数は必ず偶数個指定しなければなりません。(奇数番目がキー、偶数番目が値)。

このメソッドでは生成するハッシュにデフォルト値を指定することはできません。
[[m:Hash.new]]を使うか、[[m:Hash#default=]]で後から指定してください。

@param key 生成するハッシュのキーです。
@param value 生成するハッシュの値です。
@raise ArgumentError 奇数個の引数を与えたときに発生します。

以下は配列からハッシュを生成する方法の例です。

#@if (version < "1.7.0")
(1) [キー, 値, ...] の配列からハッシュへ

  ary = [1,"a", 2,"b", 3,"c"]
  p Hash[*ary]
  
  # => {1=>"a", 2=>"b", 3=>"c"}

(2) キーと値のペアの配列からハッシュへ

  alist = [[1,"a"], [2,"b"], [3,"c"]]
  p Hash[*alist.flatten]
  
  #=> {1=>"a", 2=>"b", 3=>"c"}

(3) キーや値が配列だと (2) の方法は使えないので地道に代入するしかない

  h = Hash.new
  alist = [[1,["a"]], [2,["b"]], [3,["c"]]]
  alist.each {|k,v|
    h[k] = v
  }
  p h
  
  #=> {1=>["a"], 2=>["b"], 3=>["c"]}
  
(4) キーと値の配列のペアからハッシュへ（地道に代入）

  keys = [1, 2, 3]
  vals = ["a", "b", "c"]
  h={}
  
  keys.each_with_index{|key,n| h[key] = vals[n]}
  p h
  
  #=> {1=>"a", 2=>"b", 3=>"c"}

#@end
#@if ("1.7.0" >= version)
#@if (version < "1.9.0")
(1) [キー, 値, ...] の配列からハッシュへ

  ary = [1,"a", 2,"b", 3,"c"]
  p Hash[*ary]
  
  # => {1=>"a", 2=>"b", 3=>"c"}

(2) キーと値のペアの配列からハッシュへ

  alist = [[1,"a"], [2,"b"], [3,"c"]]
  p Hash[*alist.flatten]
  
  #=> {1=>"a", 2=>"b", 3=>"c"}

(3) キーと値の配列のペアからハッシュへ

  keys = [1, 2, 3]
  vals = ["a", "b", "c"]
  alist = keys.zip(vals)   # あるいは alist = [keys,vals].transpose
  p Hash[*alist.flatten]
  
  #=> {1=>"a", 2=>"b", 3=>"c"}

(4) キーや値が配列だと (2) や (3) の方法は使えないので地道に代入するしかない

  h = Hash.new
  alist = [[1,["a"]], [2,["b"]], [3,["c"]]]
  alist.each {|k,v|
    h[k] = v
  }
  p h
  
  #=> {1=>["a"], 2=>["b"], 3=>["c"]}
#@end
#@end
#@if (version >= "1.9.0")
(1) [キー, 値, ...] の配列からハッシュへ

  ary = [1,"a", 2,"b", 3,["c"]]
  p Hash[*ary]
  
  # => {1=>"a", 2=>"b", 3=>["c"]}

(2) キーと値のペアの配列からハッシュへ

  alist = [[1,"a"], [2,"b"], [3,["c"]]]
  p Hash[*alist.flatten(1)]
  
  #=> {1=>"a", 2=>"b", 3=>["c"]}

(3) キーと値の配列のペアからハッシュへ

  keys = [1, 2, 3]
  vals = ["a", "b", ["c"]]
  alist = keys.zip(vals)   # あるいは alist = [keys,vals].transpose
  p Hash[*alist.flatten(1)]
  
  #=> {1=>"a", 2=>"b", 3=>["c"]}
#@end

--- new(ifnone=nil) -> Hash

空の新しいハッシュを生成します。ifnone はキーに対
応する値が存在しない時のデフォルト値です。設定したデフォルト値は[[m:Hash#default]]で参照できます。

ifnoneを省略した Hash.new は {} と同じです。

@param ifnone キーに対応する値が存在しない時のデフォルト値です。デフォルト値の扱いには注意が必要です( [[trap:Hash]] )

  h = Hash.new("foo")
  p h[1]                  # => "foo"

#@if (version >= "1.8.0")
--- new {|hash, key| ...} -> Hash
空の新しいハッシュを生成します。ブロックの評価結果がデフォルト値になりま
す。設定したデフォルト値は[[m:Hash#default_proc]]で参照できます。

値が設定されていないハッシュ要素を参照するとその都度ブロックを
実行し、その結果を返します（ハッシュにもその結果が追加されます）。
ブロックにはそのハッシュとハッシュを参照したときのキーが渡されます。

@raise ArgumentError ブロックと通常引数を同時に与えると発生します。

  # ブロックではない場合デフォルト値の変更により
  # 他の値も変更されたように見える
  h = Hash.new("foo")
  p h[1]                  # => "foo"
  p h[1] << "bar"         # => "foobar"
  p h[1]                  # => "foobar"
  p h[2]                  # => "foobar"
  p h                     # => {}
  
  
  # ブロックを使うとうまく行く
  h = Hash.new {|hash, key| hash[key] = "foo"}
  p h[1]                  # => "foo"
  p h[1] << "bar"         # => "foobar"
  p h[1]                  # => "foobar"
  p h[2]                  # => "foo"
  p h                     # => {1=>"foobar", 2=>"foo"}

  # 値が設定されていないときに(fetchのように)例外をあげるようにもできる
  h = Hash.new {|hash, key|
                  raise(IndexError, "hash[#{key}] has no value")
               }
  h[1]
  # => hash[1] has no value (IndexError)
#@else
  h = Hash.new("foo")
  p h[1]                  # => "foo"
  p h[1] << "bar"         # => "foobar"
  p h[1]                  # => "foobar"
  p h[2]                  # => "foobar"
  p h                     # => {}
#@end

@see [[m:Hash#default=]],[[m:Hash#default]],[[m:Hash#default_proc]]

== Instance Methods

--- values -> [object]

ハッシュの全値の配列を返します。

   h1 = { "a" => 100, 2 => ["some"], :c => "c" }
   p h1.values         #=> ["c", 100, ["some"]]

@see [[m:Hash#keys]],[[m:Hash#to_a]]

--- to_a -> [Array]

キーと値からなる 2 要素の配列を並べた配列を生成して返します。

   h1 = { "a" => 100, 2 => ["some"], :c => "c" }
   p h1.to_a           #=> [[:c, "c"], ["a", 100], [2, ["some"]]]

@see [[m:Hash#keys]],[[m:Hash#values]]

--- keys -> [object]

全キーの配列を返します。

   h1 = { "a" => 100, 2 => ["some"], :c => "c" }
   p h1.keys           #=> [:c, "a", 2]

@see [[m:Hash#values]],[[m:Hash#to_a]]

--- to_hash -> self

self を返します。

--- length -> Integer
--- size -> Integer

ハッシュの要素の数を返します。

#@if (version >= "1.9.0")
  puts({ant: 9 ,dog: 101 ,cat: 3}.length) #=> 3
#@else
  puts({:ant => 9 ,:dog => 101 ,:cat => 3}.length) #=> 3
#@end

--- empty? -> bool

ハッシュが空の時真を返します。

  puts {}.empty? #=> true

--- invert -> Hash

値からキーへのハッシュを作成して返します。

異なるキーに対して等しい値が登録されている場合の結果は不定であることに
注意してください、そのような場合にこのメソッドを利用することは意図され
ていません。

  h = { "n" => 100, "m" => 100, "y" => 300, "d" => 200, "a" => 0 }
  p h.invert   #=> {200=>"d", 300=>"y", 0=>"a", 100=>"n"}

@see [[m:Hash#key]]

--- fetch(key) -> object
--- fetch(key, default) -> object
--- fetch(key) {|key| ... } -> object

key に関連づけられた値を返します。該当するキーが登録されてい
ない時には、引数 default が与えられていればその値を、ブロッ
クが与えられていればそのブロックを評価した値を返します。

#@if (version >= "1.9.0")
そのいずれでもなければ例外 [[c:KeyError]] が発生します。
#@else
そのいずれでもなければ例外 [[c:IndexError]] が発生します。
#@end

fetchはハッシュ自身にデフォルト値が設定されていても無視します（挙動に変化がありません）。

@param key 探索するキーを指定します。
@param default 該当するキーが登録されていない時の返り値を指定します。
#@if (version >= "1.9.0")
@raise  KeyError
#@else
@raise  IndexError
#@end
     引数defaultもブロックも与えられてない時、キーの探索に失敗すると発生します。

#@if (version >= "1.9.0")
  h = {one: nil}
  p h[:one],h[:two]                        # => nil,nil キーが存在するのか判別できない。
  p h.fetch(:one)                          # => nil
  p h.fetch(:two)                          # => エラー key not found (KeyError)
  p h.fetch(:two,"error")                  # => "error"
  p h.fetch(:two){|key|"#{key} not exit"}  # => "two not exit"
  
  h.default = "default"
  p h.fetch(:two)                          # => エラー key not found (KeyError)
#@else
  h = {:one => nil}
  p h[:one],h[:two]                        # => nil,nil キーが存在するのか判別できない。
  p h.fetch(:one)                          # => nil
  p h.fetch(:two)                          # => エラー key not found (IndexError)
  p h.fetch(:two,"error")                  # => "error"
  p h.fetch(:two){|key|"#{key} not exit"}  # => "two not exit"
  
  h.default = "default"
  p h.fetch(:two)                          # => エラー key not found (IndexError)
#@end

@see [[m:Hash#[] ]]

--- has_key?(key) -> bool
--- include?(key) -> bool
--- key?(key) -> bool
--- member?(key) -> bool

ハッシュが key をキーとして持つ時真を返します。

@param key 探索するキーを指定します。

  {1 => "one"}.has_key?(1) => true
  {1 => "one"}.has_key?(2) => false

@see [[m:Hash#has_value?]]

--- has_value?(value) -> bool
--- value?(value) -> bool

ハッシュが value を値として持つ時真を返します。
値の一致判定は == で行われます。

@param value 探索する値を指定します。

  {1 => "one"}.has_value?("one") => true
  {1 => "one"}.has_value?("two") => false

@see [[m:Hash#has_key?]]

--- []=(key, value) -> object
--- store(key,value) -> object

key に対して value を関連づけます。value を返し
ます。

@param key キーを指定します。
@param value 値を 指定します。

  
  h = {}
  h[:key] = "value"
  p h #=>{:key=>"value"}

@see [[m:Hash#[] ]]

--- clear -> self

ハッシュの中身を空にします。

空にした後のselfを返します。
デフォルト値の設定はクリアされません。

  h = Hash.new("default value")
  h[:some] = "some"
  p h #=> {:some=>"some"}
  
  h.clear
  
  p h #=> {}
  p h.default #=> "default value"

#@since 1.9.0
--- compare_by_identity -> self

ハッシュのキーの一致判定をオブジェクトの同一性で判定するように変更します。

デフォルトでは、キーのオブジェクトによっては内容が同じならキーが一致しているとみなされますが、より厳密に
[[m:Object#object_id]]が一致しているかどうかを条件とするようにselfを変更します。

selfも変更される破壊的メソッドです。

#@#Makes hsh to compare its keys by their identity, i.e. it will
#@#consider exact same objects as same keys.

@return selfを返します。

   h1 = { "a" => 100, "b" => 200, :c => "c" }
   p h1.compare_by_identity? #=> false
   p h1["a"]        #=> 100
   
   h1.compare_by_identity
   
   p h1.compare_by_identity? #=> true
   p h1["a"]        #=> nil  # この"a"と最初の"a"とは違うオブジェクト
   p h1[:c]         #=> "c"  # 同じ内容のシンボルはすべて同一

@see [[m:Hash#compare_by_identity?]]

--- compare_by_identity? -> bool

ハッシュがキーの一致判定をオブジェクトの同一性を用いて行っているならばtrueを返します。

@see [[m:Hash#compare_by_identity]]

#@end
--- shift -> [object,object]

ハッシュから要素をひとつ取り除き、[key,value]という配列とし
て返します。shiftがどの要素を返すかは不定です。

shiftは破壊的メソッドです。selfは要素を取り除かれた残りのハッシュに変更されます。

ハッシュが空の場合、デフォルト値（[[m:Hash#default]]または[[m:Hash#default_proc]]の値か、どちらもnilならばnil）
を返します(このとき、
[key,value] という形式の値を返すわけではないことに注意)。

  h = {:ab => "some" , :cd => "all"}
  p h.shift               # => [:ab, "some"]
  p h.shift               # => [:cd, "all"]
  p h                     # => {}
  p h.shift               # => nil
  
  h1 = Hash.new("default value")
  p h1                    # => {}
  p h1.shift              # => "default value"
#@if (version >= "1.8.0")
  h2 = Hash.new {|*arg| arg}
  p h2                    # => {}
  p h2.shift              # => [{}, nil]
#@end
@see [[m:Array#shift]]
--- replace(other) -> self

ハッシュの内容を other の内容で置き換えます。
デフォルト値の設定もotherの内容になります。

self = other.dup と同じです。

@param other 置き換えるハッシュを指定します。
@return self を返します。

  foo = {1 => 'a', 2 => 'b'}
  bar = {2 => 'B', 3 => 'C'}
  foo.replace(bar)
  p foo  #=> {2=>"B", 3=>"C"}
  
  zoo = {}
  zoo = bar.dup
  p zoo  #=> {2=>"B", 3=>"C"}
  
@see [[m:Hash#dup]],[[m:Hash#merge]]
  
--- [](key) -> object
key に関連づけられた値を返します。該当するキーが登録されていない時には、
デフォルト値（[[m:Hash#default]]または[[m:Hash#default_proc]]の値か、どちらもnilならばnil）
を返します。

値としての nil と区別する必要がある場合は [[m:Hash#fetch]]または[[m:Hash#has_key?]]を使ってください。

@param key 探索するキーを指定します。

  h = {:ab => "some" , :cd => "all"}
  p h[:ab]             # => "some"
  p h[:ef]             # => nil
  
  h1 = Hash.new("default value")
  p h1[:non]             # => "default value"
  
  h2 = Hash.new {|*arg| arg}
  p h2[:non]             # => [{}, :non]

@see [[m:Hash#fetch]],[[m:Hash#values_at]],[[m:Hash#has_key?]]

--- default -> object
#@if (version >= "1.7.0")
--- default(key) -> object
#@end

ハッシュのデフォルト値を返します。
#@if (version >= "1.7.0")
ハッシュのデフォルト値がブロックで与えられている場合、1番目の形式だと
返り値がnilになることに注意してください。
ブロックのデフォルト値について調べる時は2番目の形式か
[[m:Hash#default_proc]]を使ってください。

2 番目の形式はハッシュがデフォルト値としてブロックを持つ場合
([[m:Hash.new]]参照)に指定できます。self と 引数
key を引数にブロックを実行してその結果を返します。

@param key デフォルトのブロックにキーとして渡されます。
#@end
  
  h = Hash.new("default")
  p h.default #=>"default"
  p h.default(:some) #=>"default"
  p h #=>{}
  
  h = Hash.new{|hash,key|hash[key] ="default" }
  p h.default #=>nil
  p h.default(:some) #=>"default"
  p h #=>{:some=>"default"}
  
  h = Hash.new
  p h.default #=>nil
  p h.default(:some) #=>nil
  p h #=>{}

@see [[m:Hash#default=]],[[m:Hash#default_proc]]

--- default=(value)

ハッシュのデフォルト値を value に設定します。対応する値が存
在しないキーで検索した時にはこの値を返します。

デフォルト値（ブロックを含む）が既に設定してあった場合も value で上書きします。

@param value 設定するデフォルト値です。
@return value を返します。

  h = {}
  p h.default(:some) #=>nil
  
  h.default = "default"
  p h.default(:some) #=>"default"

@see [[m:Hash#default]]

--- default_proc -> Proc|nil

ハッシュのデフォルト値を返す [[c:Proc]] オブジェクトを返します。
ハッシュがブロックのデフォルト値を持たない場合 nil を返します。

  h = Hash.new {|h, k| }
  p h.default            # => nil
  p h.default_proc       # => #<Proc:0x0x401a9ff4>

  h = Hash.new("default")
  p h.default            # => "default"
  p h.default_proc       # => nil

@see [[m:Hash#default]]

--- clone -> Hash
--- dup -> Hash

レシーバと同じ内容を持つ新しいハッシュを返します。

clone は frozen tainted singleton-class の情報も含めてコピーしますが、 dup は内容だけをコピーします。
またどちらのメソッドも要素それ自体のコピーはしません。つまり参照しているオブジェクトが
変わらない「浅い(shallow)」コピーを行います。

  h1 = {"have" => "have a","as" => "as a" }
  h2 = h1.dup
  
  h2["have"] = "has"
  p h2 #=> {"have"=>"has", "as"=>"as a"}
  p h1 #=> {"have"=>"have a", "as"=>"as a"}
  
  h2["as"].upcase!
  p h2 #=> {"have"=>"has", "as"=>"AS A"}
  p h1 #=> {"have"=>"have a", "as"=>"AS A"}

@see [[m:Object#clone]]

--- delete(key) -> object|nil
--- delete(key) {|key| ... } -> object

key に対応する値を取り除きます。取り除かれた値を返しますが、
key に対応する値が存在しない時には nil を返します。

ブロックが与えられた時には key にマッチするものがな
かった時に評価し、その結果を返します。

@param key 取り除くキーを指定します。

  h = {:ab => "some" , :cd => "all"}
  
  p h.delete(:ab) #=> "some"
  p h.delete(:ef) #=> nil
  p h.delete(:ef){|key|"Nothing"} #=> "Nothing"
  
  p h #=> {:cd=>"all"}

@see [[m:Hash#delete_if]]

--- reject {|key, value| ... } -> Hash

self を複製して、ブロックを評価した値が真になる要
素を削除したハッシュを返します。

ハッシュを返すことを除けば
[[m:Enumerable#reject]] とほぼ同じです。
selfを破壊的に変更したい場合はかわりに[[m:Hash#delete_if]]か[[m:Hash#reject!]]を使います。

  h = { 2 =>"8" ,4 =>"6" ,6 =>"4" ,8 =>"2" }
  p h.reject{|key, value| key.to_i < value.to_i} #=> {6=>"4", 8=>"2"}

@see [[m:Hash#delete_if]],[[m:Hash#delete]],[[m:Enumerable#reject]]

--- delete_if {|key, value| ... } -> self
--- reject! {|key, value| ... } -> self|nil

key と value を引数としてブロックを評価した値が真であ
る時、その要素を self から削除します。

delete_if は常に self を返します。
reject! は、要素を削除しなかった場合には nil を返し、
そうでなければ self を返します。

  h = { 2 =>"8" ,4 =>"6" ,6 =>"4" ,8 =>"2" }
  p h.reject!{|key, value| key.to_i < value.to_i} #=> {6=>"4", 8=>"2"}
  p h #=> {6=>"4", 8=>"2"}
  
  p h.delete_if{|key, value| key.to_i < value.to_i} #=> {6=>"4", 8=>"2"}
  p h.reject!{|key, value| key.to_i < value.to_i} #=> nil

@see [[m:Hash#reject]],[[m:Hash#delete]]

--- each {|key, value| ... } -> self
--- each_pair {|key, value| ... } -> self
#@if (version >= "1.9.0")
--- each -> Enumerable::Enumerator
--- each_pair -> Enumerable::Enumerator
#@end

ハッシュのキーと値を引数としてブロックを評価します。

反復の際の評価順序は不定です。
#@if (version >= "1.9.0")
ブロック付きの場合selfを、
無しで呼ばれた場合Enumerable::Enumeratorを返します。
#@else
self を返します。
#@end

#@if (version >= "1.8.0")
each と each_pair ではブロックパラメータの受渡し方が異なります。

  each      は yield([key, val])
  each_pair は yield(key, val)

ですので、each_pair のブロックパラメータに一つの変数を指
定して[key, val]の配列を得たい場合は、*記号を使って明示的に配列で
受け取るようにしてください。引数がひとつなのに*を使わない場合警告が出ます。
詳細は、[[unknown:メソッド呼び出し/yield]] を参照してください。
#@end
  {:a=>1, :b=>2}.each {|a| p a}
  # => [:a, 1]
       [:b, 2]
  
  {:a=>1, :b=>2}.each_pair {|k, v| p [k, v]}
  # => [:a, 1]
       [:b, 2]
  
  {:a=>1, :b=>2}.each_pair {|*a| p a}
  # => [:a, 1]
       [:b, 2]
  
#@if (version >= "1.9.0")
  p({:a=>1, :b=>2}.each_pair)  # => #<Enumerable::Enumerator:0xbb19e4>
#@end

@see [[m:Hash#each_key]],[[m:Hash#each_value]]

--- each_key {|key| ... } -> self
#@if (version >= "1.9.0")
--- each_key -> Enumerable::Enumerator
#@end

ハッシュのキーを引数としてブロックを評価します。

反復の際の評価順序は不定です。
#@if (version >= "1.9.0")
ブロック付きの場合selfを、
無しで呼ばれた場合Enumerable::Enumeratorを返します。
#@else
self を返します。
#@end

  {:a=>1, :b=>2}.each_key {|k| p k}
  # => :a
       :b
  
#@if (version >= "1.9.0")
  p({:a=>1, :b=>2}.each_key)  # => #<Enumerable::Enumerator:0xbb19e4>
#@end

@see [[m:Hash#each_pair]],[[m:Hash#each_value]]

--- each_value {|value| ... } -> self
#@if (version >= "1.9.0")
--- each_value -> Enumerable::Enumerator
#@end

ハッシュの値を引数としてブロックを評価します。

反復の際の評価順序は不定です。
#@if (version >= "1.9.0")
ブロック付きの場合selfを、
無しで呼ばれた場合Enumerable::Enumeratorを返します。
#@else
self を返します。
#@end

  {:a=>1, :b=>2}.each_value {|v| p v}
  # => 1
       2
  
#@if (version >= "1.9.0")
  p({:a=>1, :b=>2}.each_key)  # => #<Enumerable::Enumerator:0xbb19e4>
#@end

@see [[m:Hash#each_pair]],[[m:Hash#each_key]]

#@if (version < "1.9.0")
--- index(val) -> object
#@end
#@since 1.9.0
--- key(val) -> object
#@end

値 val に対応するキーを返します。対応する要素が存在しない時には
nil を返します。

該当するキーが複数存在する場合、どのキーを返すかは不定です。

#@if (version >= "1.8.0")
#@if (version < "1.9.0")
Hash#index は 次バージョンの1.9では((<obsolete>)) です。
使用すると警告メッセージが表示されます。
#@end
#@end
@param val 探索に用いる値を指定します。

#@if (version >= "1.8.0")
  h = {:ab => "some" , :cd => "all" , :ef => "all"}
  p h.key("some") #=> :ab
  p h.key("all") #=> :cd
  p h.key("at") #=> nil
#@else
  h = {:ab => "some" , :cd => "all" , :ef => "all"}
  p h.index("some") #=> :ab
  p h.index("all") #=> :cd
  p h.index("at") #=> nil
#@end

@see [[m:Hash#invert]]

#@if (version >= "1.8.0")
--- values_at(key_1, ... ,key_n) -> [object]

引数で指定されたキーに対応する値の配列を返します。
[self[key_1], ... ,self[key_n]]と同じです。

キーに対応する値がなければ デフォルト値（[[m:Hash#default]]または[[m:Hash#default_proc]]の値か、
どちらもnilならばnil）
が使用されます。

@param key_1, ... ,key_n キーを指定します。

  h = {1=>"a", 2=>"b", 3=>"c"}
  p h.values_at(1,3,4)               # => ["a", "c", nil]

@see [[m:Hash#[] ]],[[m:Array#values_at]]
#@end

#@if (version < "1.9.0")
--- indexes(key_1, ... , key_n)
--- indices(key_1, ... , key_n)

引数で指定されたキーに対応する値の配列を返します。

#@if (version >= "1.8.0")
このメソッドは ((<obsolete>)) です。
使用すると警告メッセージが表示されます。
代わりに [[m:Hash#values_at]] を使用してください。
#@else
[self[key_1], ... ,self[key_n]]と同じです。

キーに対応する値がなければ デフォルト値（[[m:Hash#default]]または[[m:Hash#default_proc]]の値か、
どちらもnilならばnil）が使用されます。
#@end

@param key_1, ... ,key_n キーを指定します。

#@if (version < "1.8.0")

  h = {1=>"a", 2=>"b", 3=>"c"}
  p h.indices(1,3,4)               # => ["a", "c", nil]
#@end

@see [[m:Hash#values_at]],[[m:Hash#[] ]]
#@end

--- rehash -> self

キーのハッシュ値を再計算します。

キーになっているオブジェクトの内容が変化した時など、
ハッシュ値が変わってしまった場合はこのメソッドを使ってハッシュ値を再計算しない
限り、そのキーに対応する値を取り出すことができなくなります。

@raise RuntimeError [[m:Hash#each]]などのイテレータの評価途中でrehashすると発生します。
@return selfを返します。

  a = [ "a", "b" ]
  c = [ "c", "d" ]
  h = { a => 100, c => 300 }
  p h[a]       #=> 100
  a[0] = "z"
  p h[a]       #=> nil
  h.rehash
  p h[a]       #=> 100

@see [[m:Object#hash]]

#@if (version >= "1.8.0")
--- merge(other) -> Hash
--- merge(other) {|key, self_val, other_val| ... } -> Hash
--- merge!(other) -> self
--- merge!(other) {|key, self_val, other_val| ... } -> self

レシーバのハッシュの内容をotherでマージした結果を返します。デフォルト値はレシーバの設定のままです。

self と other に同じキーがあった場合はブロック付きか否かで
判定方法が違います。ブロック付きのときはブロックを呼び出して
その返す値を重複キーに対応する値にします。ブロック付きでない
場合は常に other の値を使います。

Hash#merge! は、マージの結果でselfを変更する破壊的メソッドで、[[m:Hash#update]] の別名です。

@param other 上書きに用いるハッシュです。
@return マージした結果を返します

  foo = {1 => 'a', 2 => 'b', 3 => 'c'}
  bar = {2 => 'B', 3 => 'C', 4 => 'D'}
  
  p foo.merge(bar) #=> {1=>"a", 2=>"B", 3=>"C", 4=>"D"}
  p foo  #=> {1=>"a", 2=>"b", 3=>"c"}
  
  p foo.merge!(bar) {|key, foo_val, bar_val| foo_val + bar_val } #=> {1=>"a", 2=>"bB", 3=>"cC", 4=>"D"}
  p foo  #=> {1=>"a", 2=>"bB", 3=>"cC", 4=>"D"}

@see [[m:Hash#update]],[[m:Hash#replace]]
#@end

#@if (version >= "1.8.0")
--- update(other) -> self
--- update(other) {|key, self_val, other_val| ... } -> self

ハッシュの内容をotherでマージします。[[m:Hash#merge!]]と同じです。

@param other 上書きに用いるハッシュです。
@return マージ後のselfを返します。

@see [[m:Hash#merge!]]

#@else
--- update(other) -> self

ハッシュの内容をotherでマージします。重複するキーは常にotherで上書きします。

@param other 上書きに用いるハッシュです。
@return マージ後のselfを返します。

  foo = {1 => 'a', 2 => 'b', 3 => 'c'}
  bar = {2 => 'B', 3 => 'C', 4 => 'D'}
  
  p foo.update(bar) #=> {1=>"a", 2=>"B", 3=>"C", 4=>"D"}
  p foo  #=> {1=>"a", 2=>"B", 3=>"C", 4=>"D"}

#@end

