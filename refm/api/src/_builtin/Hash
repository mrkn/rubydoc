= class Hash < Object
include Enumerable

ハッシュテーブル(連想配列とも呼ぶ)のクラス。ハッシュは任意の種類のオブ
ジェクトから任意の種類のオブジェクトへの関連づけを行うことができます。
ハッシュ生成は以下のようなハッシュ式で行われます。

  #aはキー、bは値
  {a=>b, ... }
#@if (version >= "1.9.0")
  {s:b , ... }   #{ :s => b, ... } と同じ。キーがシンボルの場合の略記法p
#@end

ハッシュの格納に用いられるハッシュ値の計算には、
[[m:Object#hash]] メソッドが使われ、キーの同一性判定には、
[[m:Object#eql?]] メソッドが使われます。

キーとして与えたオブジェクトの内容が変化し、メソッド hash の返す
値が変わるとハッシュから値が取り出せなくなりますから、[[c:Array]]、
[[c:Hash]] などのインスタンスはキーに向きません。文字列をキーとして与
えると、文字列をコピーし、コピーを更新不可に設定(freeze)してキーとして
使用します。キーとして使われている文字列を更新しようとすると例外
[[c:TypeError]] が発生します。

##
ハッシュのキーに用いるオブジェクトは[[m:Object#eql?]]で同一性の判定を
行いますが、オブジェクトを直接比較するかわりに、ハッシュ値という
固有の整数で比較します。ハッシュ値の計算は、[[m:Object#hash]]で行います。
キーとして用いたいオブジェクトはこの２つのメソッドを適切に定義している必要が
あります。

キーとして与えたオブジェクトの内容が変化し、メソッド hash の返す
値が変わるとハッシュから値が取り出せなくなりますから、[[c:Array]]、
[[c:Hash]] などのインスタンスはキーに向きません。
[[m:Hash#rehash]]を参照。
ただ、キーとして用いられることが多い文字列は、そのコピーを更新不可に設定
(freeze)してキーとして用いることで、変更不可にしてあります。
キーとして使われている文字列を更新しようとすると例外[[c:TypeError]] が発生します。
##
== Class Methods

--- [](key,value,...)  -> Hash
--- [](hash=nil) -> Hash

新しいハッシュを生成します。一番目の形式では、引数は必ず偶数個指定
しなければなりません。(奇数番目がキー、偶数番目が値)。

二番目の形式(1つのハッシュオブジェクトを引数に指定した場合)は、指
定したハッシュと同一のキーと値を持つ新たなハッシュを生成して返しま
す。(生成されたハッシュのデフォルト値は nil です。)
引数を与えなかった場合は空のハッシュを生成します（{}と同じ）

@param key 生成するハッシュのキーです。
@param value 生成するハッシュの値です。
@param hash 生成元となるハッシュです
@raise ArgumentError 一番目の形式で奇数個の引数を与えたときに発生します。

以下は配列からハッシュを生成する方法の例です(より直接的な方法があ
るのではと思うかも知れませんが残念ながらありません)。
#@if (version < "1.7.0")
(1) [キー, 値, ...] の配列からハッシュへ

  ary = [1,"a", 2,"b", 3,"c"]
  p Hash[*ary]
  
  # => {1=>"a", 2=>"b", 3=>"c"}

(2) キーと値のペアの配列からハッシュへ

  alist = [[1,"a"], [2,"b"], [3,"c"]]
  p Hash[*alist.flatten]
  
  #=> {1=>"a", 2=>"b", 3=>"c"}

(3) キーや値が配列だと (2) の方法は使えないので地道に代入するしかない

  h = Hash.new
  alist = [[1,["a"]], [2,["b"]], [3,["c"]]]
  alist.each {|k,v|
    h[k] = v
  }
  p h
  
  #=> {1=>["a"], 2=>["b"], 3=>["c"]}
  
(4) キーと値の配列のペアからハッシュへ（地道に代入）

  keys = [1, 2, 3]
  vals = ["a", "b", "c"]
  h={}
  
  keys.each_with_index{|key,n| h[key] = vals[n]}
  p h
  
  #=> {1=>"a", 2=>"b", 3=>"c"}

#@end
#@if ("1.7.0" <= version)
#@if (version < "1.9.0")
(1) [キー, 値, ...] の配列からハッシュへ

  ary = [1,"a", 2,"b", 3,"c"]
  p Hash[*ary]
  
  # => {1=>"a", 2=>"b", 3=>"c"}

(2) キーと値のペアの配列からハッシュへ

  alist = [[1,"a"], [2,"b"], [3,"c"]]
  p Hash[*alist.flatten]
  
  #=> {1=>"a", 2=>"b", 3=>"c"}

(3) キーと値の配列のペアからハッシュへ

  keys = [1, 2, 3]
  vals = ["a", "b", "c"]
  alist = keys.zip(vals)   # あるいは alist = [keys,vals].transpose
  p Hash[*alist.flatten]
  
  #=> {1=>"a", 2=>"b", 3=>"c"}

(4) キーや値が配列だと (2) や (3) の方法は使えないので地道に代入するしかない

  h = Hash.new
  alist = [[1,["a"]], [2,["b"]], [3,["c"]]]
  alist.each {|k,v|
    h[k] = v
  }
  p h
  
  #=> {1=>["a"], 2=>["b"], 3=>["c"]}
#@end
#@end
#@if (version >= "1.9.0")
(1) [キー, 値, ...] の配列からハッシュへ

  ary = [1,"a", 2,"b", 3,["c"]]
  p Hash[*ary]
  
  # => {1=>"a", 2=>"b", 3=>["c"]}

(2) キーと値のペアの配列からハッシュへ

  alist = [[1,"a"], [2,"b"], [3,["c"]]]
  p Hash[*alist.flatten(1)]
  
  #=> {1=>"a", 2=>"b", 3=>["c"]}

(3) キーと値の配列のペアからハッシュへ

  keys = [1, 2, 3]
  vals = ["a", "b", ["c"]]
  alist = keys.zip(vals)   # あるいは alist = [keys,vals].transpose
  p Hash[*alist.flatten(1)]
  
  #=> {1=>"a", 2=>"b", 3=>["c"]}
#@end
--- new(ifnone=nil) -> Hash
--- new {|hash, key| ...} -> Hash

空の新しいハッシュを生成します。ifnone はキーに対
応する値が存在しない時のデフォルト値です。
#@if (version >= "1.8.0")
ブロックの結果をデフォルト値にすることもできます。
#@end

@param ifnone キーに対応する値が存在しない時のデフォルト値です。
デフォルト値の扱いには注意が必要です( [[trap:Hash]] )

#@if (version >= "1.8.0")
ブロックを指定した場合は、ブロックの評価結果がデフォルト値になりま
す。値が設定されていないハッシュ要素を参照するとその都度ブロックを
実行し、その結果を返します。ブロックにはそのハッシュとハッシュを参
照したときのキーが渡されます。

  # ブロックではない場合デフォルト値の変更により
  # 他の値も変更されたように見える
  h = Hash.new("foo")
  p h[1]                  # => "foo"
  p h[1] << "bar"         # => "foobar"
  p h[1]                  # => "foobar"
  p h[2]                  # => "foobar"
  
  
  # ブロックを使うとうまく行く
  h = Hash.new {|hash, key| hash[key] = "foo"}
  p h[1]                  # => "foo"
  p h[1] << "bar"         # => "foobar"
  p h[1]                  # => "foobar"
  p h[2]                  # => "foo"
  
  # 値が設定されていないときに(fetchのように)例外をあげるようにもできる
  h = Hash.new {|hash, key|
                  raise(IndexError, "hash[#{key}] has no value")
               }
  h[1]
  # => hash[1] has no value (IndexError)
#@end

== Instance Methods

--- [](key) -> object
#@todo
key に関連づけられた値を返します。該当するキーが登
録されていない時には、デフォルト値(設定されていない時には
nil) を返します。
値としての nil と区別する必要がある場合は [[m:Hash#fetch]]
を使ってください。

@param key 探すキーを指定します。
状態が変化していると、rehashが必要です。

--- []=(key, value) -> object
--- store(key,value) -> object

key に対して value を関連づけます。value を返し
ます。
@param key キーを指定します。
@param value 値を指定します。
  
  h = {}
  h[:key] = "value"
  p h #=>{:key=>"value"}

--- clear -> self

ハッシュの中身を空にします。

空にした後のselfを返します。
デフォルト値の設定はクリアされません。

--- clone -> Hash
--- dup -> Hash

レシーバと同じ内容を持つ新しいハッシュを返します。

フリーズしたハッシュの clone は同様にフリーズされたハッシュを返しますが、
dup は内容の等しいフリーズされていないハッシュを返します。

--- default
#@if (version >= "1.7.0")
--- default(key)
#@end
#@todo

ハッシュのデフォルト値を返します。
#@if (version >= "1.7.0")
ハッシュのデフォルト値がブロックで与えられている場合、1番目の形式だと
返り値がnilになることに注意してください。
ブロックのデフォルト値について調べる時は2番目の形式か
[[m:Hash#default_proc]]を使ってください。
#@end
#@if (version >= "1.7.0")
2 番目の形式はハッシュがデフォルト値としてブロックを持つ場合
([[m:Hash#Hash.new]]参照)に指定できます。self と 引数
key を引数にブロックを実行してその結果を返します。
#@end
  
  h = Hash.new("default")
  p h.default #=>"default"
  p h.default(:some) #=>"default"
  p h #=>{}
  
  h = Hash.new{|hash,key|hash[key] ="default" }
  p h.default #=>nil
  p h.default(:some) #=>"default"
  p h #=>{:some=>"default"}
  
  h = Hash.new
  p h.default #=>nil
  p h.default(:some) #=>nil
  p h #=>{}
  
--- default=(value)
#@todo

ハッシュのデフォルト値を value に設定します。対応する値が存
在しないキーで検索した時にはこの値を返します。

value を返します。

--- default_proc
#@todo

ハッシュのデフォルト値を返す [[c:Proc]] オブジェクトを返します。
デフォルトの [[c:Proc]] を持たない場合 nil を返します。

  h = Hash.new {|h, k| }
  p h.default_proc        # => #<Proc:0x0x401a9ff4>

  h = Hash.new(1)
  p h.default_proc        # => nil

--- delete(key)
--- delete(key) {|key| ... }
#@todo

key に対する関連を取り除きます。取り除かれた値を返しますが、
key に対応する値が存在しない時には nil を返します。

ブロックが与えられた時には key にマッチするものがな
かった時に評価し、その結果を返します。

--- reject {|key, value| ... }
#@todo

self を複製して、ブロックを評価した値が真になる要
素を削除したハッシュを返します。

ハッシュを返すことを除けば
[[m:Enumerable#reject]] と同じです。

--- delete_if {|key, value| ... }
--- reject! {|key, value| ... }
#@todo

key と value を引数としてブロックを評価した値が真であ
る時、その要素を self から削除します。

delete_if は常に self を返します。
reject! は、要素を削除しなかった場合には nil を返し、
そうでなければ self を返します。

--- each {|key, value| ... }
--- each_pair {|key, value| ... }
#@todo

key と value を引数としてブロックを評価します。
self を返します。

  {:a=>1, :b=>2}.each_pair {|k, v| p [k, v]}

  # => [:a, 1]
       [:b, 2]

#@if (version >= "1.8.0")

each と each_pair ではブロックパラメータの受渡し方が異なります。

  each:      yield([key, val])
  each_pair: yield(key, val)

このことにより、each_pair のブロックパラメータに一つの変数を指
定した場合、以下のように警告が出ます。詳細は、
[[unknown:メソッド呼び出し/yield]] を参照してください。

  {:a=>1, :b=>2}.each_pair {|a| p a }
  # => -:1: warning: multiple values for a block parameter (2 for 1)
          from -:1
       [:a, 1]
       -:1: warning: multiple values for a block parameter (2 for 1)
          from -:1
       [:b, 2]
#@end

--- each_key {|key| ... }
#@todo

key を引数としてブロックを評価します。
self を返します。

--- each_value {|value| ... }
#@todo

valueを引数としてブロックを評価します。
self を返します。

--- empty?
#@todo

ハッシュが空の時真を返します。

--- fetch(key[, default])
--- fetch(key) {|key| ... }
#@todo

key に関連づけられた値を返します。該当するキーが登録されてい
ない時には、引数 default が与えられていればその値を、ブロッ
クが与えられていればそのブロックを評価した値を返します。そのいずれ
でもなければ例外 [[c:IndexError]] が発生します。

#@if (version >= "1.9.0")
[[c:IndexError]] の代わりに [[c:IndexError]] のサブクラスの
[[c:KeyError]] が発生します。)
#@end

--- has_key?(key)
--- include?(key)
--- key?(key)
--- member?(key)
#@todo

ハッシュが key をキーとして持つ時真を返します。

--- has_value?(value)
--- value?(value)
#@todo

ハッシュが value を値として持つ時真を返します。
値の一致判定は == で行われます。

--- index(val)
#@since 1.9.0
--- key(val)
#@todo
#@end

val に対応するキーを返します。対応する要素が存在しない時には
nil を返します。

該当するキーが複数存在する場合、どのキーを返すかは不定です。

#@if (version >= "1.9.0")
Hash#index は version 1.9 では、((<obsolete>)) です。
使用すると警告メッセージが表示されます。
#@end

#@if (version < "1.9.0")
--- indexes(key_1, ... , key_n)
--- indices(key_1, ... , key_n)
#@todo

引数で指定されたキーを持つ値の配列を返します。

#@if (version >= "1.8.0")
このメソッドは version 1.8 では、((<obsolete>)) です。
使用すると警告メッセージが表示されます。
代わりに [[m:Hash#values_at]] を使用します。
#@end
#@end

--- invert
#@todo

値からキーへのハッシュを返します。
異なるキーに対して等しい値が登録されている場合の結果は不定であることに
注意してください、そのような場合にこのメソッドを利用することは意図され
ていません。

  h = { "n" => 100, "m" => 100, "y" => 300, "d" => 200, "a" => 0 }
  h.invert   #=> {200=>"d", 300=>"y", 0=>"a", 100=>"n"}

--- keys -> [object]

全キーの配列を返します。

   h1 = { "a" => 100, 2 => ["some"], :c => "c" }
   p h1.keys           #=> [:c, "a", 2]

値の配列は[[m:Hash#values]]を、組になった配列は[[m:Hash#to_a]]を用います。

--- length
--- size
#@todo

ハッシュの要素の数を返します。

#@if (version >= "1.8.0")
--- merge(other)
--- merge(other) {|key, self_val, other_val| ... }
--- merge!(other)
--- merge!(other) {|key, self_val, other_val| ... }
#@todo

Hash#merge は、hash.dup.[[m:Hash#update]] と同じです。
Hash#merge! は、[[m:Hash#update]] の別名です。

self と other に同じキーがあった場合はブロック付きか否かで
判定方法が違います。ブロック付きのときはブロックを呼び出して
どちらの値を使うかをユーザに選択させます。ブロック付きでない
場合は常に other の値を使います。
#@end

--- rehash
#@todo

キーのハッシュ値を再計算します。キーになっているオブジェクトのハッシュ
値が変わってしまった場合、このメソッドを使ってハッシュ値を再計算しない
限り、そのキーに対応する値を取り出すことができなくなります。

--- replace(other)
#@todo

ハッシュの内容を other の内容で置き換えます。
self を返します。

--- shift
#@todo

ハッシュから要素をひとつ取り除き、[key,value] という配列とし
て返します。

ハッシュが空の場合、デフォルト値[[m:Hash#default]]を持たなければ
nil を、デフォルト値を持つならその値を返します(このとき、
[key,value] という形式の値を返すわけではないことに注意)。

  h = Hash.new
  p h.empty?              # => true
  p h[0]                  # => nil
  p h.shift               # => nil
  p h.default             # => nil
  h.each {|v| p v}        # =>
  p h.to_a                # => []

  h1 = Hash.new("default value")
  p h1.empty?             # => true
  p h1[0]                 # => "default value"
  p h1.shift              # => "default value"
  p h1.default            # => "default value"
  h1.each {|v| p v}       # =>
  p h1.to_a               # => []

#@if (version >= "1.8.0")
  # ruby 1.8 feature
  h2 = Hash.new {|arg| arg}
  p h2.empty?             # => true
  p h2[0]                 # => [{}, 0]
  p h2.shift              # => [{}, nil]
  p h2.default            # => [{}, nil]
  h2.each {|v| p v}       # =>
  p h2.to_a               # => []
#@end

--- to_a -> [Array]

キーと値からなる 2 要素の配列の配列を生成して返します。

   h1 = { "a" => 100, 2 => ["some"], :c => "c" }
   p h1.to_a           #=> [[:c, "c"], ["a", 100], [2, ["some"]]]

キーの配列は[[m:Hash#keys]]を、値の配列は[[m:Hash#values]]を用います。

--- to_hash
#@todo

self を返します。

--- update(other)
--- update(other) {|key, self_val, other_val| ... }
#@todo

ハッシュの内容をマージします。重複するキーに対応する値は
other の内容で上書きされます。

#@if (version >= "1.8.0")
ブロックが与えられた場合は、重複するキーごとにブロックを評価してそ
の結果をそのキーに対応する値にします。ブロックには引数としてキーと
self[key] 、other[key] が渡されます。

  foo = {1 => 'a', 2 => 'b', 3 => 'c'}
  bar = {1 => 'A', 2 => 'B', 3 => 'C'}
  p foo.dup.update(bar)                   # => {1=>"A", 2=>"B", 3=>"C"}
  p foo.dup.update(bar) {|k,v| v}         # => {1=>"a", 2=>"b", 3=>"c"}
#@end

self を返します。

--- values -> [object]

ハッシュの全値の配列を返します。


   h1 = { "a" => 100, 2 => ["some"], :c => "c" }
   p h1.values         #=> ["c", 100, ["some"]]

キーの配列は[[m:Hash#keys]]を、組になった配列は[[m:Hash#to_a]]を用います。

#@if (version >= "1.8.0")
--- values_at(key_1, ... ,key_n) -> [object]

引数で指定されたキーに対応する値の配列を返します。キーに対応する値
がなければ [[m:Hash#default]] の戻り値が使用されます。

#@#[[m:Hash#indexes]] と [[m:Hash#indices]] と同じです。
#@#言及の必要なし

  h = {1=>"a", 2=>"b", 3=>"c"}
  p h.values_at(1,3,4)               # => ["a", "c", nil]
#@end

#@since 1.9.0
--- compare_by_identity -> Hash

selfのキーの同一性判定をオブジェクトの同一性で判定するように変更します。

デフォルトでは、キーのオブジェクトによっては内容が同じなら一致しているとみなされますが、より厳密に
[[m:Object#object_id]]が一致しているかどうかを条件とするようにselfを変更します。

返り値だけでなくselfも変更される破壊的メソッドです。

#@#Makes hsh to compare its keys by their identity, i.e. it will
#@#consider exact same objects as same keys.

   h1 = { "a" => 100, "b" => 200, :c => "c" }
   p h1["a"]        #=> 100
   h1.compare_by_identity
   p h1.compare_by_identity? #=> true
   p h1["a"]        #=> nil  # この"a"と最初の"a"とは違うオブジェクト
   p h1[:c]         #=> "c"  # 同じ内容のシンボルはすべて同一

@return selfを返します。

--- compare_by_identity? -> bool

selfがキーの一致をオブジェクトの同一性を用いて行っているならばtrueを返します。
[[m:Hash#compare_by_identity]]を参照してください。

#@#Returns true if hsh will compare its keys by their identity.
#@#Also see Hash#compare_by_identity.

#@end
