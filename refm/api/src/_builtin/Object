= class Object

include Kernel

全てのクラスのスーパークラス。
オブジェクトの一般的な振舞いを定義します。

== Class Methods
--- new
#@todo

== Instance Methods

--- ==(other)
#@todo

self と other が等しければ真を返します。
デフォルトでは equal? と同じ効果です。

このメソッドは各クラスの性質に合わせて再定義するべきです。

--- ===(other)
#@todo

このメソッドは [[unknown:制御構造/case]] 文での比較に用いられます。
デフォルトは [[m:Object#==]] と同じ働きをしますが、
この挙動はサブクラスで所属性のチェックを実現するため
適宜再定義されます。

--- =~(other)
#@todo

右辺に正規表現オブジェクトを置いた正規表現マッチ obj =~ /RE/
をサポートするためのメソッドです。常に false を返します。

この定義により例えば

    nil =~ /re/

は正常に false を返します。

--- class
#@todo
#@if (version < "1.9.0")
--- type
#@todo
#@end

レシーバのクラスを返します。

#@if (version < "1.9.0")
Ruby 1.8 では type は obsolete となりました。
#@end

--- clone
--- dup
#@todo

オブジェクトの複製を作成して返します。

clone は freeze、taint、特異メソッドなどの情報も
含めた完全な複製を、dup はオブジェクトの内容のみの複製を
作ります。

clone や dup は「浅い(shallow)」コピーであることに注意
してください。オブジェクト自身を複製するだけで、オブジェクトの指し
ている先(たとえば配列の要素など)までは複製しません。

深い(deep)コピーが必要な場合には、
Marshal.load(Marshal.dump(obj))を
使ってください。ただしMarshal出来ないオブジェクトが
含まれている場合には使えません。

また複製したオブジェクトに対して

  obj.equal?(obj.clone)

は一般に成立しませんが

  obj == obj.clone

は多くの場合に成立します。

true, false, nil, [[c:Symbol]] オブジェクトなど
を複製しようとすると例外 [[c:TypeError]] が発生します。

#@if (version >= "1.8.0")
#@#Ruby 1.8 では、
[[c:Numeric]] オブジェクトなど immutable
(内容不変)であるオブジェクトを複製しようとすると
例外 [[c:TypeError]] が発生します。
#@end

--- display(out = $stdout)
#@todo

オブジェクトを out に出力します。以下のように定義されています。

  class Object
    def display(out=$stdout)
      out.print to_s
      nil
    end
  end

nil を返します。

--- eql?(other)
#@todo

二つのオブジェクトが等しければ真を返します。[[c:Hash]] で二つのキー
が等しいかどうかを判定するのに使われます。

このメソッドを再定義した時には [[m:Object#hash]] メソッ
ドも再定義しなければなりません。

eql? のデフォルトの定義は equal? と同じくオブジェクト
の同一性判定になっています。

--- equal?(other)
#@todo

other が self 自身の時、真を返します。

このメソッドを再定義してはいけません。

--- extend(*modules)
#@todo

引数で指定したモジュールのインスタンスメソッドを self の特異
メソッドとして追加します。self を返します。

[[m:Module#include]] は、クラス(のインスタンス)に機能を追加します
が、extend は、ある特定のオブジェクトだけにモジュールの機能を追加
したいときに使用します。

    module Foo
      def a
        'ok'
      end
    end

    obj = Object.new
    obj.extend Foo
    p obj.a         #=> "ok"

extend の機能は、「特異クラスに対する [[m:Module#include]]」
と言い替えることもできます。

#@if (version >= "1.8.0")
引数に複数のモジュールを指定した場合、最後
の引数から逆順に extend を行います。
#@end

--- freeze
#@todo

オブジェクトの内容の変更を禁止します。self を返します。

フリーズされたオブジェクトの変更は例外 [[c:TypeError]] を発生させます。

--- frozen?
#@todo

オブジェクトの内容の変更が禁止されているときに真を返します。

--- hash
#@todo

オブジェクトのハッシュ値を返します。[[c:Hash]] クラスでオブジェク
トを格納するのに用いられています。

A.eql?(B) が成立する時は必ず A.hash == B.hash も成立し
なければいけません。eql?を再定義した時には必ずこちらも合わせ
て再定義してください。

デフォルトでは、[[m:Object#__id__]] と同じ値を返します。
ただし、[[c:Fixnum]], [[c:Symbol]], [[c:String]] だけは組込みのハッ
シュ関数が使用されます(これを変えることはできません)。

hash を再定義する場合は、一様に分布する任意の整数を返すようにしま
す。

#@if (version < "1.9.0")
--- id
#@end
--- __id__
--- object_id
#@todo

各オブジェクトに対して一意な整数を返します。あるオブジェクトに対し
てどのような整数が割り当てられるかは不定です。

id メソッドの再定義に備えて別名 __id__ が用意されて
おり、ライブラリでは後者の利用が推奨されます。また __id__ を
再定義すべきではありません。

#@if (version < "1.9.0")
id は Ruby 1.8 では obsolete となりました。
#@end

--- inspect
#@todo

オブジェクトを人間が読める形式に変換した文字列を返します。

組み込み関数 [[m:Kernel#p]] は、このメソッドの結果を使用して
オブジェクトを表示します。

--- instance_eval(expr, filename = '(eval)', lineno = 1)
--- instance_eval {|obj| ... }
#@todo

オブジェクトのコンテキストで文字列 expr を評価してその結果を
返します。

filename、lineno が与えられた場合は、ファイル filename、
行番号 lineno にその文字列があるかのようにコンパイルされ、ス
タックトレース表示などのファイル名／行番号を差し替えることができま
す。

ブロックが与えられた場合にはそのブロックをオブジェクトのコンテキス
トで評価してその結果を返します。ブロックの引数 obj には
self が渡されます。

オブジェクトのコンテキストで評価するとは self をそのオブジェ
クトにして実行するということです。また、文字列／ブロック中でメソッ
ドを定義すれば self の特異メソッドが定義されます。

ただし、ローカル変数だけは instance_eval の外側のスコープと
共有します。

#@if (version < "1.8.0")
メソッド定義の中で instance_eval のブロックを使用してメ
ソッド定義を行うと、"nested method definition" とコンパイルエラー
になります。これは、現在の ruby パーサの制限です。

    def foo
       instance_eval {
         def bar            # <- ネストしたメソッド定義と判断される
           "bar"
         end
       }
    end

    # => -:4: nested method definition

文字列で渡す形式を使えば、この制限は回避できます。

    def foo
       instance_eval %Q{
         def bar
           "bar"
         end
       }
    end

    # foo を実行すると関数(厳密には foo のレシーバのメソッド) bar
    # を定義する
    foo
    p bar
    # => "bar"

メソッド定義のネストに関して、この制限はなくなっています。
さらに、Ruby 1.7 以降, instance_eval を使わなく
ても以下で同じことができます (厳密には異なります。
[[unknown:クラス／メソッドの定義/メソッド定義のネスト]]
を参照してください)。

    def foo
       def bar
         "bar"
       end
    end

    foo
    p bar
    # => "bar"
#@end

[[m:Module#module_eval]],
[[m:Module#class_eval]] も参照してください。

--- instance_of?(klass)
#@todo

self がクラス klass の直接のインスタンスである時、
真を返します。

obj.instance_of?(c) が成立する時には、常に
obj.kind_of?(c) も成立します。

[[m:Object#kind_of?]] も参照してください。

#@if (version >= "1.8.0")
--- instance_variable_get(var)
#@todo

オブジェクトのインスタンス変数の値を取得して返します。

var にはインスタンス変数名を文字列か [[c:Symbol]] で指定しま
す。

インスタンス変数が定義されていなければ nil を返します。

    class Foo
      def initialize
        @foo = 1
      end
    end

    obj = Foo.new
    p obj.instance_variable_get("@foo")     # => 1
    p obj.instance_variable_get(:@foo)      # => 1
    p obj.instance_variable_get(:@bar)      # => nil
#@end

#@if (version >= "1.8.0")
--- instance_variable_set(var, val)
#@todo

オブジェクトのインスタンス変数に値 val を設定して val
を返します。


var にはインスタンス変数名を文字列か [[c:Symbol]] で指定しま
す。

インスタンス変数が定義されていなければ新たに定義されます。

    obj = Object.new
    p obj.instance_variable_set("@foo", 1)  # => 1
    p obj.instance_variable_set(:@foo, 2)   # => 2
    p obj.instance_variable_get(:@foo)      # => 2
#@end

--- instance_variables
#@todo

オブジェクトのインスタンス変数名を文字列の配列として返します。

    obj = Object.new
    obj.instance_eval { @foo, @bar = nil }
    p obj.instance_variables

    # => ["@foo", "@bar"]

[[m:Kernel#local_variables]],
[[m:Kernel#global_variables]],
[[m:Module.constants]],
[[m:Module#constants]],
[[m:Module#class_variables]]
も参照してください。

#@since 1.8.6
--- instance_variable_defined?(symbol)
#@todo

Returns true if the given instance variable is defined in obj.

   class Fred
     def initialize(p1, p2)
       @a, @b = p1, p2
     end
   end
   fred = Fred.new('cat', 99)
   fred.instance_variable_defined?(:@a)    #=> true
   fred.instance_variable_defined?("@b")   #=> true
   fred.instance_variable_defined?("@c")   #=> fal
#@end

--- is_a?(mod)
--- kind_of?(mod)
#@todo

self が、クラス mod とそのサブクラス、および
モジュール mod をインクルードしたクラスとそのサブクラス、
のいずれかのインスタンスであるとき真を返します。

    module M
    end
    class C < Object
      include M
    end
    class S < C
    end

    obj = S.new
    p obj.is_a? S       # true
    p obj.is_a? M       # true
    p obj.is_a? C       # true
    p obj.is_a? Object  # true
    p obj.is_a? Hash    # false

[[m:Object#instance_of?]], [[m:Module#===]] も参照してください。

--- method(name)
#@todo

self のメソッド name をオブジェクト化した
[[c:Method]] オブジェクトを返します。name は
[[c:Symbol]] または文字列で指定します。

[[m:Module#instance_method]] も参照してください。

--- method_missing(name, *args, &block)
#@todo

呼びだされたメソッドが定義されていなかった時、Ruby がこのメソッド
を呼び出します。

呼び出しに失敗したメソッドの名前 ([[c:Symbol]]) が name に
その時の引数が arg ... に渡されます。

デフォルトではこのメソッドは例外 [[c:NameError]] を発生させます。

#@since 1.8.0
--- methods(include_inherited = true) -> [String]
--- instance_methods(include_inherited = true) -> [String]
#@else
--- methods -> [String]
--- instance_methods -> [String]
#@end
#@todo

そのオブジェクトに対して呼び出せるメソッド名の一覧を文字列の配列で返します。
#@since 1.8.0
このメソッドは public メソッドおよび protected メソッドの名前を返します。

第 1 引数 include_inherited が真のときは
スーパークラスで定義されたメソッドも探索します。
#@end

例:

    class Foo
      private;   def private_foo()   end
      protected; def protected_foo() end
      public;    def public_foo()    end
    end

#@since 1.8.0
    p Foo.new.methods(false)   # => ["protected_foo", "public_foo"]
#@else
    p Foo.new.methods(false)   # => ["public_foo"]
#@end

なお、methods(false) は [[m:Object#singleton_methods]](false) と同じです。

[[m:Module#instance_methods]],
[[m:Module#public_instance_methods]],
[[m:Module#private_instance_methods]],
[[m:Module#protected_instance_methods]],
[[m:Object#singleton_methods]]
も参照してください。

#@since 1.8.0
--- public_methods(include_inherited = true) -> [String]
#@else
--- public_methods -> [String]
#@end
#@todo

そのオブジェクトが理解できる public メソッド名の一覧を文字列の配列で返します。

#@since 1.8.0
第 1 引数 include_inherited が真のときは
スーパークラスで定義されたメソッドも探索します。
#@end

例:

    class Foo
      private;   def private_foo()   end
      protected; def protected_foo() end
      public;    def public_foo()    end
    end

    p Foo.new.public_methods(false)   # => ["public_foo"]

[[m:Module#instance_methods]],
[[m:Module#public_instance_methods]],
[[m:Module#private_instance_methods]],
[[m:Module#protected_instance_methods]],
[[m:Object#singleton_methods]]
も参照してください。

#@since 1.8.0
--- private_methods(include_inherited = true) -> [String]
#@else
--- private_methods -> [String]
#@end
#@todo

そのオブジェクトが理解できる private メソッド名の一覧を文字列の配列で返します。

#@since 1.8.0
第 1 引数 include_inherited が真のときは
スーパークラスで定義されたメソッドも探索します。
#@end

例:

    class Foo
      private;   def private_foo()   end
      protected; def protected_foo() end
      public;    def public_foo()    end
    end

    p Foo.new.private_methods(false)   # => ["private_foo"]

[[m:Module#instance_methods]],
[[m:Module#public_instance_methods]],
[[m:Module#private_instance_methods]],
[[m:Module#protected_instance_methods]],
[[m:Object#singleton_methods]]
も参照してください。

#@since 1.8.0
--- protected_methods(include_inherited = true) -> [String]
#@else
--- protected_methods -> [String]
#@end
#@todo

そのオブジェクトが理解できる protected メソッド名の一覧を文字列の配列で返します。

#@since 1.8.0
第 1 引数 include_inherited が真のときは
スーパークラスで定義されたメソッドも探索します。
#@end

例:

    class Foo
      private;   def private_foo()   end
      protected; def protected_foo() end
      public;    def public_foo()    end
    end

    p Bar.new.protected_methods   # => ["protected_foo"]

[[m:Module#instance_methods]],
[[m:Module#public_instance_methods]],
[[m:Module#private_instance_methods]],
[[m:Module#protected_instance_methods]],
[[m:Object#singleton_methods]]
も参照してください。

--- nil?
#@todo

レシーバが nil であれば真を返します。

--- respond_to?(name, include_private = false)
#@todo

オブジェクトが public メソッド name を持つとき真を返します。

name は [[c:Symbol]] または文字列です。priv が真のとき
は private メソッドに対しても真を返します。

--- send(name, *args)
--- send(name, *args) { .... }
--- __send__(name, *args)
--- __send__(name, *args) { .... }
#@todo

オブジェクトのメソッド name を、引数に args を
渡して呼び出し、メソッドの実行結果を返します。

ブロック付きで呼ばれたときはブロックもそのまま引き渡します。メソッ
ド名 name は文字列か[[c:Symbol]] です。

send が再定義された場合に備えて別名 __send__ も
用意されており、ライブラリではこちらを使うべきです。また
__send__ は再定義すべきではありません。

send, __send__ は、[[unknown:クラス／メソッドの定義/呼び出し制限]]
にかかわらず任意のメソッドを呼び出せます。

#@since 1.9.0
[[unknown:クラス／メソッドの定義/呼び出し制限]]が
send, __send__にも影響するようになり、
レシーバを指定した呼び出しでは private メソッドを呼び出せなくなりました。
privateメソッドを呼び出す必要がある場合は
[[m:Object#instance_eval]] を使用してください。
#@end

#@if (version < "1.8.0")
--- singleton_methods
#@else
#@if (version == "1.8.0")
--- singleton_methods(inherited_too = false)
#@else
#@if (version >= "1.8.0")
--- singleton_methods(inherited_too = true)
#@todo
#@end
#@end
#@end

そのオブジェクトに対して定義されている特異メソッド名
(public あるいは protected メソッド) の一覧を文字列の配列で返します。
inherited_too が偽であれば、
スーパークラスで定義されたメソッドは対象になりません。
singleton_methods(false) は、
[[m:Object#methods]](false) と同じです。

    obj = Object.new
    module Foo
      private;   def private_foo()   end
      protected; def protected_foo() end
      public;    def public_foo()    end
    end

    class <<obj
      include Foo
      private;   def private_bar()   end
      protected; def protected_bar() end
      public;    def public_bar()    end
    end
    p obj.singleton_methods
    p obj.singleton_methods(false)

    # => ["public_foo", "public_bar", "protected_foo", "protected_bar"]
         ["public_bar", "protected_bar"]

あるいは、[[m:Object#extend]] は特異クラスに対するイ
ンクルードなので以下も同様になります。

    obj = Object.new

    module Foo
      private;   def private_foo()   end
      protected; def protected_foo() end
      public;    def public_foo()    end
    end

    obj.extend(Foo)
    p obj.singleton_methods
    p obj.singleton_methods(false)

    # => ["public_foo", "protected_foo"]
         []

クラスメソッド (クラスオブジェクトの特異メソッド) に関しては
引数が真のとき、スーパークラスのクラスメソッドも対象になります。

    class Foo
      def Foo.foo
      end
    end

    class Bar < Foo
      def Bar.bar
      end
    end

    p Bar.singleton_methods        #=> ["bar", "foo"]
    p Bar.singleton_methods(false) #=> ["bar"]

--- taint
#@todo

オブジェクトの「汚染マーク」をセットします。self を返します。

オブジェクトの汚染に関しては[[unknown:セキュリティモデル]]を参照してください。

--- tainted?
#@todo

オブジェクトの「汚染マーク」がセットされている時真を返します。

オブジェクトの汚染に関しては[[unknown:セキュリティモデル]]を参照してください。

#@if (version < "1.9.0")
--- to_a
#@todo

[OBSOLETE] オブジェクトを配列に変換してその配列を返します。

配列に変換できないオブジェクトは、自身のみを含む長さ 1 の配
列に変換されます

#@since 1.8.0
このメソッドは将来なくなるかもしれません。
Ruby 1.8 では警告が出ます。

例:
    p( {'a'=>1}.to_a )  # [["a", 1]]
    p ['array'].to_a    # ["array"]
    p 1.to_a            # [1]       (warning: default `to_a' will be obsolete)
    p 'str'.to_a        # ["str"]
#@end

#@since 1.8.0
多重代入の右辺に * を伴ったオブジェクトが現れた場合、
そのオブジェクトが to_a を定義していればその結果が利用されます。
to_a が定義されていない場合は、右辺が自身を含む長さ 1 の配列に
変換された後で代入が行われます。
#@# あらい 2003-10-07: 覚書: 簡単に言えば、Array(右辺) と同じ
#@# 規則で右辺が変換される。この辺りの記述は整理しなおすこと

    class Foo
      def to_a
        [1, 2, 3]
      end
    end

    a, b, c = *Foo.new
    p [a, b, c]

    # => [1, 2, 3]
#@end
#@end
--- to_ary
#@todo

オブジェクトを配列に変換してその配列を返します。

オブジェクトの配列への暗黙の変換が必要なときに内部で呼ばれます。
#@# to_ary, to_hash, to_int, to_str は、説明の便宜上このページに書
#@# いてますが、デフォルトでは Object のメソッドとしては定義されていません

このメソッドが定義されたオブジェクトが単独で多重代入の右辺に
現れた場合にも呼ばれます。

    class Foo
      def to_ary
        [1, 2, 3]
      end
    end

    a, b, c = Foo.new
    p [a, b, c]

    => [1, 2, 3]

--- to_hash
#@todo

オブジェクトのハッシュへの暗黙の変換が必要なときに内部で呼ばれます。

--- to_int
#@todo

オブジェクトの整数への暗黙の変換が必要なときに内部で呼ばれます。

--- to_s
#@todo

オブジェクトの文字列表現を返します。

[[m:Kernel#print]] や [[m:Kernel#sprintf]] は文字列以外の
オブジェクトが引数に渡された場合このメソッドを使って文字列に変換し
ます。

--- to_str
#@todo

オブジェクトの文字列への暗黙の変換が必要なときに呼ばれます。

--- untaint
#@todo

オブジェクトの「汚染マーク」を取り除きます。self を返します。

汚染マークを取り除くことによる危険性はプログラマが責任を負う必要が
あります。

セキュリティレベルが3以上の場合は例外 [[c:SecurityError]] が
発生します。

オブジェクトの汚染に関しては[[unknown:セキュリティモデル]]を参照してください。

#@since 1.8.4
--- to_enum(method = :each, *args)
--- enum_for(method = :each, *args)
#@todo

[[m:Enumerable::Enumerator.new]](self, method, *args) を返します。

例:

  str = "xyz"

  enum = str.enum_for(:each_byte)
  a = enum.map {|b| '%02x' % b } #=> ["78", "79", "7a"]

  # protects an array from being modified
  a = [1, 2, 3]
  some_method(a.to_enum)
#@end

--- _dump(limit)
#@todo

Marshal.dump において出力するオブジェクトがメソッド `_dump'
を定義している場合には、そのメソッドの結果が書き出されます。メソッ
ド `_dump' は引数として再帰を制限するレベル limit を受
け取り、オブジェクトを文字列化したものを返します。

インスタンスがメソッド `_dump' を持つクラスは必ず同じフォー
マットを読み戻すクラスメソッド `_load' を定義する必要があり
ます。`_load' はオブジェクトを表現した文字列を受け取り、それ
をオブジェクトに戻したものを返す必要があります。

  class Foo
    def initialize(obj)
      p "initialize() called"
      @foo = obj
    end
    def _dump(limit)
      Marshal.dump(@foo, limit)
    end
    def self._load(obj)
      Foo.new(Marshal.load(obj))
    end
  end

  p Marshal.load(Marshal.dump(Foo.new(['foo', 'bar'])))

  => "initialize() called"
     "initialize() called"
     #<Foo:0x4019eb88 @foo=["foo", "bar"]>

インスタンス変数の情報は普通マーシャルデータに含まれるので、この例
のように _dump を定義する必要はありません(ただし _dump を定義すると
インスタンス変数の情報は dump されなくなります)。
_dump/_load はより高度な制御を行いたい場合や拡張ライブラリで定義し
たクラスのインスタンスがインスタンス変数以外に情報を保持する場合に
利用します。(例えば、クラス [[c:Time]] は、_dump/_load を定義して
います)

#@since 1.8.0
[[m:Object#marshal_dump]],
[[m:Object#marshal_load]] も参照してください。
#@end

#@since 1.8.0
--- marshal_dump
--- marshal_load(obj)
#@todo

[[m:Marshal.#dump]] において、出力するオブジェクトがメソッド
marshal_dump を定義している場合には、その戻り値がダンプされます。
メソッド marshal_dump は任意のオブジェクトを返すメソッドとし
て定義します。

このようなオブジェクトをロードするにはメソッド marshal_load が
定義されていなくてはならず、ロード時に利用されます。
marshal_load は marshal_dump の戻り値のコピーを引数に受け取
ります。marshal_load 時の self は、生成されたばかり
([[m:Class#allocate]] されたばかり) の状態です。
なお、marshal_load の戻り値は無視されます。

dump するオブジェクトが _dump と marshal_dump の両方のメソッドを
持つ場合 marshal_dump が利用されます。

  class Foo
    def initialize
      p "initialize() called"
      @foo = ['foo', 'bar']
    end
    def marshal_dump
      @foo
    end
    def marshal_load(obj)
      @foo = obj
    end
  end
  
  p Marshal.load(Marshal.dump(Foo.new))
  
  "initialize() called"
  #<Foo:0x4019ed2c @foo=["foo", "bar"]>

インスタンス変数の情報は普通マーシャルデータに含まれるので、
この例のように marshal_dump を定義する必要はありません
(ただし marsahl_dump を定義するとインスタンス変数の情報は
ダンプされなくなるので、marshal_dump/marshal_load で扱う必要があります)。
marshal_dump/marshal_load はより高度な制御を行いたい場合や
拡張ライブラリで定義したクラスのインスタンスがインスタンス変数以外
に情報を保持する場合に利用します。

特に、marshal_dump/marshal_load を定義したオブジェクトは
特異メソッドが定義されていてもマーシャルできるようになります
(特異メソッドの情報が自動的に dump されるようになるわけではなく、
marshal_dump/marshal_load によりそれを実現する余地があるということです)。

marshal_dump/marshal_load の仕組みは Ruby 1.8.0 から導入されました。
これから書くプログラムでは _dump/_load ではなく
marshal_dump/marshal_load を使うべきです。
#@# _dump/_load はまだ obsolete ではありませんが、将来そうなるかもしれません。
#@# [[ruby-dev:21088]]
#@end

== Private Methods

--- initialize
#@todo

ユーザ定義クラスのオブジェクト初期化メソッド。

このメソッドは [[m:Class#new]] から新しく生成されたオブ
ジェクトの初期化のために呼び出されます。デフォルトの動作ではなにも
しません。サブクラスではこのメソッドを必要に応じて再定義されること
が期待されています。initialize には
[[m:Class#new]] に与えられた引数がそのまま渡されます。

initialize という名前のメソッドは自動的に private に設定され
ます。

#@since 1.8.0
--- initialize_copy(obj)
#@todo

(拡張ライブラリによる) ユーザ定義クラスのオブジェクトコピー
(clone, dup) の初期化メソッド。

このメソッドは self を obj の内容で置き換えます。ただ
し、self のインスタンス変数や特異メソッドは変化しません。

レシーバが freeze されているか、obj のクラスがレシーバ
のクラスと異なる場合は例外 [[c:TypeError]] が発生します。

デフォルトの Object#initialize_copy は、
上記の freeze チェックおよび型のチェックを行い
self を返すだけのメソッドです。

obj.[[m:Object#dup]] は、新たに生成したオブジェクトに対して
initialize_copy を呼び

    obj2 = obj.class.allocate
    obj2.initialize_copy(obj)

obj2 に対してさらに obj の汚染状態、インスタンス変数、ファイナライ
ザをコピーすることで複製を作ります。[[m:Object#clone]] は、さらに
特異メソッドのコピーも行います。

    obj = Object.new
    class <<obj
      attr_accessor :foo
      def bar
        :bar
      end
    end

    def check(obj)
      puts "instance variables: #{obj.inspect}"
      puts "tainted?: #{obj.tainted?}"
      print "singleton methods: "
      begin
        p obj.bar
      rescue NameError
        p $!
      end
    end

    obj.foo = 1
    obj.taint

    check Object.new.send(:initialize_copy, obj)
            # => instance variables: #<Object:0x4019c9d4>
            #    tainted?: false
            #    singleton methods: #<NoMethodError: ...>
    check obj.dup
            # => instance variables: #<Object:0x4019c9c0 @foo=1>
            #    tainted?: true
            #    singleton methods: #<NoMethodError: ...>
    check obj.clone
            # => instance variables: #<Object:0x4019c880 @foo=1>
            #    tainted?: true
            #    singleton methods: :bar

initialize_copy は、Ruby インタプリンタが知り得ない情報をコピーするた
めに使用(定義)されます。例えば C 言語でクラスを実装する場合、情報
をインスタンス変数に保持させない場合がありますが、そういった内部情
報を initialize_copy でコピーするよう定義しておくことで、dup や clone
を再定義する必要がなくなります。

initialize_copy という名前のメソッドは
自動的に private に設定されます。
#@end

--- remove_instance_variable(name)
#@todo

オブジェクトからインスタンス変数 name を取り除き、そのインス
タンス変数に設定されていた値を返します。name は [[c:Symbol]]
か文字列です。

オブジェクトがインスタンス変数 name を持たない場合は例外
[[c:NameError]] が発生します。

    class Foo
      def foo
        @foo = 1
        p remove_instance_variable :@foo # => 1
        p remove_instance_variable :@foo # => instance variable @foo not defined (NameError)
      end
    end
    Foo.new.foo

[[m:Module#remove_class_variable]],
[[m:Module#remove_const]]
も参照してください。

--- singleton_method_added(name)
#@todo

特異メソッドが追加された時にインタプリタから呼び出されます。
name には追加されたメソッド名が [[c:Symbol]] で渡されます。

    class Foo
      def singleton_method_added(name)
        puts "singleton method \"#{name}\" was added"
      end
    end

    obj = Foo.new
    def obj.foo
    end

    => singleton method "foo" was added

通常のメソッドの追加に対するフックには
[[m:Module#method_added]]を使います。

#@since 1.8.0
--- singleton_method_removed(name)
#@todo

特異メソッドが [[m:Module#remove_method]] に
より削除された時にインタプリタから呼び出されます。
name には削除されたメソッド名が [[c:Symbol]] で渡されます。

    class Foo
      def singleton_method_removed(name)
        puts "singleton method \"#{name}\" was removed"
      end
    end

    obj = Foo.new
    def obj.foo
    end

    class << obj
      remove_method :foo
    end

    => singleton method "foo" was removed

通常のメソッドの削除に対するフックには
[[m:Module#method_removed]]を使います。
#@end

#@since 1.8.0
--- singleton_method_undefined(name)
#@todo

特異メソッドが [[m:Module#undef_method]] または
[[unknown:クラス／メソッドの定義/undef]]
により未定義にされた時に呼び出されます。
name には未定義にされたメソッド名が [[c:Symbol]] で渡されます。

    class Foo
      def singleton_method_undefined(name)
        puts "singleton method \"#{name}\" was undefined"
      end
    end

    obj = Foo.new
    def obj.foo
    end
    def obj.bar
    end

    class << obj
      undef_method :foo
    end
    obj.instance_eval {undef bar}

    => singleton method "foo" was undefined
       singleton method "bar" was undefined

通常のメソッドの未定義に対するフックには
[[m:Module#method_undefined]] を使います。
#@end
