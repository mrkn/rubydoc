== Module Functions

#@since 1.8.0
--- exit(status = true) -> ()
#@else
--- exit(status = 0) -> ()
#@end

Rubyプログラムの実行を終了します。status として整
数が与えられた場合、その値を Ruby コマンドの終了ステータスとします。
デフォルトの終了ステータスは 0(正常終了)です。

#@since 1.8.0
status が true の場合 0、 false の場合 1 を引数に指定したとみなされます。この値はCレベルの定数
EXIT_SUCCESS、EXIT_FAILURE の値なので、正確には環境依存です。
#@end

exit は例外 [[c:SystemExit]] を発生させ
ることによってプログラムの実行を終了させますので、
必要に応じて begin 節で捕捉することができます。

@param status 終了ステータスを整数か true または false で与えます。

  puts 'start'
  begin
    puts 'start1...'
    exit
  rescue SystemExit => err
    puts "end1 with #{err.inspect}"
  end
  
  begin
    puts 'start2...'
    exit
  ensure
    puts 'end2...'
  end
  puts 'end' #実行されない
  
  #=> start
  #   start1...
  #   end1 with #<SystemExit: exit>
  #   start2...
  #   end2...
  #終了ステータス:0

@see [[m:Kernel.#exit!]],[[m:Kernel.#abort]], [[ref:d:spec/control#begin]]

#@since 1.8.0
--- exit!(status = false) -> ()
#@else
--- exit!(status = -1) -> ()
#@end

Rubyプログラムの実行を即座に終了します。
status として整数が与えられた場合、その値を Ruby コマンドの終了ステータスとします。
#@since 1.8.0
デフォルトの終了ステータスは 1 です。
#@else
デフォルトの終了ステータスは -1 です。
#@end

#@since 1.8.0
status が true の場合 0、 false の場合 1 を引数に指定したとみなされます。この値はCレベルの定数
EXIT_SUCCESS、EXIT_FAILURE の値なので、正確には環境依存です。
#@end

exit! は exit とは違って、例外処理などは一切行ないませ
ん。 [[m:Kernel.#fork]] の後、子プロセスを終了させる時などに用
いられます。

@param status 終了ステータスを整数か true または false で与えます。

  STDOUT.sync = true #表示前に終了しないようにする
  puts 'start'
  begin
    puts 'start1...'
    exit!
  ensure
    puts 'end1...' #実行されない
  end
  puts 'end' #実行されない
  
  #=> start
  #   start1...
#@since 1.8.0
  #終了ステータス:1
#@else
  #終了ステータス:-1
#@end

@see [[m:Kernel.#exit]],[[m:Kernel.#abort]]

#@since 1.8.0
--- abort(message = $!.message) -> ()
#@else
--- abort -> ()
#@end

Ruby プログラムをエラーメッセージ付きで終了します。終了ステータスは 1 固定です。

このメソッドと [[m:Kernel.#exit]] との違いは、プログラムの終了ステー
タスが 1 (正確にはCレベルの定数 EXIT_FAILURE の値)固定であることと、
#@since 1.8.0
引数を省略した呼び出し時に 
#@end
[[m:$!]] が nil でなければその例外の
メッセージを標準エラー出力 [[m:$stderr]] に出力することです。

#@since 1.8.0
引数 message を指定すると SystemExit クラスの
[[m:Exception#message]] に message を設定し
て標準エラー出力に出力します。
#@end

@param message エラーメッセージ文字列です。

  puts 'start'
  begin
    puts 'start1...'
    abort "error1"
  rescue SystemExit => err
    puts "end1 with #{err.inspect}"
  end
  
  begin
    puts 'start2...'
    $! = RuntimeError.new
    abort
  ensure
    puts 'end2...'
  end
  puts 'end' #実行されない
  
  #=> start
  #   start1...
  #   end1 with #<SystemExit: error1>
  #   start2...
  #   end2...
  #終了ステータス:1
  #(標準エラー出力)
  #=> error1
  #   ..:12: RuntimeError (RuntimeError)

@see [[m:Kernel.#exit]],[[m:Kernel.#exit!]]

--- `(command) -> String

command を外部コマンドとして実行し、その標準出力を文字列として
返します。このメソッドは `command` の形式で呼ばれます。

引数 command に対しダブルクォートで囲まれた文字列と同様の解釈と式展開を行った後、
コマンドとして実行します。
コマンドは評価されるたびに実行されます。コマンドの終了ステータスを得るには、[[m:$?]] を参照します。

コマンドの出力を得る必要がなく、単にコマンドを実行したいだけなら
[[m:Kernel.#system]] を使います。特に端末を制御するコマンドでは
`command` は失敗するかもしれません。

[[ref:d:spec/literal#command]] も参照。

@param command コマンドとして実行する引数です。そのまま評価されるのではなく、
       ダブルクォート文字列と同様のバックスラッシュ記法の解釈と式展開が行われます。
@return コマンドの出力を文字列で返します。
#@since 1.9.0
@raise Errno::EXXX コマンドを実行できないときや失敗した場合に発生します。
#@end

  puts `ruby -v` #=> ruby 1.8.6 (2007-03-13 patchlevel 0) [i386-mswin32]
  puts $?.inspect #=> #<Process::Status: pid=3580,exited(0)>

#@since 1.9.0
@see [[m:Kernel.#system]],[[m:Kernel.#exec]],[[m:Kernel.#spawn]]
#@else
@see [[m:Kernel.#system]],[[m:Kernel.#exec]]
#@end

--- system(command) -> bool

引数を外部コマンドとして実行して、成功した時に真を返します。

子プロセスが終了ステータス 0 で終了すると成功とみなし true を返します。
#@since 1.9.0
それ以外の終了ステータスの場合は false を返します。
コマンドを実行できなかった場合は nil を返します。
#@else
それ以外の終了ステータスの場合
(コマンドを実行できなかった場合も含む)は false を返します。
#@end

終了ステータスは変数 [[m:$?]] で参照できます。

#@since 1.9.0
コマンドを実行することができなかった場合、多くのシェルはステータス
127 を返します。(したがって [[m:$?]] の数値は、0x7f00)、シェルを介
さない場合は Ruby の子プロセスがステータス 127 で終了します。
コマンドが実行できなかったのか、コマンドが失敗したのかは、普通
[[m:$?]] を参照することで判別可能です。
#@end

==== 引数の解釈

この形式では command が shell のメタ文字
//emlist{
  * ? {} [] <> () ~ & | \ $ ; ' ` " \n
//}
を含む場合、shell 経由で実行されます。
そうでなければインタプリタから直接実行されます。

@param command command コマンドを文字列で指定します。

#@since 1.9.0
@see [[m:Kernel.#`]],[[m:Kernel.#spawn]],[[m:Kernel.#exec]],[[man:system(3)]]
#@else
@see [[m:Kernel.#`]],[[m:Kernel.#exec]],[[man:system(3)]]
#@end

--- system(program, *args) -> bool

引数を外部コマンドとして実行して、成功した時に真を返します。

子プロセスが終了ステータス 0 で終了すると成功とみなし true を返します。
#@since 1.9.0
それ以外の終了ステータスの場合
(コマンドを実行できなかった場合も含む)は false を返します。
#@else
それ以外の終了ステータスの場合は false を返します。
コマンドを実行できなかった場合は nil を返します。
#@end

終了ステータスは変数 [[m:$?]] で参照できます。

#@since 1.9.0
コマンドを実行することができなかった場合、多くのシェルはステータス
127 を返します。(したがって $? の数値は、0x7f00)、シェルを介
さない場合は Ruby の子プロセスがステータス 127 で終了します。
コマンドが実行できなかったのか、コマンドが失敗したのかは、普通
$? を参照することで判別可能です。
#@end

==== 引数の解釈

この形式で呼び出した場合、空白や shell のメタキャラクタも
そのまま program の引数に渡されます。
先頭の引数が2要素の配列であった場合、第1要素の文字列が実際に
起動するプログラムのパスであり、第2要素が「みせかけ」のプロ
グラム名になります。
#@since 1.8.0
また、第1要素はフルパスで指定しなくても環境変数 PATH から探します。
#@end

@param program 文字列か2要素の配列です。
@param args program に渡す引数を 0 個以上指定する
@raise ArgumentError 第一引数が配列かつ要素数が 2 でない場合に発生します。
#@#例...
#@since 1.9.0
@see [[m:Kernel.#`]],[[m:Kernel.#spawn]],[[m:Kernel.#exec]],[[man:system(3)]]
#@else
@see [[m:Kernel.#`]],[[m:Kernel.#exec]],[[man:system(3)]]
#@end

#@since 1.9.0
--- spawn(command) -> Integer

引数を外部コマンドとして実行しますが、生成した
子プロセスの終了を待ち合わせません。生成した子プロセスのプロセスIDを返します。

==== 引数の解釈

この形式では command が shell のメタ文字
//emlist{
  * ? {} [] <> () ~ & | \ $ ; ' ` " \n
//}
を含む場合、shell 経由で実行されます。
そうでなければインタプリタから直接実行されます。

@param command コマンドを文字列で指定します。
@raise Errno::EXXX 起動に失敗し、ruby インタプリタに制御が戻った場合に発生します。
@raise Errno::EXXX コマンドが実行できなかった場合に発生します。

#@#例...

@see [[m:Kernel.#system]],[[m:Kernel.#exec]]

--- spawn(program, *arg) -> Integer

引数を外部コマンドとして実行しますが、生成した
子プロセスの終了を待ち合わせません。生成した子プロセスのプロセスIDを返します。

==== 引数の解釈

この形式で呼び出した場合、空白や shell のメタキャラクタも
そのまま program の引数に渡されます。
先頭の引数が2要素の配列であった場合、第1要素の文字列が実際に
起動するプログラムのパスであり、第2要素が「みせかけ」のプロ
グラム名になります。
また、第1要素はフルパスで指定しなくても環境変数 PATH から探します。

@param program 文字列か2要素の配列を指定します。
@param args 渡される引数です。0 個以上の文字列を指定します。
@raise ArgumentError 第一引数が配列かつ要素数が 2 でない場合に発生します。
@raise Errno::EXXX コマンドが実行できなかった場合に発生します。


#@#例...

@see [[m:Kernel.#system]],[[m:Kernel.#exec]]
#@end

--- exec(command) -> ()

引数で指定されたコマンドを実行します。

プロセスの実行コードはそのコマンド(あるいは shell)になるので、
起動に成功した場合、このメソッドからは戻りません。

==== 引数の解釈

この形式では command が shell のメタ文字
//emlist{
  * ? {} [] <> () ~ & | \ $ ; ' ` " \n
//}
を含む場合、shell 経由で実行されます。
そうでなければインタプリタから直接実行されます。

@param command コマンドを文字列で指定します。
@raise Errno::EXXX 起動に失敗し、ruby インタプリタに制御が戻った場合に発生します。

  # a.rb
  puts '実行前'
  exec 'echo "実行中"'
  puts '実行後'

上記のスクリプトを実行すると以下のようになります。

  $ ruby a.rb
  実行前
  実行中
  # '実行後' は表示されない

--- exec(program, *args) -> ()

引数で指定されたコマンドを実行します。

プロセスの実行コードはそのコマンド(あるいは shell)になるので、
起動に成功した場合、このメソッドからは戻りません。

この形式では、常に shell を経由せずに実行されます。

==== 引数の解釈

この形式で呼び出した場合、空白や shell のメタキャラクタも
そのまま program の引数に渡されます。
先頭の引数が2要素の配列であった場合、第1要素の文字列が実際に
起動するプログラムのパスであり、第2要素が「みせかけ」のプロ
グラム名になります。
#@since 1.8.0
また、第1要素はフルパスで指定しなくても環境変数 PATH から探します。
#@end

@param program 文字列か2要素の配列を指定します。
@param args 渡される引数です。0 個以上の文字列を指定します。
@raise ArgumentError 第一引数が配列かつ要素数が 2 でない場合に発生します。
@raise Errno::EXXX 起動に失敗し、ruby インタプリタに制御が戻った場合に発生します。

#@#例...

#@# コマンドの引数がない場合も含めて shell を経由せずにプログラムを実行させたい場合、
#@# 以下のように exec を呼び出します。
#@# 
#@#   exec [program, program], *args

例

  # a.rb
  exec ['sleep', 'mysleep'], '600'

上記スクリプトを実行すると以下のようになります。

  $ ruby a.rb
  ## sleep してるので制御が戻ってこない。別の仮想端末に切替えて以下を実行
  $ ps aux|grep sleep
  xxxx    32754  0.0  0.0   2580   468 pts/3    S+   22:01   0:00 mysleep 600
  xxxx    32761  0.0  0.0   2824   792 pts/6    S+   22:01   0:00 grep sleep

#@since 1.9.0
@see [[m:Kernel.#system]],[[m:Kernel.#`]],[[m:Kernel.#spawn]],[[m:Kernel.#fork]],[[m:IO.popen]],[[m:IO.pipe]],[[m:Kernel.#open]],[[man:exec(3)]]
#@else
@see [[m:Kernel.#system]],[[m:Kernel.#`]],[[m:Kernel.#fork]],[[m:IO.popen]],[[m:IO.pipe]],[[m:Kernel.#open]],[[man:exec(3)]]
#@end

--- fork -> Integer | nil
--- fork { ... } -> Integer | nil

[[man:fork(2)]] システムコールを使ってプロセスの複製を作
ります。親プロセスでは子プロセスのプロセスIDを、子プロセスでは
nil を返します。ブロックを指定して呼び出した場合には、生成し
た子プロセスでブロックを評価します。

#@since 1.8.2
fork 前に STDOUT と STDERR を [[m:IO#flush]] します。
#@end

@raise NotImplementedError 実行環境がこのメソッドに対応していないとき発生します。
#@#例...
@see [[m:IO.popen]],[[m:IO.pipe]], [[man:fork(2)]]

--- syscall(num, *arg ) -> Integer

numで指定された番号のシステムコールを実行します。
第2引数以降をシステムコールの引数として渡します。

どの数値がどのシステムコールに対応するかは、
[[man:syscall(2)]] や
/usr/include/sys/syscall.h を参照してください。

システムコールの慣習に従い、[[man:syscall(2)]]
が -1 を返す場合には例外 [[c:Errno::EXXX]] が発生します。
それ以外では、返した値をそのまま数値で返します。

ライブラリ [[lib:dl]] を使えばより高レベルな操作ができます。

@param num システムコール番号です。
@param arg 文字列か、整数です。最大 9 個まで渡すことができます。
@raise Errno::EXXX syscall(2) が -1 を返した場合に発生します。
@raise NotImplementedError 実行環境がこのメソッドに対応していないとき発生します。
#@#例...
@see [[lib:dl]]

--- open(file, mode = "r", perm = 0666) -> IO
--- open(file, mode = "r", perm = 0666) {|io| ... } -> object

file をオープンして、[[c:IO]]（[[c:File]]を含む）クラスのインスタンスを返します。

open がブロックとともに呼び出された時、open はファイル
をオープンしてブロックを実行し、ブロックの実行が終了するとファイル
をクローズします。この場合はブロックを評価した結果を返します。

ファイル名 file が `|' で始まる時には続く文字列をコマンドとして起動し、
コマンドの標準入出力に対してパイプラインを生成します

ファイル名が "|-" である時、open は Ruby の子プロセス
を生成し、その子プロセスとの間のパイプ([[c:IO]]オブジェクト)を返し
ます。(このときの動作は、[[m:IO.popen]] と同じです。
[[m:File.open]] にはパイプラインを生成する機能はありません)。

Perlと異なりコマンドは常に `|' で始まります。

@param file ファイルを文字列で指定します。整数を指定した場合はファイルディスクリプタとして扱います。
@param mode モードを文字列か定数の論理和で指定します。後述。
@param perm [[man:open(2)]] の第 3 引数のように、ファイルを生成する場合の
  ファイルのパーミッションを整数で指定します。
#@if (version < "1.8.0")
  この引数は、第 2 引数が数値形式でなければ無視されます
#@end
@raise Errno::EXXX ファイルのオープンに失敗した場合に発生します。 

#@#例...

@see [[m:File.open]],[[m:IO.popen]],[[m:IO.open]]

==== 第二引数のオープンモード
以下の文字列か整数([[c:File::Constants]] モジュール
の定数の論理和)を組み合わせて指定します。

: "r", RDONLY
    ファイルを読み込みモードでオープンします。（デフォルトのモード）

: "w", WRONLY|CREAT|TRUNC
    ファイルを書き込みモードでオープンします。
    オープン時にファイルがすでに存在していれば
    その内容を空にします。

: "a", WRONLY|CREAT|APPEND
    ファイルを書き込みモードでオープンします。
    出力は 常に ファイルの末尾に追加されます。
    例えば、ファイルオープン中にファイルのサイズが小さ
    くなってもその末尾に出力されます。
#@#    このことはログ出力な
#@#    どでプログラムを実行したままそのログを小さくしたい場合
#@#    に利用されます。

"+" があれば、ファイルは読み書き両用モード (RDWR)
でオープンされます。

: "r+"
    ファイルの読み書き位置は先頭にセットされます。

: "w+"
    "r+" と同じですが、オープン時にファイルがすでに
    存在していればその内容を空にします。

: "a+"
    "r+" と同じですが、オープン時にファイルがすでに
    存在していれば読み書き位置がファイルの末尾に
    セットされます。

これらのいずれに対しても "b" フラグを ("r+b"のように) つけることがで
きます (整数なら File::BINARY )。この場合、バイナリモードでオープン
します (ただし、DOS/Windowsのようにシステムがテキスト／バイナリでファイルを区別する場
合に限ります)

--- select(reads, writes = [], excepts = [], timeout = nil) -> [[IO]] | nil

[[m:IO.select]] と同じです。

@param reads [[m:IO.select]] 参照
@param writes [[m:IO.select]] 参照
@param excepts [[m:IO.select]] 参照
@param timeout [[m:IO.select]] 参照
@see [[m:IO.select]]

--- test(cmd, file) -> bool | Time | Integer | nil

単体のファイルでファイルテストを行います。

@param cmd 以下に示す数値リテラルか文字列です(文字列の場合はその先頭の文字だけをコマンドとみなします)。
@param file テストするファイルオブジェクトです。
@return 下表に特に明記していないものは、真偽値を返します。

以下は cmd として指定できる数値リテラルとその意味です。

: ?r
    ファイルを実効 uid で読むことができる
: ?w
    ファイルに実効 uid で書くことができる
: ?x
    ファイルを実効 uid で実行することができる
: ?o
    ファイルの所有者が実効 uid である
: ?G
    ファイルのグループ所有者が実効 gid である
: ?R
    ファイルを実 uid で読むことができる
: ?W
    ファイルに実 uid で書くことができる
: ?X
    ファイルを実 uid で実行することができる
: ?O
    ファイルの所有者が実 uid である
: ?e
    ファイルが存在する
: ?z
    ファイルサイズが 0 である
: ?s
    ファイルサイズが 0 でない (ファイルサイズを返す、0 ならば nil) -> Integer|nil
: ?f
    ファイルはプレーンファイルである
: ?d
    ファイルはディレクトリである
: ?l
    ファイルはシンボリックリンクである
: ?p
    ファイルは名前つきパイプ(FIFO)である
: ?S
    ファイルはソケットである
: ?b
    ファイルはブロック特殊ファイルである
: ?c
    ファイルはキャラクター特殊ファイルである
: ?u
    ファイルに setuid ビットがセットされている
: ?g
    ファイルに setgid ビットがセットされている
: ?k
    ファイルに sticky ビットがセットされている
: ?M
    ファイルの最終更新時刻を返す -> Time
: ?A
    ファイルの最終アクセス時刻を返す -> Time
: ?C
    ファイルの inode 変更時刻を返す -> Time

--- test(cmd, file1, file2) -> bool

２ファイル間のファイルテストを行います。

@param cmd 以下に示す数値リテラルか文字列です(文字列の場合はその先頭の文字だけをコマンドとみなします)。
@param file1 テストするファイルオブジェクトです。
@param file2 テストするファイルオブジェクトです。
@return 真偽値を返します。

以下は cmd として指定できる数値リテラルとその意味です。

: ?=
    ファイル1とファイル2の最終更新時刻が等しい
: ?>
    ファイル1の方がファイル2より最終更新時刻が新しい
: ?<
    ファイル1の方がファイル2より最終更新時刻が古い
: ?-
    ファイル1とファイル2が同一のファイルである

--- load(file, priv = false) -> true

Ruby プログラム file をロードして実行します。再ロード可能です。

file が絶対パスのときは file からロードします。
file が相対パスのときは組み込み変数 [[m:$:]]
に示されるパスを順番に探し、最初に見付かったファイルを
ロードします。このとき、[[m:$:]] の要素文字列の先頭文字が
`~' (チルダ) だと、環境変数 HOME の値に展開されます。

ロードに成功した場合は true を返します。

@param file ファイル名の文字列です。
@param priv 真のとき、ロード・実行は内部的に生成される
            無名モジュールをトップレベルとして行われ、
            グローバルな名前空間を汚染しません。
@raise LoadError ロードに失敗した場合に発生します。
@see [[m:Kernel.#require]]

==== require と load の違い

[[m:Kernel.#require]] は同じファイルは一度だけしかロードしませんが、
[[m:Kernel.#load]] は無条件にロードします。
また、require は拡張子.rb や .so を自動的に補完しますが、
load は行いません。
require はライブラリのロード、load は
設定ファイルの読み込みなどに使うのが典型的な用途です。

  # 使用例
  load "#{ENV['HOME']}/.myapprc"
  load "/etc/myapprc"

なお、特定のディレクトリからファイルをロードしたい場合、
load 'filename' とするのは不適切です。必ず絶対パスを
使ってください。

--- require(feature) -> bool

Ruby ライブラリ feature をロードします。拡張子補完を行い、
同じファイルの複数回ロードはしません。

feature が絶対パスのときは feature からロードします。
feature が相対パスのときは組み込み変数 [[m:$:]]
に示されるパスを順番に探し、最初に見付かったファイルを
ロードします。このとき、$: の要素文字列の先頭文字が
`~' (チルダ) だと、環境変数 HOME の値に展開されます。

Ruby ライブラリとは Ruby スクリプト (*.rb) か拡張ライブラリ
(*.so,*.o,*.dll など) であり、feature の拡張子が省略された場合はその
両方から探します( *.rb が優先されます)。
省略されなかった場合は指定された種別のみを探します。
また、feature の拡張子にはアーキテクチャで実際に使われる拡張子に
関らず拡張ライブラリの拡張子として常に .so を用いることができます（内部で適切に変換されます）。

ライブラリのロードに成功した時には true を返し、ロードした feature の名前を(拡
張子も含めて) 変数 [[m:$"]] に追加します。ただし、feature の名前が既に $"
に含まれていた場合はロードせずに false を返します。

@param feature ファイル名の文字列です。
@raise LoadError ロードに失敗した場合に発生します。
#@since 1.9.0
@see [[m:Kernel.#load]],[[m:Kernel.#autoload]],[[m:Kernel.#require_relative]]
#@else
@see [[m:Kernel.#load]],[[m:Kernel.#autoload]]
#@end

--- require_relative(relative_feature) -> bool
現在のファイルからの相対パスで require します。

  require File.expand_path(File.join(File.dirname(__FILE__), relative_feature))
とほぼ同じです。

@param feature ファイル名の文字列です。
@raise LoadError ロードに失敗した場合に発生します。
@see [[m:Kernel.#require]]

==== require と load のスコープ

ローカル変数はファイル間では共有されません。ですので、
ロードしたライブラリのローカル変数を
ロード元のスクリプトから直接取得することはできません。
このスコープの扱い方は[[m:Kernel.#load]]でも同様です。

  ---------- some.rb -----------
  $a = 1
  @a = 1
  A = 1
  a = 1
  ---------- end some.rb -------
  
  require 'some'
  p $a #=> 1
  p @a #=> 1
  p A #=> 1
  p a # undefined local variable or method `a' for #<Object:0x294f9ec @a=1> (NameError)

--- autoload(const_name, feature) -> nil

定数 const_name を最初に参照した時に feature を
[[m:Kernel.#require]] するように設定します。

const_name には、 "::" 演算子を含めることはできません
#@since 1.8.0
（ネストした定数を指定する方法は後述）。
#@else
。つまり、トップレベルの定数しか指定できません。
#@end

@param const_name 定数をString または Symbol で指定します。
@param feature require と同様な方法で autoload する対象を指定します。
@raise LoadError featureのロードに失敗すると発生します。

    ------- /tmp/foo.rb ---------
    class Bar
    end
    ----- end of /tmp/foo.rb ----

    autoload :Bar, '/tmp/foo'
    p Bar #=> Bar

#@since 1.8.0
==== ネストした定義内の定数

const_name には、 "::" 演算子を含めることはできないので、 Kernel.#autoload 
ではトップレベルの定数しか指定できません。

[[m:Module#autoload]] と組み合わせることで、任意のクラス／モジュールの定数を autoload できます。
やはりconst_name に "::" 演算子を含めることはで
きませんが、以下のように定義する事ができます。

    ------- /tmp/foo.rb ---------
    class Foo
      class Bar
      end
    end
    ----- end of /tmp/foo.rb ----

    class Foo
      autoload :Bar, '/tmp/foo'
    end
    p Foo::Bar #=> Foo::Bar

あるいは、以下のようにもできます。

    class Foo
    end
    Foo.autoload :Bar, '/tmp/foo'
    p Foo::Bar #=> Foo::Bar

以下のように、autoload したライブラリがネストした定数を定義しない場
合、一見、正常に動作しているように見えるので注意が必要です(警告メッ
セージが出ています)。

      ------- /tmp/bar.rb ---------
      class Bar
      end
      ----- end of /tmp/bar.rb ----

      class Foo
        autoload :Bar, '/tmp/bar.rb'
      end
      p Foo::Bar
      p Foo.autoload?(:Bar)
      #=> -:4: warning: toplevel constant Bar referenced by Foo::Bar
      #   Bar
      #   nil

これは以下のようにネストせずに定義したのと同じことです。

      class Foo
      end
      class Bar
      end
      p Foo::Bar
      #=> -:5: warning: toplevel constant Bar referenced by Foo::Bar
      #   Bar
#@end

@see [[m:Kernel.#autoload?]],[[m:Module#autoload]],[[m:Kernel.#require]]

#@since 1.8.0
--- autoload?(const_name) -> String | nil

const_name が [[m:Kernel.#autoload]] 設定されているか調べます。

autoload 設定されていて、autoload 定数がまだ定義されてない(ロードされていない)
ときにそのパス名を返します。

autoload 設定されていないか、ロード済みなら nil を返します。

@param const_name 定数をString または Symbol で指定します。

    ------- /tmp/foo.rb ---------
    class Foo
      class Bar
      end
    end
    ----- end of /tmp/foo.rb ----

    class Foo
    end
    p Foo.autoload?(:Bar)         #=> nil
    Foo.autoload :Bar, '/tmp/foo'
    p Foo.autoload?(:Bar)         #=> "/tmp/foo"
    p Foo::Bar                    #=> Foo::Bar
    p Foo.autoload?(:Bar)         #=> nil

@see [[m:Kernel.#autoload]]
#@end

--- set_trace_func(proc)                                         -> object
--- set_trace_func{|event, file, line, id, binding, klass| ... } -> Proc

Ruby インタプリタのイベントをトレースする [[c:Proc]] オブジェクトとして
指定された proc を登録します。 proc に nil を指定した場合でトレースをオフにします。
ブロックを指定された場合はそのブロックをトレースする Proc オブジェクトとして登録します。

引数 proc かブロックを Proc オブジェクトに変換したものを返します。

Ruby インタプリタがプログラムを実行する過程で、メソッドの呼び出しや
式の評価などのイベントが発生する度に、以下で説明する6個の引数とともに
登録された [[c:Proc]] オブジェクトを実行します。

標準添付の [[lib:debug]]、[[lib:tracer]]、
[[lib:profile]] はこの組み込み関数を利用して実現されています。

==== ブロック引数の意味

: event
 実行のタイプを表す、以下のいずれかの文字列。
//emlist{
  "line":      式の評価。
  "call":      メソッドの呼び出し。
  "return":    メソッド呼び出しからのリターン。
  "c-call":    Cで記述されたメソッドの呼び出し。
  "c-return":  Cで記述されたメソッド呼び出しからのリターン。
  "class":     クラス定義、特異クラス定義、モジュール定義への突入。
  "end":       クラス定義、特異クラス定義、モジュール定義の終了。
  "raise":     例外の発生。
//}
: file
 実行中のプログラムのソースファイル名 (文字列)。

: line
 実行中のプログラムのソースファイル上の行番号 (整数)。

: id
 event に応じ、以下のものが渡されます。
 第六ブロック引数の klass と対応しています。
//emlist{
    line
        最後に呼び出されたメソッドを表す Symbol オブジェクト。
        トップレベルでは nil。
    call/return/c-call/c-return
        呼び出された/リターンするメソッドを表す Symbol オブジェクト。
    class/end
        nil。
    raise
        最後に呼び出されたメソッドを表す Symbol オブジェクト。
        トップレベルでは nil。
//}
: binding
 実行中のプログラムのコンテキストを表す [[c:Binding]] オブジェクト。

: klass
 event に応じ、以下のものが渡されます。
 第四ブロック引数の id と対応しています。
//emlist{
    line
        最後に呼び出されたメソッドが属するクラスを表す
        Class オブジェクト。トップレベルでは false。
    call/return/c-call/c-return
        呼び出された/リターンするメソッドが属するクラス
        を表す Class オブジェクト。
    class/end
        false。
    raise
        最後に呼び出されたメソッドが属するクラスを表す
        Class オブジェクト。トップレベルでは false。
//}
@param proc トレース用 [[c:Proc]] オブジェクトを指定します。nil を指定した場合、トレースをオフにします。

@return 引数 proc が指定された場合は proc を、ブロックの場合は Proc オブジェクトに変換したものを返します。

例:

  set_trace_func lambda {|*arg|
    p arg
  }
  class Foo
  end
  43.to_s
  
  #----結果----
  #["line", "..", 4, nil, #<Binding:0x2b69584>, false]
  #  ["c-call", "..", 4, :inherited, #<Binding:0x2b693b8>, Class]
  #    ["c-return", "..", 4, :inherited, #<Binding:0x2b6937c>, Class]
  #      ["class", "..", 4, nil, #<Binding:0x2b69098>, false]
  #        ["end", "..", 4, nil, nil, false]
  #        ["line", "..", 6, nil, #<Binding:0x2b68d78>, false]
  #          ["c-call", "..", 6, :to_s, #<Binding:0x2b68c88>, Fixnum]
  #            ["c-return", "..", 6, :to_s, #<Binding:0x2b68aa8>, Fixnum]

@see [[m:Kernel.#caller]]

--- caller(level_num = 1) -> [String] | nil

level_num 段上の呼び出し元の情報を [[m:$@]]
の形式のバックトレース(文字列の配列)として返します。

トップレベルでは空の配列を返します。caller の戻り値を [[m:$@]] に代入することで
例外の発生位置を設定できます。

指定した level_num 段上が存在しない場合は nil を返します。

@param level_num long の範囲を超えない正の整数でスタックレベルを指定します。
@see [[m:Kernel.#set_trace_func]],[[m:Kernel.#raise]]

    def foo
      p caller(0)
      p caller(1)
      p caller(2)
      p caller(3)
    end

    def bar
      foo
    end

    bar

    #=> ["-:2:in `foo'", "-:9:in `bar'", "-:12"]
    #   ["-:9:in `bar'", "-:12"]
    #   ["-:12"]
    #   []

以下の関数は、caller の要素から [ファイル名, 行番号, メソッド名]
を取り出して返します。

    def parse_caller(at)
      if /^(.+?):(\d+)(?::in `(.*)')?/ =~ at
        file = $1
        line = $2.to_i
        method = $3
        [file, line, method]
      end
    end

    def foo
      p parse_caller(caller.first)
    end

    def bar
      foo
      p parse_caller(caller.first)
    end

    bar
    p parse_caller(caller.first)

    #=> ["-", 15, "bar"]
    #   ["-", 19, nil]
    #   nil

以下は、[[m:$DEBUG]] が真の場合に役に立つ debug 関数
のサンプルです。

    $DEBUG = true
    
    def debug(*args)
      p [caller.first, *args] if $DEBUG
    end

    debug "debug information"

    #=> ["-:5", "debug information"]

--- gets(rs = $/) -> String | nil

[[c:ARGF]]から一行読み込んで、それを返します。
行の区切りは引数 rs で指定した文字列になります。

rs に nil を指定すると行区切りなしとみなしてファイルの内容を
すべて読み込みます。ARGVに複数のファイル名が存在する場合は1度に1ファイルずつ読み込みます。
空文字列 "" を指定すると連続する改行を行の区切りとみなします
(パラグラフモード)。

読み込んだ文字列は組み込み変数 [[m:$_]] にもセットされます。

@param rs 行の区切りとなる文字列です。
@return ファイルの終り(EOF)に到達した時、 nil を返します。
@raise Errno::EXXX 読み込みに失敗した場合に発生します。

  ---main.rb---
  ARGV << 'b.txt' << 'c.txt'
  p gets #=> "hello\n"
  p gets(nil) #=> "it\ncommon\n"
  p gets("") #=> "ARGF\n\n"
  p gets('、') #=> "スクリプトに指定した引数 (Kernel::ARGV を参照) をファイル名と\nみなして、"
  p gets #=> "それらのファイルを連結した 1 つの仮想ファイルを表すオブジェクトです。 \n"
  p gets #=> nil
  p readline # end of file reached (EOFError)
  --- b.txt ---
  hello
  it
  common
  --- c.txt ---
  ARGF
  
  スクリプトに指定した引数 (Kernel::ARGV を参照) をファイル名と
  みなして、それらのファイルを連結した 1 つの仮想ファイルを表すオブジェクトです。 

@see [[m:$/]],[[c:ARGF]],[[m:Kernel.#readlines]],[[m:Kernel.#readline]]

--- readline(rs = $/) -> String

[[c:ARGF]]から一行読み込んで、それを返します。
行の区切りは引数 rs で指定した文字列になります。

rs に nil を指定すると行区切りなしとみなしてファイルの内容を
すべて読み込みます。ARGVに複数のファイル名が存在する場合は1度に1ファイルずつ読み込みます。
空文字列 "" を指定すると連続する改行を行の区切りとみなします
(パラグラフモード)。

読み込んだ文字列は組み込み変数 [[m:$_]] にもセットされます。

@param rs 行の区切りとなる文字列です。
@raise Errno::EXXX 読み込みに失敗した場合に発生します。
@raise EOFError readline でファイル末端(EOF)を検出すると発生します。

  ---main.rb---
  ARGV << 'b.txt' << 'c.txt'
  p readline #=> "hello\n"
  p readline(nil) #=> "it\ncommon\n"
  p readline("") #=> "ARGF\n\n"
  p readline('、') #=> "スクリプトに指定した引数 (Kernel::ARGV を参照) をファイル名と\nみなして、"
  p readline #=> "それらのファイルを連結した 1 つの仮想ファイルを表すオブジェクトです。 \n"
  p readline # end of file reached (EOFError)
  --- b.txt ---
  hello
  it
  common
  --- c.txt ---
  ARGF
  
  スクリプトに指定した引数 (Kernel::ARGV を参照) をファイル名と
  みなして、それらのファイルを連結した 1 つの仮想ファイルを表すオブジェクトです。 

@see [[m:$/]],[[c:ARGF]],[[m:Kernel.#readlines]],[[m:Kernel.#gets]]

--- readlines(rs = $/) -> [String] | nil

[[c:ARGF]]を [[m:Kernel.#gets]](rs) でEOFまで読み込んで、その各行を要素としてもつ配列を返します。
行の区切りは引数 rs で指定した文字列になります。

rs に nil を指定すると行区切りなしとみなします。
空文字列 "" を指定すると連続する改行を行の区切りとみなします
(パラグラフモード)。

@param rs 行の区切りとなる文字列です。
@raise Errno::EXXX 読み込みに失敗した場合に発生します。

  ---main.rb---
  ARGV << 'b.txt' << 'b.txt'
  p readlines #=> ["hello\n", "it\n", "\n", "common\n", "hello\n", "it\n", "\n", "common\n"]
  
  ARGV << 'b.txt' << 'b.txt'
  p readlines(nil) #=> ["hello\nit\n\ncommon\n", "hello\nit\n\ncommon\n"]
  
  ARGV << 'b.txt' << 'b.txt'
  p readlines("") #=> ["hello\nit\n\n", "common\n", "hello\nit\n\n", "common\n"]
  
  ARGV << 'b.txt' << 'b.txt'
  p readlines('it') #=> ["hello\nit", "\n\ncommon\n", "hello\nit", "\n\ncommon\n"]
  p readlines #=> nil
  --- b.txt ---
  hello
  it
  
  common

@see [[m:$/]],[[c:ARGF]],[[m:Kernel.#gets]]

#@if ("1.8.0" <= version and version < "1.9.0")
--- getc -> Fixnum | nil

このメソッドは廃止予定です。代わりに STDIN.getc を使ってください。

@see [[m:IO#getc]]
#@end

--- putc(ch) -> object

文字 ch を 標準出力 [[m:$stdout]] に出力します。

ch が数値なら 0 〜 255 の範囲の対応する文字を出力します。
ch が文字列なら、その先頭 1byte を出力します。
どちらでもない場合は、ch.to_int で整数に変換を試みます。

@param ch 出力する文字です。数または文字列で指定します。
@return ch を返します
@raise RangeError [[c:Bignum]] を引数にした場合に発生します。
@raise IOError 標準出力が書き込み用にオープンされていなければ発生します。
@raise Errno::EXXX 出力に失敗した場合に発生します。
@raise TypeError [[c:Integer]] に変換できないオブジェクトを引数に
                 指定した場合に発生します。

#@#1.9でもいまのところ同じ結果
    putc("ch")
    putc(?c)
    putc(99)
    putc(355)
    #=> cccc
    
    putc(99.00) #=> c
    putc(33333333333333333333333333333333333) # bignum too big to convert into `long' (RangeError)

@see [[m:IO#putc]]

#@since 1.9.0
--- p(*arg) -> object | Array
#@else
--- p(*arg) -> nil
#@end
#@todo

引数を人間に読みやすい形に整形して改行と順番に標準出力 [[m:$stdout]] に出力します。主にデバッグに使用します。

引数の inspect メソッドの返り値と改行を順番に出力します。つまり以下のコードと同じです。

  print arg[0].inspect, "\n", arg[1].inspect, "\n", ...

整形に用いられる[[m:Object#inspect]]は普通に文字列に変換すると
区別がつかなくなるようなクラス間の差異も表現できるように工夫されています。

p に引数を与えずに呼び出した場合は特に何もしません。

@param arg 出力するオブジェクトを任意個指定します。
#@#inspectが定義されているオブジェクトである必要があります（実質任意のオブジェクト）。
@raise IOError 標準出力が書き込み用にオープンされていなければ発生します。
@raise Errno::EXXX 出力に失敗した場合に発生します。
#@since 1.9.0
@return 指定された引数 arg を返します。複数の引数が指定された場合はそれらを要素とする配列を返します。
#@else
@return nil を返します。
#@end

  puts "" #=> （空行）
  p "" #=> ""
  
  puts 50,"50"
  #=> 50
  #=> 50
  p 50,"50"
  #=> 50
  #=> "50"

@see [[m:Object#inspect]],[[m:Kernel.#puts]],[[m:Kernel.#print]]

--- print(*arg) -> nil

引数を順に標準出力 [[m:$stdout]] に出力します。引数が与えられない時には変数
[[m:$_]] の値を出力します。

文字列以外のオブジェクトが引数として与えられた場合には、
to_s メソッドにより文字列に変換してから出力します。
#@if (version < "1.9.0")
ただし、nil に対しては文字列 "nil" を出力します
#@end

変数 [[m:$,]] (出力フィールドセパレータ)に nil で
ない値がセットされている時には、各引数の間にその文字列を出力します。
変数 [[m:$\]] (出力レコードセパレータ)に nil でな
い値がセットされている時には、最後にそれを出力します。

@param arg 出力するオブジェクトを任意個指定します。
#@#to_s が定義されているオブジェクトである必要があります（実質任意のオブジェクト）。
@raise IOError 標準出力が書き込み用にオープンされていなければ発生します。
@raise Errno::EXXX 出力に失敗した場合に発生します。

#@since 1.9.0
  print "Hello, world!"
  print "Regexp is",/ant/
  print nil
  print "\n"
  #=> Hello, world!Regexp is(?-mix:ant)

  $_ = "input"
  $, = "<and>"
  $\ = "<end>\n"
  print
  print "AA","BB"
  #=> input<and><end>
  #=> AA<and>BB<and><end>
#@else
  print "Hello, world!"
  print "Regexp is",/ant/
  print nil
  print "\n"
  #=> Hello, world!Regexp is(?-mix:ant)nil

  $_ = "input"
  $, = "<and>"
  $\ = "<end>\n"
  print
  print "AA","BB"
  #=> input<end>
  #=> AA<and>BB<end>
#@end
@see [[m:Kernel.#puts]],[[m:Kernel.#p]]

--- puts(*arg) -> nil

引数と改行を順番に 標準出力 [[m:$stdout]] に出力します。
引数がなければ改行のみを出力します。

引数が配列の場合、その要素と改行を順に出力します。
配列や文字列以外のオブジェクトが引数として与えられた場合には、
当該オブジェクトを最初に to_ary により配列へ、
次に to_s メソッドにより文字列へ変換を試みます。
#@if (version < "1.9.0")
ただし、nil に対しては文字列 "nil" を出力します
#@end
末尾が改行で終っている引数や配列の要素に対しては puts 自身
は改行を出力しません。

@param arg 出力するオブジェクトを任意個指定します。
@raise IOError 標準出力が書き込み用にオープンされていなければ発生します。
@raise Errno::EXXX 出力に失敗した場合に発生します。

#@since 1.9.0
    puts "foo", "bar\n", "baz"
    puts ""    # 改行のみ出力
    puts       # 改行のみ出力
    puts nil   # 改行のみ出力
    puts ["oui", "non"]
    #=> foo
    #   bar
    #   baz
    #
    #
    #
    #   oui
    #   non
#@else
    puts "foo", "bar\n", "baz"
    puts ""    # 改行のみ出力
    puts       # 改行のみ出力
    puts nil
    puts ["oui", "non"]
    #=> foo
    #   bar
    #   baz
    #
    #
    #   nil
    #   oui
    #   non
#@end

@see [[m:Kernel.#print]], [[m:Kernel.#p]], [[m:IO#puts]]

#@since 1.8.0
--- warn(message) -> nil

message を 標準エラー出力 [[m:$stderr]] に出力します。 [[m:$VERBOSE]] 
フラグ が nil のときは何も出力しません。

文字列以外のオブジェクトが引数として与えられた場合には、
to_s メソッドにより文字列に変換してから出力します。

このメソッドは以下と同じです。
  $stderr.print message, "\n" unless $VERBOSE.nil?

@param message 出力するオブジェクトです。
@raise IOError 標準エラー出力が書き込み用にオープンされていなければ発生します。
@raise Errno::EXXX 出力に失敗した場合に発生します。

  warn "caution!" #=> caution!
  $VERBOSE = nil
  warn "caution!" # 何もしない

@see [[m:$stderr]],[[m:$VERBOSE]]
#@end

--- Array(arg) -> Array

引数を配列([[c:Array]])に変換した結果を返します。

arg.to_ary と arg.to_a をこの順に呼び出して、返ってきた配列を変換結果とします。

#@if (version > "1.9.0")
arg に to_ary, to_a のいずれのメソッドも定義されていない場合は
一要素の配列 [arg] を返します。
#@else
arg に to_ary, to_a のいずれのメソッドもない場合は
[[m:Object#to_a]]によって一要素の配列 [arg] を返します。
#@end

@param arg 変換対象のオブジェクトです。
@raise TypeError to_ary, to_a の返り値が配列でなければ発生します

  p Array({:it => 3}) #=> [[:it, 3]]
  p Array(nil) #=> []
  p Array("fefe") #=> ["fefe"]

@see [[m:Object#to_a]],[[m:Object#to_ary]],[[c:Array]]

--- Float(arg) -> Float

引数を浮動小数点数([[c:Float]])に変換した結果を返します。

引数が数値の場合は素直に変換し、文字列の場合
は整数や浮動小数点数と見なせるもののみ変換します。

メソッド Float は文字列に対し [[m:String#to_f]] よりも厳密な変換を行います。

@param arg 変換対象のオブジェクトです。
@raise ArgumentError 整数や浮動小数点数と見なせない文字列を引数に指定した場合に発生します。
@raise TypeError nil またはメソッド to_f を持たないオブジェクトを引数に指定したか、
                 to_f が浮動小数点数を返さなかった場合に発生します。

    p Float(4)            #=> 4.0
    p Float(4_000)        #=> 4000.0
    p Float(9.88)         #=> 9.88
    
    p Flot(Time.gm(1986)) #=> 504921600.0
    p Float(Object.new)   # cannot convert Object into Float (TypeError)
    p Float(nil)          # cannot convert nil into Float (TypeError)
    
    p Float("10")         #=> 10.0
    p Float("10e2")       #=> 1000.0
    p Float("1e-2")       #=> 0.01
    p Float(".1")         #=> 0.1

    p Float("nan")        # invalid value (ArgumentError)
    p Float("INF")        # invalid value (ArgumentError)
    p Float("-Inf")       # invalid value (ArgumentError)
    p Float(("10" * 1000)) #=> Infinity
    p Float("0xa.a")      # invalid value (ArgumentError)
    p Float(" \n10\s \t") #=> 10.0 # 空白類は無視される
    p Float("")           # invalid value (ArgumentError)

@see [[m:String#to_f]],[[c:Float]]

--- Integer(arg) -> Integer

引数を整数([[c:Fixnum]],[[c:Bignum]])に変換した結果を返します。

引数が数値の場合は直接変換し（小数点以下切り落とし）、
文字列の場合は、進数を表す接頭辞を含む整数表現とみなせる文字列のみ
変換します。
#@if (version < "1.8.0")
許される接頭辞は16 進(0x)、2 進(0b)、8 進数(0)です。
#@end

#@since 1.8.0
数値と文字列以外のオブジェクトに対しては arg.to_int, arg.to_i を
この順に使用して変換します。
#@else
数値、文字列以外のオブジェクトに対しては arg.to_i を
使用します。
#@end

@param arg 変換対象のオブジェクトです。
@raise ArgumentError 整数と見なせない文字列を引数に指定した場合に発生します。
#@since 1.8.0
@raise TypeError メソッド to_int, to_i を持たないオブジェクトを引数に指定したか、to_int, to_i
  が整数([[c:Integer]]のサブクラス)を返さなかった場合に発生します。
#@else
@raise TypeError メソッド to_i を持たないオブジェクトを引数に指定したか、
                 to_i が整数を返さなかった場合に発生します。
#@end

#@since 1.8.0
    p Integer(4)          #=> 4
    p Integer(4_000)      #=> 4000
    p Integer(9.88)       #=> 9
    
    p Integer(nil)        #=> 0
    p Integer(Object.new) # cannot convert Object into Integer (TypeError)
    
    p Integer("10")       #=> 10
    p Integer("0d10")     #=> 10
    p Integer("010")      #=> 8
    p Integer("0o10")     #=> 8
    p Integer("0x10")     #=> 16
    p Integer("0b10")     #=> 2
    p Integer(" \n10\t ") #=> 10 # 空白類は無視される
    p Integer("hoge")     # `Integer': invalid value for Integer: "hoge" (ArgumentError)
    p Integer("")         # `Integer': invalid value for Integer: "" (ArgumentError)
#@else
    p Integer(4)          #=> 4
    p Integer(4_000)      #=> 4000
    p Integer(9.88)       #=> 9
    
    p Integer(nil)        #=> 0
    p Integer(Object.new) # cannot convert Object into Integer (TypeError)
    
    p Integer("10")       #=> 10
    p Integer("010")      #=> 8
    p Integer("0x10")     #=> 16
    p Integer("0b10")     #=> 2
    p Integer(" \n10\t ") #=> 10 # 空白類は無視される
    p Integer("hoge")     # `Integer': invalid value for Integer: "hoge" (ArgumentError)
    p Integer("")         # `Integer': invalid value for Integer: "" (ArgumentError)
#@end

@see [[m:String#hex]],[[m:String#oct]],[[m:String#to_i]],[[c:Integer]]

--- String(arg) -> String

引数を文字列([[c:String]])に変換した結果を返します。

arg.to_s を呼び出して文字列に変換します。
arg が文字列の場合、何もせず arg を返します。

@param arg 変換対象のオブジェクトです。
@raise TypeError to_s の返り値が文字列でなければ発生します。

  class Foo
   def to_s
     "hogehoge"
   end
  end
  
  arg = Foo.new
  p String(arg) #=> "hogehoge"

@see [[m:Object#to_s]],[[c:String]]

--- at_exit{ ... } -> Proc

与えられたブロックをインタプリタ終了時に実行します。

at_exitがメソッドである点を除けば、END ブロックによる終了
処理の登録と同等です。登録した処理を取り消すことはできません。
[[d:spec/terminate]]も参照してください。

@return 登録した処理を [[c:Proc]] オブジェクトで返します。

  3.times do |i|
    at_exit{puts "at_exit#{i}"}
  end
  END{puts "END"}
  at_exit{puts "at_exit"}
  puts "main_end"
  
  #=> main_end
  #   at_exit
  #   END
  #   at_exit2
  #   at_exit1
  #   at_exit0

@see [[ref:d:spec/control#END]]

#@since 1.8.0
--- loop { ... } -> object
(中断されない限り)永遠にブロックの評価を繰り返します。

@return breakの引数など、ループ脱出時の値を返します。
#@else
--- loop { ... } -> nil
(中断されない限り)永遠にブロックの評価を繰り返します。

@return nilを返します。
#@end

  def try int
    n = 0
    loop do
      n += 1
      break(n) if rand(n) > int
    end
  end
  
  puts "end on #{try(400)}" #=> end on ???

--- sleep(sec = 0) -> Integer

sec 秒だけプログラムの実行を停止します。

sec が省略されたり 0 を指定した場合、他スレッドからの [[m:Thread#run]]
などで明示的に起こさない限り永久にスリープします。Thread#runを呼ぶとその時点で
sleepの実行が中断されます。

@param sec 停止する秒数を非負の数値で指定します。浮動小数点数も指定できます。 
           0 を指定した場合、永久にスリープします。

@return 実際に停止していた秒数 (整数に丸められた値) です。

  it = Thread.new do
    sleep 999
    puts 'it_end'
  end
  
  re = sleep 2.11
  puts re
  it.run
  re2 = sleep 0.76
  puts re2
  #=> 2
  #   it_end
  #   1

--- block_given? -> bool
--- iterator? -> bool

メソッドにブロックが与えられていれば真を返します。

このメソッドはカレントコンテキストにブロックが与えられているかを調べるので、
メソッド内部以外で使っても単に false を返します。

iterator? は （ブロックが必ずイテレートするとはいえないので）推奨されていないの
で block_given? を使ってください。

  def check
    if block_given?
      puts "Block is given."
    else
      puts "Block isn't given."
    end
  end
  check{} #=> Block is given.
  check #=> Block isn't given.

#@until 1.9.0
--- callcc {|cont| .... } -> object

継続を作成します。 [[c:Continuation]] を参照してください。
#@end

#@since 1.9.0
--- catch {|tag| .... } -> object
#@end
--- catch(tag) {|tag| .... } -> object

[[m:Kernel.#throw]]との組み合わせで大域脱出を行います。 catch はブロックを実行します。

#@since 1.9.0
ブロックの実行中に tag と同一のオブジェクトを引数とする [[m:Kernel.#throw]] が行われた
#@else
ブロックの実行中に tag と同じ名前の [[m:Kernel.#throw]] が行われた
#@end
場合は、その throw の第二引数を戻り値として、ブロックの実行を終了します。

主にネストしたループから一気に脱出するのに使用します。

#@since 1.9.0
引数を省略した場合、タグとなるオブジェクトが内部で生成せれ、ブロック引数 tag に
渡されます。

@param tag タグとなる任意のオブジェクトです。
#@else
@param tag シンボルや文字列などシンボル化できるものです。
#@end
@return ブロックの返り値か、対応するthrowの第二引数を返り値として返します。

#@since 1.9.0
  result = catch do |tag|
    for i in 1..2
      for j in 1..2
        for k in 1..2
          throw tag, k
        end
      end
    end
  end
  
  p result #=> 1
#@else
  result = catch(:tag) do
    for i in 1..2
      for j in 1..2
        for k in 1..2
          throw :tag, k
        end
      end
    end
  end
  
  p result #=> 1
#@end

@see [[m:Kernel.#throw]]

--- throw(tag, value = nil) -> ()

[[m:Kernel.#catch]]との組み合わせで大域脱出を行います。 throw 
は同じ tag を指定した catch のブロックの終わりまでジャンプします。

throw は探索時に呼び出しスタックをさかのぼるので、
ジャンプ先は同じメソッド内にあるとは限りません。
もし ensure節 が存在するならジャンプ前に実行します。

もし同じ tag で待っている catch が存在しない場合は [[c:NameError]] で
スレッドが終了します。

#@since 1.9.0
同じタグであるとは [[m:Object#object_id]] が同じであるという意味です。
#@end

#@since 1.9.0
@param tag catch の引数に対応する任意のオブジェクトです。
#@else
@param tag シンボルまたは文字列です。
#@end
@param value catch の戻り値になります。
@raise NameError 同じ tag で待っている catch が存在しない場合に発生します。

  def foo
    throw :exit, 25
  end
  
  ret = catch(:exit) do
    begin
      foo
      some_process()    # 絶対に実行されない
      10
    ensure
      puts "ensure"
    end
  end
  puts ret
  #=> ensure
  #   25

@see [[m:Kernel.#catch]]

--- rand(max = 0) -> Integer|Float

擬似乱数を得るメソッドです。

max.to_i.abs（引数の整数表現の絶対値）が 0以外 の場合、
0 以上 max.to_i.abs 未満の範囲の整数をランダムに返します。
また 0 の場合、0.0 以上 1.0 未満の範囲の浮動小数点数をランダムに返します。

まだ [[m:Kernel.#srand]] が呼ばれていなければ自動的に呼び出します。

@param max 数値オブジェクトです。

  p rand(63) #=> 20
  p rand(63) #=> 56
  p rand(0) #=> 0.341033520223401
  p rand(0) #=> 0.31341550089985
  
  p rand(-5) #=> 2
  p rand(0.9) #=> 0.195303845149051
  p rand(1.5) #=> 0

@see [[m:Kernel.#srand]], [[m:Object#to_int]], [[m:Numeric#abs]]

--- srand -> Integer
--- srand(seed) -> Integer

[[m:Kernel.#rand]] の乱数の種を設定し、古い種を返します。

seed.to_i（引数の整数表現）を乱数の種に設定します。
seed に既知の値を与えると、以前の Kernel.#rand の値を再現できます。

#@#(ただし最初だけは 0 を返します)。
初期値 seed が省略された時には
現在の時刻やプロセス ID、srand を呼び出した回数、
また可能なら /dev/urandom から読み出したデータなどを元に種を作ります。

#@since 1.8.3
@param seed 乱数の種となる数値を指定します。to_int メソッドにより整数に変換されます。
            [[c:Bignum]] も指定可能です。
#@else
@param seed 乱数の種となる数値を指定します。to_int メソッドにより整数に変換されます。
            unsigned long よりも大きな値を与えることは出来ません。
#@end

  num = 455675
  seeds = []
  
  srand(num)
  
  p rand(6) #=> 3
  p rand(6) #=> 0
  p rand(0) #=> 0.445804380918972
  p rand(0) #=> 0.422248634121701
  
  seeds << srand
  
  p rand(6) #=> 3
  p rand(6) #=> 3
  p rand(0) #=> 0.938911141393347
  p rand(0) #=> 0.915824970865251
  
  seeds << srand(num)
  
  p rand(6) #=> 3
  p rand(6) #=> 0
  p rand(0) #=> 0.445804380918972
  p rand(0) #=> 0.422248634121701
  
  seeds << srand
  
  p seeds #=> [455675, 2995620310703489221660585195204777696, 455675]

@see [[m:Kernel.#rand]], [[m:Object#to_int]]

--- global_variables -> [String]

プログラム中で定義されているグローバル変数(`$'で始まる変数)名の
配列を返します。

  p global_variables #=> ["$-p", "$-I", "$-v" ... ]

@see [[m:Kernel.#local_variables]],[[m:Object#instance_variables]],[[m:Module.constants]],[[m:Module#constants]],[[m:Module#class_variables]]

--- local_variables -> [String]

現在のスコープで定義されているローカル変数名の配列を返します。

  yuyu = 0
  p local_variables #=> ["yuyu"]

@see [[m:Kernel.#global_variables]],[[m:Object#instance_variables]],[[m:Module.constants]],[[m:Module#constants]],[[m:Module#class_variables]]



#@until 1.9.0
--- sub(pattern, replace)          -> String
--- sub!(pattern, replace)         -> String
--- sub(pattern) {|matched| ... }  -> String
--- sub!(pattern) {|matched| ... } -> String

組み込み変数 [[m:$_]] の指す文字列内で pattern に
マッチする最初の部分を replace に置き換えます。$_ を返します。

$_.sub, $_.sub! とほぼ同じです。

暗号的になりすぎるきらいがあるため、このメソッドの使用は推奨されていません。
今後はより明示的な $_.sub, $_.sub! を使ってください。

$_.sub とこのメソッド sub は以下の点で違いがあります。

  * sub は $_ の値をコピーして、コピーの方を更新し、
  $_ に再代入します。

@param pattern [[m:String#sub]] 参照
@param replace [[m:String#sub]] 参照
@see [[m:String#sub]],[[m:$_]]

--- gsub(pattern, replace)          -> String
--- gsub!(pattern, replace)         -> String
--- gsub(pattern) {|matched| ... }  -> String
--- gsub!(pattern) {|matched| ... } -> String

組み込み変数 [[m:$_]] の指す文字列内で pattern に
マッチする部分を全て replace に置き換えます。$_ を返します。

$_.gsub, $_.gsub! とほぼ同じです。

暗号的になりすぎるきらいがあるため、このメソッドの使用は推奨されていません。
今後はより明示的な $_.gsub, $_.gsub! を使ってください。

$_.gsub とこのメソッド gsub は以下の点で違いがあります。

  * gsub は $_ の値をコピーして、コピーの方を更新し、
  $_ に再代入します。

@param pattern [[m:String#gsub]] 参照
@param replace [[m:String#gsub]] 参照
@see [[m:String#gsub]],[[m:$_]]

--- chop  -> String
--- chop! -> String | nil

組み込み変数 $_ を最後の文字を取り除いたものにし
ます(終端が"\r\n"であれば2文字取り除きます)。

chop! は文字列そのものを変更しその結果を返しますが、
取り除く文字列がなければ nil を返します。

$_.chop, $_.chop! とほぼ同じです。

暗号的になりすぎるきらいがあるため、このメソッドの使用は推奨されていません。
今後はより明示的な $_.chop, $_.chop! を使ってください。

$_.chopとこのメソッド chop は以下の点で違いがあります。

  * chop は $_ の値をコピーして、コピーの方を更新し、
  $_ に再代入します。

@see [[m:String#chop]],[[m:$_]]

--- chomp(rs = $/)  -> String
--- chomp!(rs = $/) -> String | nil

組み込み変数 $_ を rs で指定される末尾
の文字列を取り除いたものにします。

chomp! は文字列そのものを変更しその結果を返しますが、
取り除く文字列がなければ nil を返します。
rs のデフォルト値は $/ です。

$_.chomp, $_.chomp! とほぼ同じです。

暗号的になりすぎるきらいがあるため、このメソッドの使用は推奨されていません。
今後はより明示的な $_.chomp, $_.chomp!を使ってください。

$_.chomp とこのメソッド chomp は以下の点で違いがあります。

  * chomp は $_ の値をコピーして、コピーの方を更新し、
  $_ に再代入します。

@param rs [[m:String#chomp]] 参照
@see [[m:String#chomp]],[[m:$_]],[[m:$/]]

--- split(sep = $/, limit = 0) -> [String]

$_.split と同じです。

暗号的になりすぎるきらいがあるため、このメソッドの使用は推奨されていません。
今後はより明示的な $_.split を使ってください。

@param sep [[m:String#split]] 参照
@param limit [[m:String#split]] 参照
@see [[m:String#split]],[[m:$_]]

--- scan(re)                  -> [String] | [[String]]
--- scan(re) {|matched| ... } -> [String] | [[String]]

$_.scan と同じです。

暗号的になりすぎるきらいがあるため、このメソッドの使用は推奨されていません。
今後はより明示的な $_.scan を使ってください。

@param re [[m:String#scan]] 参照
@see [[m:String#scan]],[[m:$_]]

#@end

--- trap(signal, command) -> object
--- trap(signal) { ... } -> object
#@since 1.8.0
signal で指定された割り込みにたいするハンドラとして
command を登録します。[[m:Signal.#trap]]と同じです。

[[m:Signal.#trap]]の使用を推奨します。

@param signal [[m:Signal.#trap]] 参照
@param command [[m:Signal.#trap]] 参照

@see [[m:Signal.#trap]],[[c:Signal]]
#@else
signal で指定された割り込みにたいするハンドラとして
command を登録します。signal はシグナル名の
文字列か [[c:Symbol]]、またはシグナル番号で指定します。

command は文字列またはブロックで指定します。
nil、空文字列""、"SIG_IGN" または
"IGNORE" を指定した時は、そのシグナルを無視します
(可能ならば)。
"SIG_DFL" または "DEFAULT" を指定した時は、
デフォルトの動作を行なうようになります。
"EXIT"を指定した時は、シグナルを受け取ると終了処理を
行ったあとステータス 0 で終了します。

また signal の特別な値として 0 または "EXIT"
を指定できます。これは「プログラムの終了時」を表します。

いくつかのシグナルに対して、Ruby インタプリタは例外 [[c:Interrupt]] や
[[c:SignalException]] を発生させます。このようなシグナルは例外処理によっ
て捕捉することもできます。

    begin
      Process.kill :QUIT, $$   # 自身にSIGQUITを送信
    rescue SignalException
      puts "rescue #$!"
    end
    #=> rescue SIGQUIT

trap() により捕捉されたシグナルは例外を発生させません。

trap は既にシグナルに対応する command が登録されて
いれば、それを返します(ブロックは [[c:Proc]] オブジェク
トとして返されます。"IGNORE" や "DEFAULT" に対しては
nil を返します)。何も登録されていなければ
nil を返します。

#@##@since 1.8.0
trap 実行前に"IGNORE" や "DEFAULT" が登録されていたなら、
"IGNORE"、"DEFAULT" を返します。ruby インタプリタが知り得ない
シグナルハンドラが登録されていた場合((-ちょっとウソ-))は nil を返します。

    p trap(:INT, "p true")     #=> nil
    p trap(:INT) { }           #=> "p true"
    p trap(:INT, "SIG_IGN")    #=> #<Proc:0x401b1328>
    p trap(:INT, "DEFAULT")    #=> nil
    p trap(:INT, "EXIT")       #=> nil
    p trap(:INT, nil)          #=> "EXIT"
#@##@end

存在しないシグナルを指定した場合は、例外 [[c:ArgumentError]] が発
生します。なお、Windows (mswin32, mingw32)では、INT
ILL FPE SEGV TERM BREAK ABRT そして EXIT しか指定できません。
#@end

--- trace_var(varname, hook) -> nil
--- trace_var(varname){|new_val| .... } -> nil
--- trace_var(varname, hook) -> [String|Proc]

グローバル変数 varname への代入のフックを登録します。

ここでの「グローバル変数」は、
[[unknown:特殊変数|組み込み変数]]も含めた `$' で始まる変数のことです。

この呼び出し以降、varname で指定したグローバル変数に
値が代入されるたびに hook かブロックが評価されます。hook が Proc オブジェクトの場合
代入された値がブロック引数に渡されます。文字列の場合はRubyコードとして評価されます。

trace_var がフックするのは明示的な代入だけです。
フックは複数登録できます。

フックを解除するには、hook に nil を
指定するか、[[m:Kernel.#untrace_var]] を用います。

hook が nil ならば、設定されていた
hook をすべて解除してその配列を返します(ブロックで登録されていれば
[[c:Proc]] オブジェクトで返されます)
それ以外は、nil を返します。

@param varname グローバル変数名を文字列か [[c:Symbol]] で指定します。
@param hook フックになる文字列または [[c:Proc]] オブジェクトです。
@return フックを登録した場合は nil を返します。解除した場合は解除した
        フックを並べた配列を返します。

    trace_var(:$v){|val| puts "hook: $v=#{val.inspect}" }
    $v = 1       #=> hook: $v=1
    $v = "foo"   #=> hook: $v="foo"
    $v.upcase!
    p $v         #=> "FOO"

@see [[m:Kernel.#untrace_var]]

--- untrace_var(varname, hook = nil) -> [String|Proc]

グローバル変数 varname に関連付けられたフックを解除します。

hook が指定された場合にはそのフックだけを解除します。
省略するか nil を与えた場合は
varname のフックを全て解除します。

@param varname グローバル変数名を文字列か [[c:Symbol]] で指定します。
@param hook 文字列または [[c:Proc]] オブジェクトです。
@return 解除されたフックの配列を返します。

  trace_var(:$v){|val| print "hookA.#{val.inspect},\n" }
  block = proc{|val| print "hookB.#{val.inspect}," }
  trace_var(:$v,&block)
  $v = 'str'        #=> hookB."str",hookA."str",
  
  untrace_var(:$v,block)
  $v = 'str'        #=> hookA."str",
  
  trace_var(:$v){|val| print "hookC.#{val.inspect}," }
  p untrace_var(:$v) #=> [#<Proc:0x02b68f58@..:9>, #<Proc:0x02b6978c@..:3>]
  $v = 'str'        # なにも出力されない

@see [[m:Kernel.#trace_var]]

--- raise -> ()
--- fail  -> ()
--- raise(message) -> ()
--- fail(message)  -> ()
--- raise(error_type, message = nil, backtrace = caller(0)) -> ()
--- fail(error_type, message = nil, backtrace = caller(0))  -> ()

例外を発生させます。
発生した例外は変数 [[m:$!]] に格納されます。また例外が
発生した時のスタックトレースは変数 [[m:$@]] に格納され
ます。発生した例外は rescue 節で捕捉できます。

引数無しの場合は、同スレッドの同じブロック内で最後に rescue された
例外オブジェクト ([[m:$!]]) を再発生させます。そのような
例外が存在しないが自身は捕捉されている時には例外 [[c:RuntimeError]] を発生させます。

    begin
      open("nonexist")
    rescue
      raise   #=> `open': No such file or directory - "nonexist" (Errno::ENOENT)
    end

引数を渡した場合は、例外メッセージ message を持った error_type の示す例外(省略時 RuntimeError)を
発生させます。

error_type として例外ではないクラスやオブジェクトを指定した場合、
そのオブジェクトの exception メソッドが返す値を発生する例外にします。
その際、exception メソッドに引数として変数 message を渡すことができます。

@param error_type 発生させる例外を例外クラスまたは例外クラスのインスタンスで指定します。
@param message 例外のメッセージとなる文字列です。
@param backtrace 例外発生時のスタックトレースで、[[m:Kernel.#caller]] の戻り値と同じ
  形式で指定しなければいけません。
@raise TypeError exception メソッドが例外オブジェクトを返さなかった場合に発生します。

例外の捕捉の例を示します。

  #例1
  begin
    raise NameError,"!!error!!"
  rescue ArgumentError => rer
  rescue NameError => rer
  rescue TypeError => rer
  ensure
    p rer #=> #<NameError: !!error!!>
  end
  
  #例2
  def foo num
    print 'in method.'
    raise "error!!" if num <= 9
  rescue RuntimeError
    num += 10
    print 'in rescue.'
    retry
  else
    print 'in else.'
  ensure
    print "in ensure.\n"
  end
  
  foo(4) #=> in method.in rescue.in method.in else.in ensure.
  
  #例3
  class MyException
    def exception(mesg=nil)
      SecurityError.new(mesg)
    end
  end
  
  raise MyException.new rescue p $! #=> #<SecurityError: SecurityError>

@see [[m:Kernel.#caller]]

--- printf(format, *arg) -> nil
--- printf(port, format, *arg) -> nil

C 言語の printf と同じように、format に従い引数を文字列に変
換して port に出力します。

port を省略した場合は標準出力 [[m:$stdout]] に出力します。

引数を 1 つも指定しなければ何もしません。

Ruby における format 文字列の拡張については
[[m:Kernel.#sprintf]]の項を参照してください。

@param port 出力先になる[[c:IO]] のサブクラスのインスタンスです。
@param format フォーマット文字列です。
@param arg フォーマットされる引数です。
@raise ArgumentError port を指定したのに format を省略した場合に発生します。
@raise IOError port が書き込み用にオープンされていなければ発生します。
@raise Errno::EXXX 出力に失敗した場合に発生します。 

  printf("calculate%3s%-6s%.15f", 'PI', '...', Math::PI) 
  #=> calculate PI...   3.141592653589793
  
  printf("%d %04x", 123, 123)               #=> "123 007b"
  printf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
  printf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
  printf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
  printf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
  printf("%u", -123)                        #=> "..4294967173"

@see [[m:Kernel.#sprintf]],[[m:IO#printf]]

--- sprintf(format, *arg) -> String
--- format(format, *arg) -> String

format 文字列を C 言語の sprintf と同じように解釈し、
引数をフォーマットした文字列を返します。

@param format フォーマット文字列です。
@param arg フォーマットされる引数です。
@see [[m:Kernel.#printf]],[[m:Time#strftime]],[[m:Date.strptime]]

#@include(printf-format)

--- binding -> Binding

変数・メソッドなどの環境情報を含んだ [[c:Binding]] オブジェクトを
生成して返します。通常、[[m:Kernel.#eval]] の第二引数として使います。

  def foo
    a = 1
    binding
  end

  eval("p a", foo)  #=> 1

@see [[m:Kernel.#eval]],[[m:Kernel::TOPLEVEL_BINDING]]

--- eval(expr) -> object
--- eval(expr, bind, fname = __FILE__, lineno = 1) -> object

文字列 expr を Ruby プログラムとして評価してその結果を返しま
す。第2引数に [[c:Proc]] オブジェクトまたは [[c:Binding]] オブジェ
クトを与えた場合、そのオブジェクトを生成したコンテキストで文字列を
評価します。

expr の中のローカル変数の扱いはブロックの場合と同じです。すなわち、eval 
実行前に補足されていた変数は eval 実行後にブロック外に持ち出せます。

fname と lineno が与えられた場合には、ファイル
fname の行番号 lineno から文字列 expr が書かれているかのように
コンパイルされます。スタックトレースの表示などを差し替えることが
できます。

bind によらずに特定のオブジェクトのコンテキストで expr を評価したい
場合、 [[m:Module#module_eval]], [[m:Object#instance_eval]] が使えます。

@param expr  評価する文字列です。
@param bind  [[c:Proc]] オブジェクトまたは [[c:Binding]] オブジェクトです。
@param fname スタックトレースに表示するファイル名です。
@param lineno 文字列 expr が書かれていると想定する先頭の行番号を整数で指定します。

  a = nil
  eval('a = RUBY_RELEASE_DATE')
  p a #=> "2007-03-13"
  
  eval('def fuga;p 777 end')
  fuga #=> 777
  
  eval('raise RuntimeError', binding, 'XXX.rb', 4)
  #=> XXX.rb:4: RuntimeError (RuntimeError)
  #       from ..:9

@see [[m:Kernel.#binding]],[[m:Module#module_eval]],[[m:Object#instance_eval]],[[m:Object#method]],[[m:Object#send]]

#@#==== リフレクション

--- proc { ... } -> Proc
--- lambda { ... } -> Proc
--- proc -> Proc
--- lambda -> Proc

与えられたブロックから手続きオブジェクト ([[c:Proc]] のインスタンス)
を生成して返します。[[m:Proc.new]] に近い働きをします。

ブロックが指定されなければ、呼び出し元のメソッドで指定されたブロック
を手続きオブジェクトとして返します。呼び出し元のメソッドがブロックなし
で呼ばれると [[c:ArgumentError]] 例外が発生します。

ただし、ブロックを指定しない呼び出しは推奨されていません。呼び出し元のメソッドで指定されたブロック
を得たい場合は明示的に & 引数でうけるべきです。

@raise ArgumentError スタック上にブロックがないのにブロックを省略した呼び出しを行ったときに発生します。

  def foo &block
    lambda(&block)
  end
  
  it = foo{p 12}
  it.call #=> 12

@see [[c:Proc]],[[m:Proc.new]]

#@since 1.8.0
#@include(lambda_proc)
#@end

#@since 1.8.7
--- __method__ -> Symbol

現在のメソッド名を返します。

  def foo
    p __method__
  end
  foo #=> :foo

#@end
