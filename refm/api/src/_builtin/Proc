= class Proc < Object

ブロックをコンテキスト(ローカル変数のスコープやスタックフ
レーム)とともにオブジェクト化した手続きオブジェクトです。

Proc は ローカル変数のスコープを導入しないことを除いて
名前のない関数のように使えます。ダイナミックローカル変数は
Proc ローカルの変数として使えます。

Proc がローカル変数のスコープを保持していることは以下の例で
変数 var を参照できていることからわかります。

  var = 1
  $foo = Proc.new { var }
  var = 2
  
  def foo
    $foo.call
  end
  
  p foo       # => 2

=== 手続きを中断して値を返す

手続きオブジェクトを中断して、呼出し元(呼び出しブロックでは yield、それ以外では [[m:Proc#call]])
に値を返すには、 next を使います。break や return ではありません。

例:

  def foo
    f = Proc.new{
      next 1
      2
    }
  end
  
 p foo.call       #=> 1


=== orphan な手続きオブジェクトの挙動

Proc を生成したメソッドからリターンしてしまった後は Proc
からの return, retry は例外 [[c:LocalJumpError]] を発生させます。

  def foo
    proc { return }
  end

  foo.call
  # => in `call': return from proc-closure (LocalJumpError)

  def foo
    proc { retry }
  end

  foo.call
  # => in `call': retry from proc-closure (LocalJumpError)

ブロック付きメソッドに対して Proc オブジェクトを `&' を指定して渡すと
呼び出しブロックのように動作しますが、厳密には以下の違いがあります

  # 問題なし
  (1..5).each { break }

  # ruby 1.6.7, 1.8 で問題なし。1.6.8 では例外
  proc = Proc.new { break }
  (1..5).each(&proc)

  # ruby 1.6 では、LocalJumpError
  # ruby 1.8 では、each 再実行
  proc = Proc.new { retry }
  (1..5).each(&proc)
  #=> retry from proc-closure (LocalJumpError)

これは、Proc オブジェクトが呼び出しブロックとして振舞う際の制限です。

== Class Methods

--- new -> Proc
--- new { ... } -> Proc

ブロックをコンテキストとともにオブジェクト化して返します。

ブロックを指定しなければ、このメソッドを呼び出したメソッドが
ブロックを伴うときに、それを Proc オブジェクトとして生成して返します。

  def foo
    pr = Proc.new
    pr.call(1)
  end
  foo {|arg| p arg }
  # => 1

これは以下と同じです。

  def foo
    yield(1)
  end
  foo {|arg| p arg }
  # => 1

呼び出し元のメソッドがブロックを伴わなければ、例外
[[c:ArgumentError]] が発生します。

  def foo
    Proc.new
  end
  foo
  # => -:2:in `new': tried to create Proc object without a block (ArgumentError)
          from -:2:in `foo'
          from -:4

Proc.new は、Proc#initialize が定義されていれば
オブジェクトの初期化のためにこれを呼び出します。このことを
除けば、[[m:Kernel.#proc]] と同じです。

== Instance Methods

--- [](*arg) -> ()
--- call(*arg) -> ()

手続きオブジェクトを実行してその結果を返します。

引数はブロックの引数にそのまま(多重代入のルールに従い)代入されます。

@param arg 手続きオブジェクトに与える引数を指定します。

@raise LocalJumpError Procを生成したメソッドからリターンしてしまった場合に発生します。

--- arity -> Fixnum

Procオブジェクトの引数の数を返します。

self が引数の数を可変長で受け取れる場合

  -(最低限必要な数+1)

を返します。

--- binding -> Binding

Proc オブジェクトが保持するコンテキストを 
[[c:Binding]] オブジェクトで返します。

--- to_proc -> self

self を返します。

--- to_s -> String

self の文字列表現を返します。

可能なら self を生成したソースファイル名、行番号を含みます。

  p Proc.new {
     true
  }.to_s

  => "#<Proc:0x0x401a880c@-:3>"

#@since 1.9.0
--- yield(*arg) -> ()

[[m:Proc#call]] と同じですが、引数の数のチェックを行いません。

  pr = Proc.new {|a,b,c| p [a,b,c]}
  pr.yield(1)        #=> [1, nil, nil]
  pr.yield(1,2,3,4)  #=> [1, 2, 3]
  pr.call(1)         #=> wrong # of arguments (4 for 3) (ArgumentError)

これは [[unknown:メソッド呼び出し/yield]] と同じ動作です。

  def foo
    yield(1)
  end
  foo {|a,b,c| p [a,b,c]}

@param arg 手続きオブジェクトに与える引数を指定します。

@raise LocalJumpError Procを生成したメソッドからリターンしてしまった場合に発生します。

#@end

