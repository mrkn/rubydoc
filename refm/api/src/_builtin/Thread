= class Thread < Object

スレッドを表すクラスです。

Thread を使うことで並行プログラミングが可能になります。スレッド
はメモリ空間を共有して同時に実行される制御の流れです。
#@since 1.9.0
ネイティブスレッドを用いて実装されていますが、
現在の実装では Ruby VM は Giant VM lock を有しており、同時に実行される
ネイティブスレッドは常にひとつです。
#@else
ただし、現在の実装では Ruby インタプリタは時分割でスレッドを実行しますので、
スレッドを使うことで実行速度が速くなることはありません。
#@end
#@since 1.9.0
Ruby のスレッドスケジューリングはネイティブスレッドのそれを利用しています。
よって詳細はプラットフォームに依存します。
#@else
Ruby のスレッドスケジューリングは優先順位付のラウンドロビンです。一定
時間毎、あるいは実行中のスレッドが権利を放棄したタイミングでスケジュー
リングが行われ、その時点で実行可能なスレッドのうち最も優先順位が高いも
のにコンテキストが移ります。
#@end

プログラムの開始と同時に生成されるスレッドを「メインスレッド」と呼
びます。なんらかの理由でメインスレッドが終了する時には、他の全てのスレッ
ドもプログラム全体も終了します。ユーザからの割込みによって発生した例外
はメインスレッドに送られます。

スレッドの起動時に指定したブロックの実行が終了するとスレッドの実行も終
了します。ブロックの終了は正常な終了も例外などによる異常終了も含みます。

=== 例外発生時のスレッドの振る舞い

あるスレッドで例外が発生し、そのスレッド内で rescue で捕捉されなかっ
た場合、通常はそのスレッドだけがなにも警告なしに終了されます。ただ
しその例外で終了するスレッドを [[m:Thread#join]] で待っている他の
スレッドがある場合、その待っているスレッドに対して、同じ例外が再度
発生します。

  begin
    t = Thread.new do
      Thread.pass    # メインスレッドが確実にjoinするように
      raise "unhandled exception"
    end
    t.join
  rescue
    p $!  # => "unhandled exception"
  end

また、以下の 3 つの方法により、いずれかのスレッドが例外によって終
了した時に、インタプリタ全体を中断させるように指定することができま
す。

  * 組み込み変数 [[m:$DEBUG]] を真に設定する(デバッグモード)
    ruby インタプリタを [[unknown:Rubyの起動/-d]] 付きで起動した場合も同様。
  * [[m:Thread.abort_on_exception]] でフラグを設定する。
  * [[m:Thread#abort_on_exception]] で指定
    したスレッドのフラグを設定する。

上記3つのいずれかが設定されていた場合、インタプリタ全体が中断されます。

=== スレッド終了時の ensure 節の実行

スレッド終了時には ensure 節が実行されます。
これはスレッドが正常に終了する時はもちろんですが、他のスレッドから [[m:Thread#kill]]
などによって終了させられた時も同様に実行されます。[[m:Thread#kill!]] が呼ばれた時は
ensure 節が実行されません。

ただしメインスレッドに対して [[m:Thread#kill!]] が呼ばれても ensure 節が実行されます。
メインスレッドの終了時の詳細に関しては [[unknown:終了処理]] を参照して下さい。

=== スレッドの状態

個々のスレッドは、以下の実行状態を持ちます。これらの状態は
[[m:Object#inspect]] や
[[m:Thread#status]] によって見ることができます。

 p Thread.new {sleep 1} # => #<Thread:0xa039de0 sleep>

: run (実行or実行可能状態)
 生成されたばかりのスレッドや [[m:Thread#run]] や
 [[m:Thread#wakeup]] で起こされたスレッドはこの状態です。
 [[m:Thread#join]] でスレッドの終了を待っているスレッドもスレッドの
 終了によりこの状態になります。
 
 この状態のスレッドは「生きて」います。

: sleep (停止状態)
 [[m:Thread.stop]] や [[m:Thread#join]] により停止されたスレッ
 ドはこの状態になります。
 
 この状態のスレッドは「生きて」います。

: aborting (終了処理中)
 [[m:Thread#kill]] 等で終了されるスレッドは一時的にこの状態になりま
 す。この状態から停止状態(sleep)になることもあります。
 
 この状態のスレッドはまだ「生きて」います。

: dead (終了状態)
 [[m:Thread#kill]] 等で終了したスレッドはこの状態になります。この状
 態のスレッドはどこからも参照されていなければ GC によりメモリ上から
 なくなります。
 
 この状態のスレッドは「死んで」います。


=== デッドロックの検出
#@since 1.9.0
#@todo
#@else
ruby はデッドロックを検出します。デッドロックを検出した場合、例外 [[c:fatal]] が
発生してプロセスは終了します。デッドロックの条件は以下のとおりです。

  * スレッドが複数ある
  * すべてのスレッドが sleep (停止状態) である
  * すべてのスレッドが IO 待ちでない

メインスレッドだけが [[m:Thread.stop]] で停止している状態は sleep forever と同じと見なし、
fatal は発生しません。

#@# [[ruby-dev:31041]]
#@end

== Class Methods
--- abort_on_exception             -> bool
--- abort_on_exception=(newstate)

真の時は、いずれかのスレッドが例外によって終了した時に、インタプリタ
全体を中断させます。false の場合、あるスレッドで起こった例外は、[[m:Thread#join]]
などで検出されない限りそのスレッドだけをなにも警告を出さずに終了させます。

デフォルトは false です。

[[unknown:Thread#スレッドと例外]]に詳述されています。

@param newstate スレッド実行中に例外発生した場合、インタプリタ全体を終了させるかどうかを true か false で指定します。

--- critical             -> nil
--- critical=(newstate)

#@since 1.9.0
サポートされていません。警告を出力し、何もせずに nil を返します。
#@else
真である間、スレッドの切替えを行いません。

カレントスレッドが停止状態になった場合や、シグナルに割り込まれた場合には、
自動的に false になります。
ただし、[[m:Thread.new]] によりスレッドを生成した場合には、critical 
の値に関わらず そのスレッドは実行されます。
また、[[m:Thread.pass]] により明示的に切替えることもできます。

デフォルトは false です。

注意: I/O や GC、拡張ライブラリがからむとこのフラグは無視さ
れることもあります。排他制御を行うにはこのメソッドに頼らず
[[c:Mutex]] や [[c:Monitor]] を使うべきです。

@param newstate スレッドの切替えを許す稼働かを、true か false で指定します。
#@end

--- current    -> Thread

現在実行中のスレッド(カレントスレッド)を返します。

  p Thread.current #=> #<Thread:0x4022e6fc run>

--- exit    -> ()

カレントスレッドに対して [[m:Thread#exit]] を呼びます。

--- kill(thread)    -> Thread

指定したスレッド thread に対して [[m:Thread#exit]] を呼びます。終了したスレッドを返します。

@param thread 終了したい Thread オブジェクトを指定します。

  th = Thread.new do
  end
    
  p Thread.kill(th)     #=> #<Thread:0x40221bc8 dead>

--- list    -> [Thread]

#@since 1.8.0
全ての生きているスレッドを含む配列を生成して返します。aborting 状態であるスレッド
も要素に含まれます。
#@else
生きているスレッドのうち、実行中(run)または停止中(stop)のスレッド
の配列を返します。
#@end

  Thread.new do
    sleep 
  end
  sleep 0.1
  
  p Thread.list   #=> [#<Thread:0x40377a54 sleep>, #<Thread:0x4022e6fc run>]

--- main    -> Thread

メインスレッドを返します。

  p Thread.main #=> #<Thread:0x4022e6fc run>

--- new(*arg) {|*arg| ... }         -> Thread
--- start(*arg) {|*arg| ... }       -> Thread
--- fork(*arg) {|*arg| ... }        -> Thread

スレッドを生成して、ブロックの評価を開始します。
生成したスレッドを返します。

@param arg 引数 arg はそのままブロックに渡されます。スレッドの開始と同時にその
スレッド固有のローカル変数に値を渡すために使用します。

例えば、以下のコードは間違いです。スレッドの実行が開始される前に
変数 i が書き変わる可能性があるからです。

  for i in 1..5
     Thread.start { p i }
  end

上の例は以下のように書き直すべきです。

  for i in 1..5
     Thread.start(i) {|t| p t }
  end

@raise ThreadError 現在のスレッドが属する [[c:ThreadGroup]] が freeze されている場合に発生します。またブロックを与えられずに呼ばれた場合にも発生します。

--- pass    -> nil

他のスレッドに実行権を譲ります。実行中のスレッドの状態を変えずに、
他の実行可能状態のスレッドに制御を移します。

 Thread.new do
   (1..3).each{|i|
     p i
     Thread.pass
   }
   exit
 end
 
 loop do
   Thread.pass
   p :main
 end

 #=>
 1
 :main
 2
 :main
 3
 :main

--- stop     -> nil

他のスレッドから [[m:Thread#run]] メソッドで再起動されるまで、カレ
ントスレッドの実行を停止します。

== Instance Methods

--- [](name)    -> object | nil

name に対応したスレッドに固有のデータを取り出します。
name に対応するスレッド固有データがなければ nil を返し
ます。

@pass name スレッド固有データのキーを文字列か [[c:Symbol]] で指定します。

--- []=(name,val)

val を name に対応するスレッド固有のデータとして格納します。

@param name スレッド固有データのキーを文字列か [[c:Symbol]] で指定します。文字列を指定した場合は [[m:String#to_sym]] によりシンボルに変換されます。

@param val スレッド固有データを指定します。nil を指定するとそのスレッド固有データは削除されます。

--- abort_on_exception               -> bool
--- abort_on_exception=(newstate)

真の場合、そのスレッドが例外によって終了した時に、インタプリタ
全体を中断させます。false の場合、あるスレッドで起こった例
外は、[[m:Thread#join]] などで検出されない限りそのスレッ
ドだけをなにも警告を出さずに終了させます。

デフォルトは偽です。[[unknown:Thread#スレッドと例外]]に詳述。

@param newstate 自身を実行中に例外発生した場合、インタプリタ全体を終了させるかどうかを true か false で指定します。

--- alive?     -> bool

スレッドが「生きている」時、true を返します。

[[m:Thread#status]] が真を返すなら、このメソッドも真です。

--- exit         -> self
--- kill         -> self
--- terminate    -> self

スレッドの実行を終了させます。終了時に ensure 節が実行されます。

ただし、スレッドは終了処理中(aborting)にはなりますが、
直ちに終了するとは限りません。すでに終了している場合は何もしません。このメソッドにより
終了したスレッドの [[m:Thread#value]] の返り値は不定です。
自身がメインスレッドであるか最後のスレッドである場合は、プロセスを [[m:Kernel.#exit]](0) 
により終了します。

  th1 = Thread.new do
    begin
      sleep 10
    ensure
      p "this will be displayed"
    end
  end

  sleep 0.1
  th1.kill

  #=> "this will be displayed"

#@since 1.8.6
--- exit!         -> self
--- kill!         -> self
--- terminate!    -> self

ensure 節を実行せずにスレッドの実行を終了させます。

ただし、スレッドは終了処理中(aborting)にはなりますが、
直ちに終了するとは限りません。すでに終了している場合は何もしません。このメソッドにより
終了したスレッドの [[m:Thread#value]] の返り値は不定です。
自身がメインスレッドであるか最後のスレッドである場合は、プロセスを [[m:Kernel.#exit]](0) 
により終了します。

  th1 = Thread.new do
    begin
      sleep 10
    ensure
      p "th1: this will be displayed"
    end
  end
  th2 = Thread.new do
    begin
      sleep 10
    ensure
      p "th2: this will NOT be displayed"
    end
  end
  
  th1.kill
  th2.kill!

  #=> "th1: this will be displayed"

@see [[m:Thread#exit]]
#@end

--- group    -> ThreadGroup | nil

スレッドが属している [[c:ThreadGroup]] オブジェクトを返します。
死んでいるスレッドは nil を返します。

    p Thread.current.group == ThreadGroup::Default
    # => true

--- join           -> self
#@since 1.8.0
--- join(limit)    -> self | nil
#@end

スレッド self の実行が終了するまで、カレントスレッドを停止し
ます。self が例外により終了していれば、その例外がカレントス
レッドに対して発生します。

#@since 1.8.0
limit を指定して、limit 秒過ぎても自身が終了しない場合、nil を返します。

@param limit タイムアウトする時間を整数か小数で指定します。単位は秒です。
#@end

@raise ThreadError join を実行することによってデッドロックが起きる場合に発生します。またカレントスレッドを join したときにも発生します。

以下は、生成したすべてのスレッドの終了を待つ例です。

   threads = []
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })

   threads.each {|t| t.join}

--- key?(name)     -> bool

name に対応したスレッドに固有のデータが定義されていれば
true を返します。

@param name 文字列か [[c:Symbol]] で指定します。

--- keys    -> [Symbol]

スレッド固有データに関連づけられたキーの配列を返します。キーは
[[c:Symbol]] で返されます。

    th = Thread.current
    th[:foo] = 'FOO'
    th['bar'] = 'BAR'
    p th.keys

    #=> [:bar, :foo]

--- priority    -> Integer
--- priority=(val)

スレッドの優先度を返します。この値の大きいほど優先度が高くなります。
メインスレッドのデフォルト値は 0 です。新しく生成されたスレッドは親スレッドの
priority を引き継ぎます。

#@since 1.9.0
@param val スレッドの優先度を指定します。プラットフォームに依存します。
#@else
@param val スレッドの優先度を指定します。負の値も指定できます。
#@end

--- raise(error_type, message, traceback)     -> ()

自身が表すスレッドで強制的に例外を発生させます。

@param error_type [[m:Kernel.#raise]] を参照してください。

@param message [[m:Kernel.#raise]] を参照してください。

@param traceback [[m:Kernel.#raise]] を参照してください。

  Thread.new {
    sleep 1
    Thread.main.raise "foobar"
  }

  begin
    sleep
  rescue
    p $!, $@
  end

  => #<RuntimeError: foobar>
     ["-:3"]

--- run    -> self

停止状態(stop)のスレッドを再開させます。
[[m:Thread#wakeup]] と異なりすぐにスレッドの切り替え
を行います。

@raise ThreadError 死んでいるスレッドに対して実行すると発生します。

--- safe_level    -> Integer

self のセーフレベルを返します。カレントスレッドの
safe_level は、[[m:$SAFE]] と同じです。

セーフレベルについては[[unknown:セキュリティモデル]]を参照してください。

--- status    -> String | false | nil

生きているスレッドの状態を文字列 "run"、"sleep", "aborting" のいず
れかで返します。正常終了したスレッドに対して false、例外によ
り終了したスレッドに対して nil を返します。
#@#((-((<ruby 1.6 feature>)): version 1.6.5 までは、終了処理中
#@#(aborting)のスレッドに対しては "run" を返していました-))

[[m:Thread#alive?]] が真を返すなら、このメソッドも真です。

--- stop?    -> bool

スレッドが終了(dead)あるいは停止(stop)している時、true を返します。

--- value    -> object 

スレッド self が終了するまで待ち([[m:Thread#join]] と同じ)、
そのスレッドのブロックが返した値を返します。スレッド実行中に例外が
発生した場合には、その例外を再発生させます。

スレッドが [[m:Thread#kill]] によって終了した場合は、返り値は不定です。

以下は、生成したすべてのスレッドの終了を待ち結果を出力する例です。

   threads = []
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })

   threads.each {|t| p t.value}

最後の行で、待ち合わせを行っていることがわかりにくいと思うなら以下
のように書くこともできます。

   threads.each {|t| p t.join.value}

--- wakeup    -> self

停止状態(stop)のスレッドを実行可能状態(run)にします。

@raise ThreadError 死んでいるスレッドに対して実行すると発生します。


#@since 1.9.0
--- add_trace_func
#@todo

--- set_trace_func
#@todo
#@end

== Constants

#@since 1.9.0
--- MUTEX_FOR_THREAD_EXCLUSIVE
#@end