= class Thread < Object

Ruby のスレッドを表現するクラスです。

Thread を使うことで並行プログラミングが可能になります。スレッド
はメモリ空間を共有して同時に実行される制御の流れです。ただし、現在の実
装では Ruby インタプリタは時分割でスレッドを実行しますので、スレッドを
使うことで実行速度が速くなることはありません。

プログラムの開始と同時に生成されるスレッドを「メインスレッド」と呼
びます。なんらかの理由でメインスレッドが終了する時には、他の全てのスレッ
ドもプログラム全体も終了します。ユーザからの割込みによって発生した例外
はメインスレッドに送られます。

スレッドの起動時に指定したブロックの実行が終了するとスレッドの実行も終
了します。ブロックの終了は正常な終了も例外などによる異常終了も含みます。

Ruby のスレッドスケジューリングは優先順位付のラウンドロビンです。一定
時間毎、あるいは実行中のスレッドが権利を放棄したタイミングでスケジュー
リングが行われ、その時点で実行可能なスレッドのうち最も優先順位が高いも
のにコンテキストが移ります。

=== スレッドと例外

あるスレッドで例外が発生し、そのスレッド内で rescue で捕捉されなかっ
た場合、通常はそのスレッドだけがなにも警告なしに終了されます。ただ
しその例外で終了するスレッドを [[m:Thread#join]] で待っている他の
スレッドがある場合、その待っているスレッドに対して、同じ例外が再度
発生します。

  begin
    t = Thread.new do
      Thread.pass    # メインスレッドが確実にjoinするように
      raise "unhandled exception"
    end
    t.join
  rescue
    p $!  # => "unhandled exception"
  end

また、以下の 3 つの方法により、いずれかのスレッドが例外によって終
了した時に、インタプリタ全体を中断させるように指定することができま
す。

  * 組み込み変数 [[m:$DEBUG]] を真に設定する(デバッグモード)
    ruby インタプリタを [[unknown:Rubyの起動/-d]] 付きで起動した場合も同様。
  * [[m:Thread.abort_on_exception]] でフラグを設定する。
  * [[m:Thread#abort_on_exception]] で指定
    したスレッドのフラグを設定する。

上記3つのいずれかが設定されていた場合、インタプリタ全体が中断されます。

=== スレッドの状態

個々のスレッドは、以下の実行状態を持ちます。これらの状態は
[[m:Object#inspect]] や
[[m:Thread#status]] によって見ることができます。

 p Thread.new {sleep 1} # => #<Thread:0xa039de0 sleep>

: run (実行or実行可能状態)
 生成されたばかりのスレッドや [[m:Thread#run]] や
 [[m:Thread#wakeup]] で起こされたスレッドはこの状態です。
 [[m:Thread#join]] でスレッドの終了を待っているスレッドもスレッドの
 終了によりこの状態になります。
 
 この状態のスレッドは「生きて」います。

: sleep (停止状態)
 [[m:Thread.stop]] や [[m:Thread#join]] により停止されたスレッ
 ドはこの状態になります。
 
 この状態のスレッドは「生きて」います。

: aborting (終了処理中)
 [[m:Thread#kill]] 等で終了されるスレッドは一時的にこの状態になりま
 す。この状態から停止状態(sleep)になることもあります。
 
 この状態のスレッドはまだ「生きて」います。

: dead (終了状態)
 [[m:Thread#kill]] 等で終了したスレッドはこの状態になります。この状
 態のスレッドはどこからも参照されていなければ GC によりメモリ上から
 なくなります。
 
 この状態のスレッドは「死んで」います。

== Class Methods
--- abort_on_exception             -> boolean
--- abort_on_exception=(newstate)
#@todo

真の時は、いずれかのスレッドが例外によって終了した時に、インタプリタ
全体を中断させます。デフォルトは偽、すなわち、通常あるスレッドで起こった例
外は、[[m:Thread#join]] などで検出されない限りそのスレッ
ドだけをなにも警告を出さずに終了させます。[[unknown:Thread#スレッドと例外]]に詳述。

参照の場合は真偽値を、代入形式では右辺 newstate を、返します。

--- critical             -> boolean
--- critical=(newstate)
#@todo

真である間、スレッドの切替えを行いません。カレントスレッドが停止
(stop)した場合やシグナルに割り込まれた場合には、自動的に
false になります。

ただし、[[m:Thread.new]] によりスレッドを生成した場合にはそ
のスレッドは実行されます。また、[[m:Thread.pass]] により明
示的に切替えることもできます。

参照の場合は真偽値を、代入形式では右辺 newstate を、返します。

注意: I/O や GC、拡張ライブラリがからむとこのフラグは無視さ
れることもあります。排他制御を行うにはこのメソッドに頼らず
[[c:Mutex]] や [[c:Monitor]] を使うべきです。

--- current    -> Thread
#@todo

現在実行中のスレッド(カレントスレッド)を返します。

--- exit    -> Thread
#@todo

カレントスレッドの実行を終了します。

カレントスレッドを返します。

#@#((-あらい 2001-10-14:
#@#p (Thread.new { Thread.exit }.value)
#@#は、false を表示します。Thread.exit や Thread#kill ではス
#@#レッドの終了結果を設定していないためです
#@#[[unknown:ruby-dev:14904]]-))

カレントスレッドが唯一のスレッドであるなら、[[m:Kernel.#exit]](0)
により終了します。

--- kill(thread)    -> Thread
#@todo

指定したスレッドの実行を終了させます。既に終了しているスレッドに対
しては何もしません。

thread を返します。 exit と同様 Thread の終了結果を設定しません

--- list    -> [Thread]
#@todo

生きているスレッドのうち、実行中(run)または停止中(stop)のスレッド
の配列を返します。

#@since 1.8.0
version 1.8 では、aborting 状態であるスレッド
も要素に含まれます。つまり「生きている」スレッドの配列を返します
#@end

--- main    -> Thread
#@todo

メインスレッドを返します。

--- new(*arg) {|*arg| ... }         -> Thread
--- start(*arg) {|*arg| ... }       -> Thread
--- fork(*arg) {|*arg| ... }        -> Thread
#@todo

スレッドを生成して、ブロックの評価を開始します。
生成したスレッドを返します。

@param arg 引数 arg はそのままブロックに渡されます。スレッドの開始と同時にその
スレッド固有のローカル変数に値を渡すために使用します。

例えば、以下のコードは間違いです。スレッドの実行が開始される前に
変数 i が書き変わる可能性があるからです。

  for i in 1..5
     Thread.start { p i }
  end

上の例は以下のように書き直すべきです。

  for i in 1..5
     Thread.start(i) {|t| p t }
  end

@raise ThreadError 現在のスレッドが属する [[c:ThreadGroup]] が freeze されている場合に発生します。またブロックを与えられずに呼ばれた場合にも発生します。

--- pass    -> nil
#@todo

他のスレッドに実行権を譲ります。実行中のスレッドの状態を変えずに、
他の実行可能状態のスレッドに制御を移します(明示的なスケジューリン
グ)。

--- stop     -> nil
#@todo

他のスレッドから [[m:Thread#run]] メソッドで再起動されるまで、カレ
ントスレッドの実行を停止します。

== Instance Methods

--- [](name)    -> nil | object
#@todo

name に対応したスレッドに固有のデータを取り出します。
name に対応するスレッド固有データがなければ nil を返し
ます。

@pass name スレッド固有データのキーを文字列か [[c:Symbol]] で指定します。

--- []=(name,val)
#@todo

val を name に対応するスレッド固有のデータとして格納します。

@param name スレッド固有データのキーを文字列か [[c:Symbol]] で指定します。

@param val スレッド固有データを指定します。nil を指定するとそのスレッド固有データは削除されます。

--- abort_on_exception               -> boolean
--- abort_on_exception=(newstate)
#@todo

真の時は、そのスレッドが例外によって終了した時に、インタプリタ
全体を中断させます。デフォルトは偽です。すなわち、通常あるスレッドで起こった例
外は、[[m:Thread#join]] などで検出されない限りそのスレッ
ドだけをなにも警告を出さずに終了させます。[[m:Thread#スレッドと例外]]に詳述。

--- alive?     -> boolean
#@todo

スレッドが「生きている」時、true を返します。

[[m:Thread#status]] が真を返すなら、このメソッドも真です。

--- exit         -> self
--- kill         -> self
--- terminate    -> self
#@todo

スレッドの実行を終了させます。ただし、スレッドは終了処理中(aborting)にはなりますが、
直ちに終了するとは限りません。すでに終了している場合は何もしません。

自身がメインスレッドであるか最後のスレッドである場合は、プロセスを [[m:Kernel.#exit]](0) 
により終了します。

#@since 1.8.6
--- thr.exit!         -> self
--- thr.kill!         -> self
--- thr.terminate!    -> self
#@todo

Terminates thr without calling ensure clauses and schedules another
thread to be run, returning the terminated Thread. If this is
the main thread, or the last thread, exits the process.

See [[m:Thread#exit]] for the safer version.

#@end

--- group    -> nil | ThreadGroup
#@todo

スレッドが属している [[c:ThreadGroup]] オブジェクトを返します。

    p Thread.current.group == ThreadGroup::Default
    # => true

死んでいるスレッドは nil を返します。

--- join           -> self
#@todo
#@since 1.8.0
--- join(limit)    -> nil | self
#@end
#@todo

スレッド self の実行が終了するまで、カレントスレッドを停止し
ます。self が例外により終了していれば、その例外がカレントス
レッドに対して発生します。

#@since 1.8.0
limit を指定すると、limit 秒でタイムアウトし、nil を返します。
@param limit タイムアウトする時間を整数(秒)で指定します。
#@end

以下は、生成したすべてのスレッドの終了を待つ例です。

   threads = []
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })

   threads.each {|t| t.join}

--- key?(name)     -> boolean
#@todo

name に対応したスレッドに固有のデータが定義されていれば
true を返します。

@param name 文字列か [[c:Symbol]] で指定します。

--- keys    -> [Symbol]
#@todo

スレッド固有データに関連づけられたキーの配列を返します。キーは
[[c:Symbol]] で返されます。

    th = Thread.current
    th[:foo] = 'FOO'
    th['bar'] = 'BAR'
    p th.keys

    #=> [:bar, :foo]

--- priority    -> Integer
#@todo

スレッドの優先度を返します。優先度のデフォルト値は 0 で、この値の
大きいスレッドは小さいスレッドよりも優先度が高くなります。

--- priority=(val)
#@todo

スレッドの優先度を設定します。負の値も指定できます。

#@#((<ruby 1.6 feature>)): version 1.6.5 までは self を返し
#@#ていました

--- raise(error_type, message, traceback)     -> ()
#@todo

そのスレッドで強制的に例外を発生させます。

引数の意味については組み込み関数 [[m:Kernel.#raise]] を参照してく
ださい。

  Thread.new {
    sleep 1
    Thread.main.raise "foobar"
  }

  begin
    sleep
  rescue
    p $!, $@
  end

  => #<RuntimeError: foobar>
     ["-:3"]

--- run    -> self
#@todo

停止状態(stop)のスレッドを再開させます。
[[m:Thread#wakeup]] と異なりすぐにスレッドの切り替え
を行います。

@raise ThreadError 死んでいるスレッドに対して実行すると発生します。

--- safe_level    -> Integer
#@todo

self のセーフレベルを返します。カレントスレッドの
safe_level は、[[m:$SAFE]] と同じです。

セーフレベルについては[[unknown:セキュリティモデル]]を参照してください。

--- status    -> String | nil | false
#@todo

生きているスレッドの状態を文字列 "run"、"sleep", "aborting" のいず
れかで返します。正常終了したスレッドに対して false、例外によ
り終了したスレッドに対して nil を返します。
#@#((-((<ruby 1.6 feature>)): version 1.6.5 までは、終了処理中
#@#(aborting)のスレッドに対しては "run" を返していました-))

[[m:Thread#alive?]] が真を返すなら、このメソッドも真です。

--- stop?    -> boolean
#@todo

スレッドが終了(dead)あるいは停止(stop)している時、true を返します。

--- value    -> object 
#@todo

スレッド self が終了するまで待ち([[m:Thread#join]] と同じ)、
そのスレッドのブロックが返した値を返します。スレッド実行中に例外が
発生した場合には、その例外を再発生させます。

スレッドが [[m:Thread#kill]] によって終了した場合は、返り値は不定です。

以下は、生成したすべてのスレッドの終了を待ち結果を出力する例です。

   threads = []
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })

   threads.each {|t| p t.value}

最後の行で、待ち合わせを行っていることがわかりにくいと思うなら以下
のように書くこともできます。

   threads.each {|t| p t.join.value}

--- wakeup    -> self
#@todo

停止状態(stop)のスレッドを実行可能状態(run)にします。

@raise ThreadError 死んでいるスレッドに対して実行すると発生します。

