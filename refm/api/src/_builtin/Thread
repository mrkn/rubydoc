= class Thread < Object

Ruby のスレッドを表現するクラスです。

Thread を使うことで並行プログラミングが可能になります。スレッド
はメモリ空間を共有して同時に実行される制御の流れです。ただし、現在の実
装では Ruby インタプリタは時分割でスレッドを実行しますので、スレッドを
使うことで実行速度が速くなることはありません。

プログラムの開始と同時に生成されるスレッドを「メインスレッド」と呼
びます。なんらかの理由でメインスレッドが終了する時には、他の全てのスレッ
ドもプログラム全体も終了します。ユーザからの割込みによって発生した例外
はメインスレッドに送られます。

スレッドの起動時に指定したブロックの実行が終了するとスレッドの実行も終
了します。ブロックの終了は正常な終了も例外などによる異常終了も含みます。

Ruby のスレッドスケジューリングは優先順位付のラウンドロビンです。一定
時間毎、あるいは実行中のスレッドが権利を放棄したタイミングでスケジュー
リングが行われ、その時点で実行可能なスレッドのうち最も優先順位が高いも
のにコンテキストが移ります。

=== スレッドと例外

あるスレッドで例外が発生し、そのスレッド内で rescue で捕捉されなかっ
た場合、通常はそのスレッドだけがなにも警告なしに終了されます。ただ
しその例外で終了するスレッドを [[m:Thread#join]] で待っている他の
スレッドがある場合、その待っているスレッドに対して、同じ例外が再度
発生します。

  begin
    t = Thread.new do
      Thread.pass    # メインスレッドが確実にjoinするように
      raise "unhandled exception"
    end
    t.join
  rescue
    p $!  # => "unhandled exception"
  end

また、以下の 3 つの方法により、いずれかのスレッドが例外によって終
了した時に、インタプリタ全体を中断させるように指定することができま
す。

  * 組み込み変数 [[m:$DEBUG]] を真に設定する(デバッグモード)
    ruby インタプリタを [[unknown:Rubyの起動/-d]] 付きで起動した場合も同様。
  * [[m:Thread.abort_on_exception]] でフラグを設定する。
  * [[m:Thread#abort_on_exception]] で指定
    したスレッドのフラグを設定する。

上記3つのいずれかが設定されていた場合、インタプリタ全体が中断されます。

=== スレッドの状態

個々のスレッドは、以下の実行状態を持ちます。これらの状態は
[[m:Object#inspect]] や
[[m:Thread#status]] によって見ることができます。

 p Thread.new {sleep 1} # => #<Thread:0xa039de0 sleep>

: run (実行or実行可能状態)
 生成されたばかりのスレッドや [[m:Thread#run]] や
 [[m:Thread#wakeup]] で起こされたスレッドはこの状態です。
 [[m:Thread#join]] でスレッドの終了を待っているスレッドもスレッドの
 終了によりこの状態になります。
 
 この状態のスレッドは「生きて」います。

: sleep (停止状態)
 [[m:Thread.stop]] や [[m:Thread#join]] により停止されたスレッ
 ドはこの状態になります。
 
 この状態のスレッドは「生きて」います。

: aborting (終了処理中)
 [[m:Thread#kill]] 等で終了されるスレッドは一時的にこの状態になりま
 す。この状態から停止状態(sleep)になることもあります。
 
 この状態のスレッドはまだ「生きて」います。

: dead (終了状態)
 [[m:Thread#kill]] 等で終了したスレッドはこの状態になります。この状
 態のスレッドはどこからも参照されていなければ GC によりメモリ上から
 なくなります。
 
 この状態のスレッドは「死んで」います。


=== デッドロックの検出
#@since 1.9.0
#@todo
#@else
ruby はデッドロックを検出します。デッドロックを検出した場合、例外 [[c:fatal]] が
発生してプロセスは終了します。デッドロックの条件は以下のとおりです。

  * スレッドが複数ある
  * すべてのスレッドが sleep (停止状態) である
  * すべてのスレッドが IO 待ちでない

メインスレッドだけが [[m:Thread.stop]] で停止している状態は sleep forever と同じと見なし、
fatal は発生しません。

#@# [[ruby-dev:31041]]
#@end

== Class Methods
--- abort_on_exception             -> boolean
--- abort_on_exception=(newstate)
#@todo

真の時は、いずれかのスレッドが例外によって終了した時に、インタプリタ
全体を中断させます。false の場合、あるスレッドで起こった例外は、[[m:Thread#join]]
などで検出されない限りそのスレッドだけをなにも警告を出さずに終了させます。

デフォルトは false です。

[[unknown:Thread#スレッドと例外]]に詳述されています。

@param newstate スレッド実行中に例外発生した場合、インタプリタ全体を終了させるかどうかを true か false で指定します。


--- critical             -> nil
--- critical=(newstate)
#@todo

#@since 1.9.0
サポートされていません。警告を出力し、何もせずに nil を返します。
#@else

真である間、スレッドの切替えを行いません。

カレントスレッドが停止状態になった場合や、シグナルに割り込まれた場合には、
自動的に false になります。
ただし、[[m:Thread.new]] によりスレッドを生成した場合には、critical 
の値に関わらず そのスレッドは実行されます。
また、[[m:Thread.pass]] により明示的に切替えることもできます。

デフォルトは false です。

注意: I/O や GC、拡張ライブラリがからむとこのフラグは無視さ
れることもあります。排他制御を行うにはこのメソッドに頼らず
[[c:Mutex]] や [[c:Monitor]] を使うべきです。

@param newstate スレッドの切替えを許す稼働かを、true か false で指定します。
#@end

--- current    -> Thread
#@todo

現在実行中のスレッド(カレントスレッド)を返します。

--- exit    -> Thread
#@todo

カレントスレッドに対して [[m:Thread#exit]] を呼びます。

--- kill(thread)    -> Thread
#@todo

指定したスレッド thread に対して [[m:Thread#exit]] を呼びます。

@param thread 終了したい Thread オブジェクトを指定します。

--- list    -> [Thread]
#@todo

生きているスレッドのうち、実行中(run)または停止中(stop)のスレッド
の配列を返します。

#@since 1.8.0
version 1.8 では、aborting 状態であるスレッド
も要素に含まれます。つまり「生きている」スレッドの配列を返します
#@end

--- main    -> Thread
#@todo

メインスレッドを返します。

--- new(*arg) {|*arg| ... }         -> Thread
--- start(*arg) {|*arg| ... }       -> Thread
--- fork(*arg) {|*arg| ... }        -> Thread
#@todo

スレッドを生成して、ブロックの評価を開始します。
生成したスレッドを返します。

@param arg 引数 arg はそのままブロックに渡されます。スレッドの開始と同時にその
スレッド固有のローカル変数に値を渡すために使用します。

例えば、以下のコードは間違いです。スレッドの実行が開始される前に
変数 i が書き変わる可能性があるからです。

  for i in 1..5
     Thread.start { p i }
  end

上の例は以下のように書き直すべきです。

  for i in 1..5
     Thread.start(i) {|t| p t }
  end

@raise ThreadError 現在のスレッドが属する [[c:ThreadGroup]] が freeze されている場合に発生します。またブロックを与えられずに呼ばれた場合にも発生します。

--- pass    -> nil
#@todo

他のスレッドに実行権を譲ります。実行中のスレッドの状態を変えずに、
他の実行可能状態のスレッドに制御を移します(明示的なスケジューリン
グ)。

--- stop     -> nil
#@todo

他のスレッドから [[m:Thread#run]] メソッドで再起動されるまで、カレ
ントスレッドの実行を停止します。

== Instance Methods

--- [](name)    -> nil | object
#@todo

name に対応したスレッドに固有のデータを取り出します。
name に対応するスレッド固有データがなければ nil を返し
ます。

@pass name スレッド固有データのキーを文字列か [[c:Symbol]] で指定します。

--- []=(name,val)
#@todo

val を name に対応するスレッド固有のデータとして格納します。

@param name スレッド固有データのキーを文字列か [[c:Symbol]] で指定します。

@param val スレッド固有データを指定します。nil を指定するとそのスレッド固有データは削除されます。

--- abort_on_exception               -> boolean
--- abort_on_exception=(newstate)
#@todo

真の場合、そのスレッドが例外によって終了した時に、インタプリタ
全体を中断させます。false の場合、あるスレッドで起こった例
外は、[[m:Thread#join]] などで検出されない限りそのスレッ
ドだけをなにも警告を出さずに終了させます。

デフォルトは偽です。[[unknown:Thread#スレッドと例外]]に詳述。

@param newstate 自身を実行中に例外発生した場合、インタプリタ全体を終了させるかどうかを true か false で指定します。

--- alive?     -> boolean
#@todo

スレッドが「生きている」時、true を返します。

[[m:Thread#status]] が真を返すなら、このメソッドも真です。

--- exit         -> self
--- kill         -> self
--- terminate    -> self
#@todo

スレッドの実行を終了させます。終了時に ensure 節が実行されます。
ただし、スレッドは終了処理中(aborting)にはなりますが、
直ちに終了するとは限りません。すでに終了している場合は何もしません。このメソッドにより
終了したスレッドの [[m:Thread#value]] の返り値は不定です。

自身がメインスレッドであるか最後のスレッドである場合は、プロセスを [[m:Kernel.#exit]](0) 
により終了します。

  th1 = Thread.new do
    begin
      sleep 10
    ensure
      p "this will be displayed"
    end
  end

  sleep 0.1
  th1.kill

  #=> "this will be displayed"

#@since 1.8.6
--- exit!         -> self
--- kill!         -> self
--- terminate!    -> self
#@todo

ensure 節を実行せずにスレッドの実行を終了させます。ただし、スレッドは終了処理中(aborting)にはなりますが、
直ちに終了するとは限りません。すでに終了している場合は何もしません。このメソッドにより
終了したスレッドの [[m:Thread#value]] の返り値は不定です。

自身がメインスレッドであるか最後のスレッドである場合は、プロセスを [[m:Kernel.#exit]](0) 
により終了します。
  th1 = Thread.new do
    begin
      sleep 10
    ensure
      p "th1: this will be displayed"
    end
  end
  th2 = Thread.new do
    begin
      sleep 10
    ensure
      p "th2: this will NOT be displayed"
    end
  end
  
  th1.kill
  th2.kill!

  #=> "th1: this will be displayed"

@see [[m:Thread#exit]]
#@end

--- group    -> nil | ThreadGroup
#@todo

スレッドが属している [[c:ThreadGroup]] オブジェクトを返します。

    p Thread.current.group == ThreadGroup::Default
    # => true

死んでいるスレッドは nil を返します。

--- join           -> self
#@since 1.8.0
--- join(limit)    -> nil | self
#@end
#@todo

スレッド self の実行が終了するまで、カレントスレッドを停止し
ます。self が例外により終了していれば、その例外がカレントス
レッドに対して発生します。

以下は、生成したすべてのスレッドの終了を待つ例です。

   threads = []
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })

   threads.each {|t| t.join}

#@since 1.8.0
limit を指定して、limit 秒過ぎても自身が終了しない場合、nil を返します。

@param limit タイムアウトする時間を整数か小数で指定します。
#@end

@raise ThreadError join を実行することによってデッドロックが起きる場合に発生します。またカレントスレッドを join したときにも発生します。

--- key?(name)     -> boolean
#@todo

name に対応したスレッドに固有のデータが定義されていれば
true を返します。

@param name 文字列か [[c:Symbol]] で指定します。

--- keys    -> [Symbol]
#@todo

スレッド固有データに関連づけられたキーの配列を返します。キーは
[[c:Symbol]] で返されます。

    th = Thread.current
    th[:foo] = 'FOO'
    th['bar'] = 'BAR'
    p th.keys

    #=> [:bar, :foo]

--- priority    -> Integer
--- priority=(val)
#@todo

スレッドの優先度を返します。この値の大きいほど優先度が高くなります。
メインスレッドのデフォルト値は 0 です。新しく生成されたスレッドは親スレッドの
priority を引き継ぎます。

#@since 1.9.0
@param val スレッドの優先度を指定します。プラットフォームに依存します。
#@else
@param val スレッドの優先度を指定します。負の値も指定できます。
#@end

--- raise(error_type, message, traceback)     -> ()
#@todo

そのスレッドで強制的に例外を発生させます。

引数の意味については組み込み関数 [[m:Kernel.#raise]] を参照してく
ださい。

  Thread.new {
    sleep 1
    Thread.main.raise "foobar"
  }

  begin
    sleep
  rescue
    p $!, $@
  end

  => #<RuntimeError: foobar>
     ["-:3"]

--- run    -> self
#@todo

停止状態(stop)のスレッドを再開させます。
[[m:Thread#wakeup]] と異なりすぐにスレッドの切り替え
を行います。

@raise ThreadError 死んでいるスレッドに対して実行すると発生します。

--- safe_level    -> Integer
#@todo

self のセーフレベルを返します。カレントスレッドの
safe_level は、[[m:$SAFE]] と同じです。

セーフレベルについては[[unknown:セキュリティモデル]]を参照してください。

--- status    -> String | nil | false
#@todo

生きているスレッドの状態を文字列 "run"、"sleep", "aborting" のいず
れかで返します。正常終了したスレッドに対して false、例外によ
り終了したスレッドに対して nil を返します。
#@#((-((<ruby 1.6 feature>)): version 1.6.5 までは、終了処理中
#@#(aborting)のスレッドに対しては "run" を返していました-))

[[m:Thread#alive?]] が真を返すなら、このメソッドも真です。

--- stop?    -> boolean
#@todo

スレッドが終了(dead)あるいは停止(stop)している時、true を返します。

--- value    -> object 
#@todo

スレッド self が終了するまで待ち([[m:Thread#join]] と同じ)、
そのスレッドのブロックが返した値を返します。スレッド実行中に例外が
発生した場合には、その例外を再発生させます。

スレッドが [[m:Thread#kill]] によって終了した場合は、返り値は不定です。

以下は、生成したすべてのスレッドの終了を待ち結果を出力する例です。

   threads = []
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })

   threads.each {|t| p t.value}

最後の行で、待ち合わせを行っていることがわかりにくいと思うなら以下
のように書くこともできます。

   threads.each {|t| p t.join.value}

--- wakeup    -> self
#@todo

停止状態(stop)のスレッドを実行可能状態(run)にします。

@raise ThreadError 死んでいるスレッドに対して実行すると発生します。

