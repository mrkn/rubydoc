= class Array < Object
include Enumerable

配列クラス。配列の要素は任意の Ruby オブジェクトです。
一般的には配列は配列式を使って

  [1, 2, 3]

のように生成します。

== Class Methods

--- [](*item)    -> Array
#@todo

引数 item を要素として持つ配列を生成して返します。

  Array[1, 2, 3] #=> [1, 2, 3]

@param item 配列の要素を指定します。

--- new(size = 0, val = nil)    -> Array
#@todo

長さ size の配列を生成し、各要素を val で初期化して返します。

要素毎に val が複製されるわけではないことに注意してください。
全要素が同じオブジェクト val を参照します[[trap:Array]]。
以下の例では、配列の各要素は全て同一の文字列を指します。

    ary = Array.new(3, "foo")
    p ary #=> ["foo", "foo", "foo"]
    ary[0].capitalize!
    p ary #=> ["Foo", "Foo", "Foo"]

@param size 配列の長さを数値で指定します。

@param val 配列の要素の値を指定します。

#@since 1.8.0
--- new(ary)    -> Array
#@todo
指定された配列 ary を複製して返します。

    p Array.new([1,2,3]) # => [1,2,3]

@param array 複製したい配列を指定します。
#@end

--- new(size) {|index| ... }    -> Array

長さ size の配列を生成し、各要素の値をブロックの評価結果に設定します。

ブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。

    p Array.new(5) {|i| i }         # => [0, 1, 2, 3, 4]

    ary = Array.new(3, "foo")
    ary.each {|obj| p obj.object_id }
    # => 537774036
         537774036
         537774036

    ary = Array.new(3) { "foo" }
    ary.each {|obj| p obj.object_id }
    # => 537770448
         537770436
         537770424

@param size 配列の長さを数値で指定します。

== Instance Methods

--- [](nth)    -> nil | object
#@todo

nth 番目の要素を返します。nth 番目の要素が存在しない時には nil を返します。

  a = [ "a", "b", "c", "d", "e" ]
  a[0]  #=> "a"
  a[1]  #=> "b"
  a[-1] #=> "e"
  a[-2] #=> "d"
  a[10] #=> nil

@param nth インデックスを整数で指定します。
先頭の要素が 0 番目になります。nth の値が負の時には末尾からのインデックスと見倣します。末尾
の要素が -1 番目になります。

--- [](range)    -> nil | Array
#@todo

[[c:Range]] オブジェクト range の範囲にある要素からなる部分配列を返します。
range の first の値が配列の範囲に収まらない場合 nil を返します。
range の first が end より後にある場合には空の配列を返します。

  a = [ "a", "b", "c", "d", "e" ]
  a[0..1]   #=> ["a", "b"]
  a[0...1]  #=> ["a"]
  a[0..-1]  #=> ["a", "b", "c", "d", "e"]
  a[-2..-1] #=> ["d", "e"]
  a[-2..4]  #=> ["d", "e"]  (start は末尾から -2 番目、end は先頭から (4+1) 番目となる。)
  a[0..10]  #=> ["a", "b", "c", "d", "e"]
  a[10..11] #=> nil
  a[2..1]   #=> []
  a[-1..-2] #=> []

@param range 生成したい部分配列の範囲を [[c:Range]] オブジェクトで指定します。
range の first や end の値が負の時には末尾からのインデックスと見倣します。末尾
の要素が -1 番目になります。
end の値が配列の範囲を越える時には、越えた分は無視されます。
--- [](start, length)    ->  nil | Array
#@todo

start 番目から length 個の要素を含む部分配列を返します。
length が負の時、start が自身の範囲を越えた時には nil を返します。

  a = [ "a", "b", "c", "d", "e" ]
  a[0, 1]    #=> ["a"]
  a[-1, 1]   #=> ["e"]
  a[0, 10]   #=> ["a", "b", "c", "d", "e"]
  a[0, 0]    #=> []
  a[0, -1]   #=> nil
  a[10, 1]   #=> nil

@param start 生成したい部分配列の先頭のインデックスを整数で指定します。
start の値が負の時には末尾からのインデックスと見倣します。末尾の要素が -1 番目になります。

@param length 生成したい部分配列の長さを整数で指定します。
length が start 番目からの配列の長さより長い時には、越えた分の長さは無視されます。


--- []=(nth, val)
#@todo

nth 番目の要素を val に設定します。nth が配列の範囲を越える時には配列の長さを自動的に拡張し、
拡張した領域を nil で初期化します。

  a = [0, 1, 2, 3, 4, 5]
  a[0] = "a"
  p a  #=> ["a", 1, 2, 3, 4, 5]
  a[10] = "x"
  p a  ["a", 1, 2, 3, 4, 5, nil, nil, nil, nil, "x"]

@param nth インデックスを整数で指定します。

@param val 設定したい要素の値を指定します。

--- []=(range, val)
#@todo

[[c:Range]] オブジェクト range の範囲にある要素を配列 val の内容に置換します。
range の first が自身の末尾を越える時には配列の長さを自動的に拡張し、拡張した領域を nil で初期化します。

    ary = [0, 1, 2, 3, 4, 5]
    ary[0..2] = ["a", "b"]
    p ary  # => ["a", "b", 3, 4, 5]

    ary = [0, 1, 2]
    ary[5..6] = "x"
    p ary  # => [0, 1, 2, nil, nil, "x"]
    
    ary = [0, 1, 2, 3, 4, 5]
    ary[1..3] = "x"
    p ary  # => [0, "x", 4, 5]

@param range 設定したい配列の範囲を [[c:Range]] オブジェクトで指定します。
range の first や end の値が負の時には末尾からのインデックスと見倣します。末尾の要素が -1 番目になります。
range の first が end より後にある場合には first の直前に val を挿入します。
    ary = [0, 1, 2, 3, 4, 5]
    ary[2..0] = ["a", "b", "c"]
    p ary   # => [0, 1, "a", "b", "c", 2, 3, 4, 5]

@param val range の範囲に設定したい要素を配列で指定します。
val が配列でないときには val.to_ary もしくは [val] の内容で置換します。
val の要素の数の方が range の長さより大きい時には、後ろの要素がずれます。
val が nil か 空の配列 [] なら range の範囲にある要素が削除されます。
    ary = [0, 1, 2, 3, 4, 5]
    ary[2..4] = nil
    p ary   # => [0, 1, 5]

--- []=(start, length, val)
#@todo

インデックス start から length 個の要素を配列 val の内容で置き換えます。
start が自身の末尾を越える時には配列の長さを自動的に拡張し、拡張した領域を nil で初期化します。

  ary = [0, 1, 2, 3]
  ary[1, 2] = ["a", "b", "c", "d"]
  p ary                        #=> [0, "a", "b", "c", "d", 3]
  
  ary = [0, 1, 2]
  ary[5, 1] = "Z" 
  p ary                        #=> [0, 1, 2, nil, nil, "Z"]
    
  ary = [0, 1, 2, 3]
  ary[0, 10] = ["a"]
  p ary                        #=> ["a"]

@param start 置き換えたい範囲の先頭のインデックスを指定します。
start の値が負の時には末尾からのインデックスと見倣します。末尾の要素が -1 番目になります。

@param length 置き換えたい要素の個数を指定します。
length の値が 0 のときは start の直前に val を挿入します。
    ary = [0, 1, 2, 3]
    ary[1, 0] = ["inserted"]
    p ary                        # => [0, "inserted", 1, 2, 3]

@param val 設定したい要素を配列で指定します。
val が配列でないときには val.to_ary もしくは [val] の内容で置換します。
val の長さが length と等しくない場合には、val の長さに合わせて要素が削除されたりずれたりします。
val が nil か 空の配列 [] なら start から end までの要素が削除されます。
    a = [0, 1, 2, 3, 4, 5]
    a[2, 3] = nil
    p a   # => [0, 1, 5]

--- +(other)    -> Array
#@todo

self と other の内容を繋げた新しい配列を返します。


    a = [1, 2]
    b = [8, 9]
    p a + b     #=> [1, 2, 8, 9]
    p a         #=> [1, 2]        (変化なし)
    p b         #=> [8, 9]        (こちらも変化なし)

@param other 自身と繋げたい配列を指定します。other が配列でなければ other.to_ary の戻り値を用います。

@raise TypeError other が配列でく other.to_ary の戻り値がまた配列でなかった場合に発生します。

--- *(times)    -> Array
#@todo

配列の内容を times 回 繰り返した新しい配列を作成し返します。
値はコピーされないことに注意してください[[trap:Array]]。

    p [1, 2, 3] * 3  #=> [1, 2, 3, 1, 2, 3, 1, 2, 3]

@param times 繰り返したい回数を整数で指定します。

--- *(sep)    -> String
#@todo

sep を間にはさんで連結した文字列を返します。[[m:Array#join]](sep) と同じ動作をします。

    p [1,2,3] * ","
    # => "1,2,3"

@param sep 文字列を指定します。

--- -(other)    -> Array
#@todo

集合の差演算。self から other の要素を
取り除いた内容の新しい配列を返します。

#@since 1.8.0
要素の同一性は [[m:Object#eql?]] により評価されます。
self 中で重複していて、other中に存在していなかった要素は、その重複が保持されます。

    [1, 2, 1, 3, 1, 4, 1, 5] - [2, 3, 4, 5]       # => [1, 1, 1, 1]

    [1, 2, 1, 3, 1, 4, 1, 5] - [1, 2, 3, 4, 5]    # => []
#@else
重複する要素は取り除かれます。
要素の同一性は [[m:Object#===]] が使われます。
#@end

@param other 自身から取り除きたい要素の配列を指定します。
other が配列でなければ to_ary メソッドによる暗黙の型変換を試みます。

--- &(other)    -> Array
#@todo

集合の積演算です。両方の配列に含まれる要素からなる新しい配列を返
します。重複する要素は取り除かれます。

要素の重複判定は、[[m:Object#eql?]] により行われます。
処理の高速化のために内部で [[c:Hash]] を使用しているためです。

  [1, 1, 2, 3] & [1, 3, 4] #=> [1, 3]

@param other 配列を指定します。other が配列でなければ to_ary メソッドによる暗黙の型変換を試みます。

--- |(other)    -> Array
#@todo

集合の和演算です。両方の配列にいずれかに含まれる要素を全て含む新し
い配列を返します。重複する要素は取り除かれます。

要素の重複判定は、[[m:Object#eql?]] により行われます。

  [1, 1, 4, 2, 3] | [4, 5, 5]  #=> [1, 4, 2, 3, 5]

@param other 配列を指定します。other が配列でなければ to_ary メソッドによる暗黙の型変換を試みます。

--- <<(obj)    -> self
#@todo

obj を配列の末尾に追加します。[[m:Array#push]] と同じです。

  ary = [1]
  ary << 2
  p ary      # [1, 2]

またこのメソッドは self を返すので、以下のように連続して
書くことができます。

  ary = [1]
  ary << 2 << 3 << 4
  p ary   #=> [1, 2, 3, 4]

@param obj 自身に加えたいオブジェクトを指定します。

--- <=>(other)    -> -1 | 0 | 1
#@todo

self と other の各要素をそれぞれ順に <=> で比較していき、結果が 0 でなかった場合に
その値を返します。各要素が等しく、配列の長さも等しい場合には 0 を返します。
各要素が等しいまま一方だけ配列の末尾に達した時、自身の方が短ければ -1 をそうでなければ 1 
を返します。

  [ 1, 2, 3 ] <=> [ 1, 3, 2 ]       #=> -1
  [ 1, 2, 3 ] <=> [ 1, 2 ]          #=> 1

@param other 自身と比較したい配列を指定します。

--- ==(other)    -> boolean
#@todo

self と other の各要素をそれぞれ順に == で比較し
て、全要素が等しければ true を返します。そうでない場合には false を返します。

@param other 自身と比較したい配列を指定します。

--- assoc(key)    -> Array
#@todo

配列の配列を検索して、その 0 番目の要素が key に等しい最初の
要素を返します。比較は == 演算子を使って行われます。
該当する要素がなければ nil を返します。

    ary = [[1,15], [2,25], [3,35]]
    p ary.assoc(2)           # => [2, 25]
    p ary.assoc(100)         # => nil
    p ary.assoc(15)          # => nil

@param key 自身の要素である配列の、最初の要素と同じ型のオブジェクトを指定します。

[[m:Array#rassoc]] も参照してください。

--- at(pos)    -> object
#@todo

配列の pos の位置にある要素を返します。
self[pos] と同じです。

@param pos インデックスを整数で指定します。

--- clear    -> self
#@todo

配列の要素をすべて削除して空にします。

    ary = [1, 2]
    ary.clear
    p ary     #=> []

--- clone    -> Array
--- dup      -> Array
#@todo

レシーバと同じ内容を持つ新しい配列を返します。

clone は frozen tainted singleton-class の情報も含めてコピーしますが、
dup は内容だけをコピーします。
またどちらのメソッドも要素それ自体のコピーはしません。
つまり「浅い(shallow)」コピーを行います。

    ary = ['string']
    p ary             #=> ["string"]
    copy = ary.dup
    p copy            #=> ["string"]

    ary[0][0...3] = ''
    p ary             #=> ["ing"]
    p copy            #=> ["ing"]

--- collect! {|item| ..}    -> self
--- map! {|item| ..}        -> self
#@todo

各要素を順番にブロックに渡して評価し、その結果で要素を
置き換えます。

    ary = [1, 2, 3]
    ary.map! {|i| i * 3 }
    p ary   #=> [3, 6, 9]

@see [[m:Enumerable#collect]]

--- compact     -> Array
--- compact!    -> nil | self
#@todo

compact は self から nil である要素を取り除いた
新しい配列を返します。compact! は変更を破壊的に行い、変更が
行われた場合は self を、そうでなければ nil を返します。

    ary = [1, nil, 2, nil, 3, nil]
    p ary.compact   #=> [1, 2, 3]
    p ary           #=> [1, nil, 2, nil, 3, nil]
    ary.compact!
    p ary           #=> [1, 2, 3]
    p ary.compact!  #=> nil

--- concat(other)    -> self
#@todo

配列 other を self の末尾に(破壊的に)連結します。

    array = [1, 2]
    a     = [3, 4]
    array.concat a
    p array          # => [1, 2, 3, 4]
    p a              # => [3, 4]       # こちらは変わらない

@param other 自身と連結したい配列を指定します。

--- delete(val)           -> nil | object
--- delete(val) { ... }   -> object
#@todo

val と == で等しい要素をすべて取り除きます。
val と等しい要素が見つかった場合は、val を返します。
そうでない場合には nil を返します。

ブロックが指定された場合、val と等しい要素が見つからなかったときにブロックを
評価してその結果を返します。

    array = [1, 2, 3, 2, 1]
    p array.delete(2)       #=> 2
    p array                 #=> [1, 3, 1]

    # ブロックなしの引数に nil を渡すとその戻り値から削除が
    # 行われたかどうかの判定をすることはできない
    ary = [nil,nil,nil]
    p ary.delete(nil)       #=> nil
    p ary                   #=> []
    p ary.delete(nil)       #=> nil

@param val 自身から削除したい値を指定します。

--- delete_at(pos)    -> nil | object
#@todo

pos で指定された位置にある要素を取り除きそれを返します。
pos が範囲外であったら nil を返します。

[[m:Array#at]] と同様に負のインデックスで末尾から位置を指定するこ
とができます。

    array = [0, 1, 2, 3, 4]
    array.delete_at 2
    p array             #=> [0, 1, 3, 4]

@param pos 削除したい要素のインデックスを整数で指定します。

--- delete_if {|x| ... }    -> self
--- reject! {|x| ... }      -> nil | self
#@todo

要素を順番にブロックに渡して評価し、その結果が真になった要素をすべて削除します。
delete_if は常に self を返しますが、reject! は要素が 1 つ以上削除されれば self を、
1 つも削除されなければ nil を返します。

  a = [0, 1, 2, 3, 4, 5]
  a.delete_if{|x| x % 2 == 0}
  p a #=> [1, 3, 5]

--- each {|item| .... }    -> self
#@todo

各要素に対してブロックを評価します。
    
    [1, 2, 3].each do |i|
      puts i
    end
    #=> 1
        2
        3

#@#
#@#each により(また、標準のメソッドで)複数の値を取得しながら繰り返す
#@#ことはできません。現在のところ以下のようなメソッドを定義する必要が
#@#あります。
#@#
#@#    class Array
#@#      def every(&block)
#@#        arity = block.arity
#@#        return self.each(&block) if arity <= 0
#@#
#@#        i = 0
#@#        while i < self.size
#@#          yield(*self[i, arity])
#@#          i += arity
#@#        end
#@#        self
#@#      end
#@#    end
#@#
#@#    ary = [1,2,3]
#@#    ary.every {|i| p i}
#@#    # => 1
#@#    #    2
#@#    #    3
#@#    ary.every {|i,j| p [i,j]}
#@#    # => [1, 2]
#@#    #    [3, nil]
#@#    ary.every {|i,j,k| p [i,j,k]}
#@#    # => [1, 2, 3]
#@#    ary.every {|*i| p *i}
#@#    # => 1
#@#    #    2
#@#    #    3

--- each_index {|index| .... }    -> self
#@todo

各要素のインデックスに対してブロックを評価します。
以下と同じです。

    (0 ... ary.size).each {|index| ....  }

--- empty?    -> boolean
#@todo

配列の要素数が 0 の時真を返します。

--- eql?(other)    -> boolean
#@todo

self と other の各要素をそれぞれ順に
[[m:Object#eql?]] で比較して、全要素が等しければ真を返
します。

@param other 自身と比較したい配列を指定します。

--- fetch(nth)               -> object    
--- fetch(nth, ifnone)       -> object
--- fetch(nth) {|nth| ... }  -> object
#@todo

nth 番目の要素を返します。

[[m:Array#[] ]](nth) とは nth 番目の要素が存在しない場合の振舞いが異
なります。最初の形式では、例外 [[c:IndexError]] が発生します。
二番目の形式では、引数 ifnone を返します。
三番目の形式では、ブロックを評価した結果を返します。

@param nth 取得したい要素のインデックスを整数で指定します。

@param ifnone 要素が存在しなかった場合に返すべき値を指定します。

--- fill(val)            -> self
#@since 1.8.0
--- fill {|index| ... }  -> self
#@end
#@todo
すべての要素に val をセットします。

このメソッドが val のコピーでなく val 自身をセットする
ことに注意してください([[trap:Array]])。

val の代わりにブロックを指定するとブロックの評価結果を値とします。

  a = [0, 1, 2, 3, 4]
  a.fill(10)
  p a #=> [10, 10, 10, 10, 10]
  
  a = [0, 1, 2, 3, 4]
  a.fill("a")
  p a #=> ["a", "a", "a", "a", "a"]
  a[0].capitalize!
  p a #=> ["A", "A", "A", "A", "A"]

@param val 自身にセットしたいオブジェクトを指定します。

--- fill(val, start, length = nil)             -> self
--- fill(val, range)                     -> self
#@since 1.8.0
--- fill(start, length = nil) {|index| ... }    -> self
--- fill(range) {|index| ... }            -> self
#@end
#@todo

配列の指定された範囲すべてに val をセットします。

範囲の始点が自身の末尾を越える時には配列の長さを自動的に拡張し、拡張した領域を nil で初期化します。
範囲の終点が自身の末尾を越える時は長さを自動的に拡張し、拡張した部分を val で初期化します。
このメソッドが val のコピーでなく val 自身をセットすることに注意してください([[trap:Array]])。
  a = [0, 1, 2]
  a.fill("x", 5..10)
  p a #=> [0, 1, 2, nil, nil, "x", "x", "x", "x", "x", "x"]

#@since 1.8.0
val の代わりにブロックを指定するとブロックの評価結果を値とし
ます。ブロックは要素毎に実行されるので、セットする値のそれぞれをあ
るオブジェクトの複製にすることができます。
ブロックのパラメータには start からのインデックスが渡されます。

    ary = []
    p ary.fill(1..2) {|i| i}         # => [nil, 1, 2]
    p ary.fill(0,3) {|i| i}          # => [0, 1, 2]
    p ary.fill { "foo" }             # => ["foo", "foo", "foo"]
    p ary.collect {|v| v.object_id } # => [537770124, 537770112, 537770100]
#@end

@param val 自身に設定したいオブジェクトを指定します。

@param start val を設定する範囲の始点のインデックスを整数で指定します。start の値が負の時には末尾からのインデックスと見倣します。末尾の要素が -1 番目になります。

@param length val を設定する要素の個数を指定します。nil が指定された時は配列の終りまでの長さを意味します。

@param range val を設定する範囲を [[c:Range]] オブジェクトで指定します。

#@##@since 1.8.0
#@#version 1.8.0 には、ブロックに渡されるパラ
#@#メータが仕様と異なる不具合がありました。
#@#
#@#    ary = []
#@#    p ary.fill(1..2) {|i| i}         # => [2, 4, 6]  <- bug
#@#    p ary.fill(0,3) {|i| i}          # => [1, 3, 5]  <- bug
#@#    p ary.fill { "foo" }             # => ["foo", "foo", "foo"]
#@#    p ary.collect {|v| v.object_id } # => [537770124, 537770112, 537770100]
#@##@end

--- first       -> nil | object
#@todo
配列の先頭の要素を返します。要素がなければ nil を返します。

    p [0, 1, 2].first   #=> 0
    p [].first          #=> nil

[[m:Array#last]] も参照してください。

#@since 1.8.0
--- first(n)    -> Array
#@todo

先頭の n 要素を配列で返します。n は 0 以上でなければなりません。

    ary =  [0, 1, 2]
    p ary.first(0)
    p ary.first(1)
    p ary.first(2)
    p ary.first(3)
    p ary.first(4)
    # => []
         [0]
         [0, 1]
         [0, 1, 2]
         [0, 1, 2]

@param n 取得したい要素の個数を整数で指定します。

#@end

[[m:Array#last]] も参照してください。

--- flatten     -> Array
--- flatten!    -> nil | self
#@todo

ネストした配列を平滑化してそれを返します。flatten! は
配列それ自体を破壊的に平滑化し、配列がネストしていないとき
には nil を返します。

    p [1, [2, 3, [4], 5]].flatten   #=> [1, 2, 3, 4, 5]

    array = [[[1, [2, 3]]]]
    array.flatten!
    p array                         #=> [1, 2, 3]

--- include?(val)    -> boolean
#@todo

配列が val と == において等しい要素を持つ時に真を返します。

@param val オブジェクトを指定します。

--- index(val)           -> nil | Integer
#@since 1.9.0
--- index {|item| ...}   -> nil | Integer
#@end
#@todo
最初の形式では、val と == で等しい最初の要素の位置を返
します。
等しい要素がひとつもなかった時には nil を返します。

#@since 1.9.0
二番目の形式では、ブロックが真を返した最初の要素の位置を返します。
ブロック引数には、要素が順に渡されます。
#@end

    p [1, 0, 0, 1, 0].index(1)   #=> 0
    p [1, 0, 0, 0, 0].index(1)   #=> 0
    p [0, 0, 0, 0, 0].index(1)   #=> nil
#@since 1.9.0
    p [0, 1, 0, 1, 0].index {|v| v > 0}   #=> 1
#@end

@param val インデックスを知りたいオブジェクトを指定します。

[[m:Array#rindex]] も参照してください。

--- indexes(*index)     
--- indices(*index)     
#@todo

#@since 1.8.0
このメソッド obsolete です。
代わりに [[m:Array#values_at]] を使用します。
使用すると警告メッセージが表示されます。
#@end

各引数の値をインデックスとする要素の配列を返します。範囲外の
インデックス指定に対しては nil が対応します。

    ary = %w( a b c d e )
    p ary.indexes( 0, 2, 4 )          #=> ["a", "c", "e"]
    p ary.indexes( 3, 4, 5, 6, 35 )   #=> ["d", "e", nil, nil]
    p ary.indexes( 0, -1, -2 )        #=> ["a", "e", "d"]
    p ary.indexes( -4, -5, -6, -35 )  #=> ["b", "a", nil, nil]


#@since 1.8.0
--- insert(nth, *val)    -> self
#@todo

インデックス nth の要素の直前に第 2 引数以降の値を挿入します。
引数 val を一つも指定しなければ何もしません。

    ary = [1, 2, 3]
    ary.insert(2, "a", "b")
    p ary                  # => [1, 2, "a", "b", 3]

@param nth インデックスを整数で指定します。

@param val オブジェクトを指定します。

#@end

--- join(sep = $,)    -> String
#@todo

配列の要素を文字列 sep を間に挟んで連結した文字列を返します。

文字列でない要素に対しては to_s した結果を連結します。
要素がまた配列であれば再帰的に (同じ sep を利用して)
join した文字列を連結します。
ただし、配列要素が自身を含むような無限にネストした配列に対しては、以下
のような結果になります。

    ary = [1,2,3]
    ary.push ary
    p ary           # => [1, 2, 3, [...]]
    p ary.join      # => "123123[...]"

@param sep 間に挟む文字列を指定します。nil のときは空文字列を使います。

@see [[m:$,]]

--- last    -> nil | object
#@todo

配列の末尾の要素を返します。配列が空のときは nil を返します。

    p [0, 1, 2].last   #=> 2
    p [].last          #=> nil

[[m:Array#first]] も参照してください。

#@since 1.8.0
--- last(n)    -> Array
#@todo

末尾の n 要素を配列で返します。n は 0 以上でなければなりません。

    ary =  [0, 1, 2]
    p ary.last(0)
    p ary.last(1)
    p ary.last(2)
    p ary.last(3)
    p ary.last(4)
    # => []
         [2]
         [1, 2]
         [0, 1, 2]
         [0, 1, 2]

@param n 取得したい要素の個数を整数で指定します。

#@end

[[m:Array#first]] も参照してください。

--- length    -> Integer
--- size      -> Integer
#@todo

配列の長さを返します。配列が空のときは 0 を返します。

--- nitems    -> Integer
#@todo

nil でない要素の数を返します。

--- pack(template)    -> String
#@todo

配列の内容を template で指定された文字列にしたがって、
バイナリとしてパックした文字列を返します。

テンプレートは
型指定文字列とその長さ(省略時は1)を並べたものです。長さと
して * が指定された時は「残りのデータ全て」の長さを
表します。型指定文字は[[unknown:packテンプレート文字列]]の通りです。

@pack template テンプレートを文字列で指定します。

--- pop    -> nil | object
#@todo

末尾の要素を取り除いてそれを返します。自身が空配列の時は
nil を返します。

      array = [1, [2, 3], 4]
      p array.pop      # => 4
      p array.pop      # => [2, 3]
      p array          # => [1]

      p array.pop      # => 1
      p array.pop      # => nil
      p array          # => []

[[m:Array#push]], [[m:Array#shift]], [[m:Array#unshift]] も参照し
てください。

#@since 1.8.0
--- push(*obj)        -> self
#@else
--- push(obj, *rest)  -> self
#@end
#@todo

obj を順番に配列の末尾に追加します。
#@since 1.8.0
引数を指定しなければ何もしません。
#@end

      array = [1, 2, 3]
      array.push 4
      array.push [5, 6]
      array.push 7, 8
      p array          # => [1, 2, 3, 4, [5, 6], 7, 8]

@param obj 自身に追加したいオブジェクトを指定します。

[[m:Array#pop]], [[m:Array#shift]], [[m:Array#unshift]] も参照して
ください。

--- rassoc(obj)    -> nil | Array
#@todo

self が配列の配列であると仮定して、要素の配列でインデックス
1 の要素が obj に等しいものを検索し見つかった最初の要素を返
します。該当する要素がなければ nil を返します。

比較は == 演算子を使って行われます。

    a = [[15,1], [25,2], [35,3]]
    p a.rassoc(2)    # => [25, 2]

@param obj オブジェクトを指定します。

[[m:Array#assoc]] も参照してください。

--- replace(another)    -> self
#@todo

配列の内容を配列 another の内容で置き換えます。

    a = [1, 2, 3]
    a.replace [4, 5, 6]
    p a                 #=> [4, 5, 6]

@param another 配列を指定します。

--- reverse     -> Array
#@since 1.8.0
--- reverse!    -> self
#@else
--- reverse!    -> nil | self
#@end
#@todo

reverse は全ての要素を逆順に並べた新しい配列を返します。
reverse! は配列の要素を逆順に(破壊的に)並べ替えます。
reverse は、常に新しい配列を返しますが、
#@since 1.8.0
reverse!  は、常に self を返します。
#@else
reverse!  は、1 要素の配列に対して nil を返しそれ以外では self を返
します
#@end

--- reverse_each {|item| ... }    -> self
#@todo

各要素に対して逆順にブロックを評価します。

--- rindex(val)           -> Integer
#@since 1.9.0
--- rindex {|item| ... }  -> Integer
#@end
#@todo

val と == で等しい最後の要素の位置を返します。
等しい要素がひとつもなかった時には nil を返します。

#@since 1.9.0
ブロックが与えられた時には、ブロックが真を返した最後の要素の位置を返し
ます。ブロック引数には、要素が順に渡されます。
#@end

    p [1, 0, 0, 1, 0].rindex(1)   #=> 3
    p [1, 0, 0, 0, 0].rindex(1)   #=> 0
    p [0, 0, 0, 0, 0].rindex(1)   #=> nil
#@since 1.9.0
    p [0, 1, 0, 1, 0].rindex {|v| v > 0}   #=> 3
#@end

@param val オブジェクトを指定します。

[[m:Array#index]] も参照してください。

--- shift    -> nil | object
#@todo

配列の先頭の要素を取り除いてそれを返します。残りの要素はひとつずつ
前に詰められます。自身が空配列の時は nil を返します。

  a = [0, 1, 2, 3, 4]
  p a.shift #=> 0
  p a       #=> [1, 2, 3, 4]

[[m:Array#push]], [[m:Array#pop]], [[m:Array#unshift]] も参照して
ください。

--- slice(nth)       -> nil | object
--- slice(pos, len)  -> nil | Array
--- slice(range)     -> nil | Array
#@todo

[[m:Array#[] ]] と同じです。

--- slice!(nth)       -> nil | object
--- slice!(pos, len)  -> nil | Array
--- slice!(range)     -> nil | Array
#@todo

指定した要素を取り除いて返します。取り除く要素がなければ nil
を返します。

--- sort                -> Array
--- sort!               -> self
--- sort {|a, b| ... }  -> Array
--- sort! {|a, b| ... } -> self
#@todo

配列の内容をソートします。ブロックとともに呼び出された時には
ブロックに 2 引数を与えて評価し、その結果で比較します。
ブロックがない時には <=> 演算子を使って比較します。
sort はソートされた新しい配列を返し、sort! は
self を破壊的に変更します。

#@since 1.8.0
sort! は、常に self を返します。
#@else
sort! は、要素の数が 2 より小さい場合には nil を返します。
#@end

--- to_a    -> self
--- to_ary  -> self
#@todo

self をそのまま返します。

--- to_s    -> String
#@todo

[[m:Array#join]]([[m:$,]]) と同じです。

#@since 1.9.0
--- to_splat
#@end
#@todo

#@since 1.8.0
--- transpose    -> Array
#@todo

self を行列と見立てて、行列の転置(行と列の入れ換え)を行いま
す。転置した配列を生成して返します。空の配列に対しては空の配列を生
成して返します。

それ以外の一次元の配列に対しては、例外
[[c:TypeError]] が発生します。各要素のサイズが不揃いな配列に対して
は、例外 [[c:IndexError]] が発生します。

    p [[1,2],
       [3,4],
       [5,6]].transpose
    # => [[1, 3, 5], [2, 4, 6]]

    p [].transpose
    # => []

    p [1,2,3].transpose

    # => -:1:in `transpose': cannot convert Fixnum into Array (TypeError)
            from -:1

    p [[1,2],
       [3,4,5],
       [6,7]].transpose
    # => -:3:in `transpose': element size differ (3 should be 2) (IndexError)
#@end

--- uniq     -> Array
--- uniq!    -> nil | self
#@todo

uniq は配列から重複した要素を取り除いた新しい配列を返します。
取り除かれた要素の部分は前に詰められます。uniq! は削除を破壊
的に行い、削除が行われた場合は self を、そうでなければ
nil を返します。

要素の重複判定は、[[m:Object#eql?]] により行われます。

    p [1, 1, 1].uniq         #=> [1]
    p [1, 4, 1].uniq         #=> [1, 4]
    p [1, 3, 2, 2, 3].uniq   #=> [1, 3, 2]


#@since 1.8.0
--- unshift(*obj)        -> self
#@else
--- unshift(obj, *rest)  -> self
#@end
#@todo

obj を順番に配列の先頭に挿入します。
#@since 1.8.0
引数を指定しなければ何もしません。
#@end

    arr = [1,2,3]
    arr.unshift 0
    p arr             #=> [0, 1, 2, 3]
    arr.unshift [0]
    p arr             #=> [[0], 0, 1, 2, 3]
    arr.unshift 1, 2
    p arr             #=> [1, 2, [0], 0, 1, 2, 3]

@param obj 自身に追加したいオブジェクトを指定します。

[[m:Array#push]], [[m:Array#pop]], [[m:Array#shift]] も参照してく
ださい。

#@since 1.8.0
--- values_at(*index)    -> nil | Array
#@todo

引数で指定されたインデックスに対応する要素を配列で返します。インデッ
クスに対応する値がなければ nil が要素になります。

    ary = %w( a b c d e )
    p ary.values_at( 0, 2, 4 )          #=> ["a", "c", "e"]
    p ary.values_at( 3, 4, 5, 6, 35 )   #=> ["d", "e", nil, nil, nil]
    p ary.values_at( 0, -1, -2 )        #=> ["a", "e", "d"]
    p ary.values_at( -4, -5, -6, -35 )  #=> ["b", "a", nil, nil]

@param index インデックスを整数で指定します。

#@# ([[m:Array#indexes]], [[m:Array#indices]] と同じです)

#@end
