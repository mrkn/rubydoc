= class Array < Object
include Enumerable

配列クラスです。
配列は任意の Ruby オブジェクトを要素として持つことができます。

一般的には配列は配列式を使って

  [1, 2, 3]

のように生成します。

== Class Methods

#@since 1.9.1
--- try_convert(obj) -> Array | nil
to_ary メソッドを用いて obj を配列に変換しようとします。

何らかの理由で変換できないときには nil を返します。
このメソッドは引数が配列であるかどうかを調べるために使えます。

例:

   Array.try_convert([1])   # => [1]
   Array.try_convert("1")   # => nil

   if tmp = Array.try_convert(arg)
     # the argument is an array
   elsif tmp = String.try_convert(arg)
     # the argument is a string
   end

#@end

--- [](*item)    -> Array

引数 item を要素として持つ配列を生成して返します。

[[c:Array]] のサブクラスを作成したしたときに、そのサブクラスのインスタンスを作成
しやすくするために用意されている。

@param item 配列の要素を指定します。

例:

  Array[1, 2, 3] #=> [1, 2, 3]
  
  class SubArray < Array
    # ...
  end
  p SubArray[1, 2, 3] # => [1, 2, 3]

--- new(size = 0, val = nil)    -> Array

長さ size の配列を生成し、各要素を val で初期化して返します。

要素毎に val が複製されるわけではないことに注意してください。
全要素が同じオブジェクト val を参照します[[trap:Array]]。
後述の例では、配列の各要素は全て同一の文字列を指します。

@param size 配列の長さを数値で指定します。

@param val 配列の要素の値を指定します。

例:

    ary = Array.new(3, "foo")
    p ary                     #=> ["foo", "foo", "foo"]
    ary[0].capitalize!
    p ary                     #=> ["Foo", "Foo", "Foo"]  (各要素は同一のオブジェクトである)

#@since 1.8.0
--- new(ary)    -> Array

指定された配列 ary を複製して返します。
[[m:Array#dup]] 同様 要素を複製しない浅い複製です。

@param ary 複製したい配列を指定します。

例:

    p Array.new([1,2,3]) # => [1,2,3]

    a = ["a", "b", "c"]
    b = Array.new(a)
    a.each{|s| s.capitalize! }
    p a                        #=> ["A", "B", "C"]
    p b                        #=> ["A", "B", "C"]   (b は a と要素を共有する)

#@end

--- new(size) {|index| ... }    -> Array

長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、
各要素の値をブロックの評価結果に設定します。

ブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。

@param size 配列の長さを数値で指定します。

例:
    ary = Array.new(3){|index| "hoge#{index}"}
    p ary                      #=> ["hoge0", "hoge1", "hoge2"]

例:

    ary = Array.new(3){ "foo" }
    p ary                      #=> ["foo", "foo", "foo"]
    ary[0].capitalize!
    p ary                      #=> ["Foo", "foo", "foo"]  (各要素は違うオブジェクトである)

== Instance Methods

--- [](nth)    -> object | nil

nth 番目の要素を返します。nth 番目の要素が存在しない時には nil を返します。

@param nth インデックスを整数で指定します。
       先頭の要素が 0 番目になります。nth の値が負の時には末尾からのインデックスと見倣します。末尾
       の要素が -1 番目になります。

例:

  a = [ "a", "b", "c", "d", "e" ]
  a[0]  #=> "a"
  a[1]  #=> "b"
  a[-1] #=> "e"
  a[-2] #=> "d"
  a[10] #=> nil

--- [](range)    -> Array | nil

[[c:Range]] オブジェクト range の範囲にある要素からなる部分配列を返します。
range の first の値が配列の範囲に収まらない場合 nil を返します。
range の first が end より後にある場合には空の配列を返します。

@param range 生成したい部分配列の範囲を [[c:Range]] オブジェクトで指定します。
             range の first や end の値が負の時には末尾からのインデックスと見倣します。末尾
             の要素が -1 番目になります。
             end の値が配列の範囲を越える時には、越えた分は無視されます。

例:

  a = [ "a", "b", "c", "d", "e" ]
  a[0..1]   #=> ["a", "b"]
  a[0...1]  #=> ["a"]
  a[0..-1]  #=> ["a", "b", "c", "d", "e"]
  a[-2..-1] #=> ["d", "e"]
  a[-2..4]  #=> ["d", "e"]  (start は末尾から -2 番目、end は先頭から (4+1) 番目となる。)
  a[0..10]  #=> ["a", "b", "c", "d", "e"]
  a[10..11] #=> nil
  a[2..1]   #=> []
  a[-1..-2] #=> []
  
  # 特殊なケース。first が自身の長さと同じ場合には以下のようになります。
  a[5]                   #=> nil  
  a[5, 1]                #=> []
  a[5..10]               #=> []

--- [](start, length)    ->  Array | nil

start 番目から length 個の要素を含む部分配列を返します。
length が負の時、start が自身の範囲を越えた時には nil を返します。

@param start 生成したい部分配列の先頭のインデックスを整数で指定します。
             start の値が負の時には末尾からのインデックスと見倣します。末尾の要素が -1 番目になります。

@param length 生成したい部分配列の長さを整数で指定します。
              length が start 番目からの配列の長さより長い時には、越えた分の長さは無視されます。

例:

  a = [ "a", "b", "c", "d", "e" ]
  a[0, 1]    #=> ["a"]
  a[-1, 1]   #=> ["e"]
  a[0, 10]   #=> ["a", "b", "c", "d", "e"]
  a[0, 0]    #=> []
  a[0, -1]   #=> nil
  a[10, 1]   #=> nil
 
  # 特殊なケース。start が自身の長さと同じ場合には以下のようになります。
  a[5]                   #=> nil  
  a[5, 1]                #=> []
  a[5..10]               #=> []

--- []=(nth, val)

nth 番目の要素を val に設定します。nth が配列の範囲を越える時には配列の長さを自動的に拡張し、
拡張した領域を nil で初期化します。

@param nth インデックスを整数で指定します。

@param val 設定したい要素の値を指定します。

@raise IndexError 指定された nth が自身の始点よりも前を指している場合に発生します。

例:

  a = [0, 1, 2, 3, 4, 5]
  a[0] = "a"
  p a  #=> ["a", 1, 2, 3, 4, 5]
  a[10] = "x"
  p a  #=> ["a", 1, 2, 3, 4, 5, nil, nil, nil, nil, "x"]
 
  a = [0, 1, 2, 3, 4, 5]
  a[-100] = 1           #=> IndexError

--- []=(range, val)

[[c:Range]] オブジェクト range の範囲にある要素を配列 val の内容に置換します。
range の first が自身の末尾を越える時には配列の長さを自動的に拡張し、拡張した領域を nil で初期化します。

    ary = [0, 1, 2, 3, 4, 5]
    ary[0..2] = ["a", "b"]
    p ary  # => ["a", "b", 3, 4, 5]

    ary = [0, 1, 2]
    ary[5..6] = "x"
    p ary  # => [0, 1, 2, nil, nil, "x"]
    
    ary = [0, 1, 2, 3, 4, 5]
    ary[1..3] = "x"
    p ary  # => [0, "x", 4, 5]

@param range 設定したい配列の範囲を [[c:Range]] オブジェクトで指定します。
             range の first や end の値が負の時には末尾からのインデックスと見倣します。
             末尾の要素が -1 番目になります。
             range の first が end より後にある場合には first の直前に val を挿入します。
//emlist{
    ary = [0, 1, 2, 3, 4, 5]
    ary[2..0] = ["a", "b", "c"]
    p ary   # => [0, 1, "a", "b", "c", 2, 3, 4, 5]
//}

@param val range の範囲に設定したい要素を配列で指定します。
           val が配列でないときには val.to_ary もしくは [val] の内容で置換します。
           val の要素の数の方が range の長さより大きい時には、後ろの要素がずれます。
#@since 1.9.1
           val が空の配列 [] なら start から end までの要素が削除されます。
#@else
           val が nil か 空の配列 [] なら start から end までの要素が削除されます。
#@end
//emlist{
    ary = [0, 1, 2, 3, 4, 5]
    ary[2..4] = nil
    p ary   # => [0, 1, 5]
//}
@raise RangeError 指定された範囲の始点が自身の始点よりも前にある場合に発生します。

例:

  a = [0, 1, 2, 3, 4, 5]
  a[-10..10] = 1        #=> RangeError

--- []=(start, length, val)

インデックス start から length 個の要素を配列 val の内容で置き換えます。
start が自身の末尾を越える時には配列の長さを自動的に拡張し、拡張した領域を nil で初期化します。

  ary = [0, 1, 2, 3]
  ary[1, 2] = ["a", "b", "c", "d"]
  p ary                        #=> [0, "a", "b", "c", "d", 3]
  
  ary = [0, 1, 2]
  ary[5, 1] = "Z" 
  p ary                        #=> [0, 1, 2, nil, nil, "Z"]
    
  ary = [0, 1, 2, 3]
  ary[0, 10] = ["a"]
  p ary                        #=> ["a"]

@param start 置き換えたい範囲の先頭のインデックスを指定します。
             start の値が負の時には末尾からのインデックスと見倣します。末尾の要素が -1 番目になります。

@param length 置き換えたい要素の個数を指定します。
              length の値が 0 のときは start の直前に val を挿入します。
//emlist{
    ary = [0, 1, 2, 3]
    ary[1, 0] = ["inserted"]
    p ary                        # => [0, "inserted", 1, 2, 3]
//}

@param val 設定したい要素を配列で指定します。
           val が配列でないときには val.to_ary もしくは [val] の内容で置換します。
           val の長さが length と等しくない場合には、val の長さに合わせて要素が削除されたりずれたりします。
#@since 1.9.1
           val が空の配列 [] なら start から end までの要素が削除されます。
#@else
           val が nil か 空の配列 [] なら start から end までの要素が削除されます。
#@end
//emlist{
    a = [0, 1, 2, 3, 4, 5]
    a[2, 3] = nil
    p a   # => [0, 1, 5]
//}

@raise IndexError 指定された start が自身の始点よりも前を指している場合に発生します。


--- +(other)    -> Array

自身と other の内容を繋げた配列を生成して返します。

@param other 自身と繋げたい配列を指定します。other が配列でなければ other.to_ary の戻り値を用います。

@raise TypeError other が配列でなく、さらに other.to_ary の戻り値がまた配列でなかった場合に発生します。

    a = [1, 2]
    b = [8, 9]
    p a + b     #=> [1, 2, 8, 9]
    p a         #=> [1, 2]        (変化なし)
    p b         #=> [8, 9]        (こちらも変化なし)

--- *(times)    -> Array

配列の内容を times 回 繰り返した新しい配列を作成し返します。
値はコピーされないことに注意してください[[trap:Array]]。

@param times 繰り返したい回数を整数で指定します。

    p [1, 2, 3] * 3  #=> [1, 2, 3, 1, 2, 3, 1, 2, 3]

--- *(sep)    -> String

指定された sep を間にはさんで連結した文字列を生成して返します。[[m:Array#join]](sep) と同じ動作をします。

@param sep 文字列を指定します。

    p [1,2,3] * ","
    # => "1,2,3"

@see [[m:Array#join]]

--- -(other)    -> Array

自身から other の要素を取り除いた配列を生成して返します。

#@since 1.8.0
要素の同一性は [[m:Object#eql?]] により評価されます。
self 中で重複していて、other中に存在していなかった要素は、その重複が保持されます。
#@else
重複する要素は取り除かれます。
要素の同一性は [[m:Object#===]] が使われます。
#@end

@param other 自身から取り除きたい要素の配列を指定します。other が配列でなければ to_ary メソッドによる暗黙の型変換を試みます。

#@since 1.8.0
    [1, 2, 1, 3, 1, 4, 1, 5] - [2, 3, 4, 5]       # => [1, 1, 1, 1]

    [1, 2, 1, 3, 1, 4, 1, 5] - [1, 2, 3, 4, 5]    # => []
#@end

--- &(other)    -> Array

集合の積演算です。両方の配列に含まれる要素からなる新しい配列を返
します。重複する要素は取り除かれます。

要素の重複判定は、[[m:Object#eql?]] により行われます。
処理の高速化のために内部で [[c:Hash]] を使用しているためです。

@param other 配列を指定します。other が配列でなければ to_ary メソッドによる暗黙の型変換を試みます。

  [1, 1, 2, 3] & [1, 3, 4] #=> [1, 3]

--- |(other)    -> Array

集合の和演算です。両方の配列にいずれかに含まれる要素を全て含む新し
い配列を返します。重複する要素は取り除かれます。

要素の重複判定は、[[m:Object#eql?]] により行われます。

@param other 配列を指定します。other が配列でなければ to_ary メソッドによる暗黙の型変換を試みます。

  [1, 1, 4, 2, 3] | [4, 5, 5]  #=> [1, 4, 2, 3, 5]

--- <<(obj)    -> self

指定された obj を自身の末尾に破壊的に追加します。[[m:Array#push]] と同じです。

  ary = [1]
  ary << 2
  p ary      # [1, 2]

またこのメソッドは self を返すので、以下のように連続して
書くことができます。

  ary = [1]
  ary << 2 << 3 << 4
  p ary   #=> [1, 2, 3, 4]

@param obj 自身に加えたいオブジェクトを指定します。

--- <=>(other)    -> -1 | 0 | 1

自身と other の各要素をそれぞれ順に <=> で比較していき、結果が 0 でなかった場合に
その値を返します。各要素が等しく、配列の長さも等しい場合には 0 を返します。
各要素が等しいまま一方だけ配列の末尾に達した時、自身の方が短ければ -1 をそうでなければ 1 
を返します。

@param other 自身と比較したい配列を指定します。

  [ 1, 2, 3 ] <=> [ 1, 3, 2 ]       #=> -1
  [ 1, 2, 3 ] <=> [ 1, 2 ]          #=> 1

--- ==(other)    -> bool

自身と other の各要素をそれぞれ順に == で比較し
て、全要素が等しければ true を返します。そうでない場合には false を返します。

@param other 自身と比較したい配列を指定します。

--- assoc(key)    -> Array | nil

配列の配列を検索して、その 0 番目の要素が key に等しい最初の
要素を返します。比較は == 演算子を使って行われます。
該当する要素がなければ nil を返します。

@param key 自身の要素である配列の、最初の要素と同じ型のオブジェクトを指定します。

    ary = [[1,15], [2,25], [3,35]]
    p ary.assoc(2)           # => [2, 25]
    p ary.assoc(100)         # => nil
    p ary.assoc(15)          # => nil

@see [[m:Array#rassoc]]

--- at(pos)    -> object

配列の pos の位置にある要素を返します。
self[pos] と同じです。

@param pos インデックスを整数で指定します。

  a = [0, 1, 2, 3]
  p a.at(1)        #=> 1

--- clear    -> self

配列の要素をすべて削除して空にします。

    ary = [1, 2]
    ary.clear
    p ary     #=> []

--- clone    -> Array
--- dup      -> Array

レシーバと同じ内容を持つ新しい配列を返します。

clone は frozen tainted singleton-class の情報も含めてコピーしますが、
dup は内容だけをコピーします。
またどちらのメソッドも要素それ自体のコピーはしません。
つまり「浅い(shallow)」コピーを行います。

    ary = ['string']
    p ary             #=> ["string"]
    copy = ary.dup
    p copy            #=> ["string"]

    ary[0][0...3] = ''
    p ary             #=> ["ing"]
    p copy            #=> ["ing"]

--- collect! {|item| ..}    -> self
--- map! {|item| ..}        -> self
#@since 1.8.7
#@since 1.8.8
--- collect!                -> Enumerator
--- map!                    -> Enumerator
#@else
--- collect!                -> Enumerable::Enumerator
--- map!                    -> Enumerable::Enumerator
#@end
#@end

各要素を順番にブロックに渡して評価し、その結果で要素を
置き換えます。

#@since 1.8.7
ブロックが与えられなかった場合は、自身と map! から生成した
#@since 1.8.8
[[c:Enumerator]] オブジェクトを返します。
#@else
[[c:Enumerable::Enumerator]] オブジェクトを返します。
#@end
#@end

例:

    ary = [1, 2, 3]
    ary.map! {|i| i * 3 }
    p ary   #=> [3, 6, 9]

#@since 1.8.7
    ary = [1, 2, 3]
    e = ary.map!
    e.each{ 1 }
    p ary           #=> [1, 1, 1]
#@end

#@since 1.8.8
@see [[m:Enumerable#collect]], [[c:Enumerator]]
#@else
@see [[m:Enumerable#collect]], [[c:Enumerable::Enumerator]]
#@end

--- compact     -> Array
--- compact!    -> self | nil

compact は自身から nil を取り除いた配列を生成して返します。
compact! は自身から破壊的に nil を取り除き、変更が
行われた場合は self を、そうでなければ nil を返します。

    ary = [1, nil, 2, nil, 3, nil]
    p ary.compact   #=> [1, 2, 3]
    p ary           #=> [1, nil, 2, nil, 3, nil]
    ary.compact!
    p ary           #=> [1, 2, 3]
    p ary.compact!  #=> nil

--- concat(other)    -> self

配列 other を自身の末尾に破壊的に連結します。

@param other 自身と連結したい配列を指定します。

    array = [1, 2]
    a     = [3, 4]
    array.concat a
    p array          # => [1, 2, 3, 4]
    p a              # => [3, 4]       # こちらは変わらない


--- delete(val)           -> object | nil
--- delete(val) { ... }   -> object

指定された val と == で等しい要素を自身からすべて取り除きます。
val と等しい要素が見つかった場合は、val を返します。
そうでない場合には nil を返します。

ブロックが指定された場合、val と等しい要素が見つからなかったときにブロックを
評価してその結果を返します。

@param val 自身から削除したい値を指定します。

    array = [1, 2, 3, 2, 1]
    p array.delete(2)       #=> 2
    p array                 #=> [1, 3, 1]

    # ブロックなしの引数に nil を渡すとその戻り値から削除が
    # 行われたかどうかの判定をすることはできない
    ary = [nil,nil,nil]
    p ary.delete(nil)       #=> nil
    p ary                   #=> []
    p ary.delete(nil)       #=> nil

--- delete_at(pos)    -> object | nil

指定された位置 pos にある要素を取り除きそれを返します。
pos が範囲外であったら nil を返します。

[[m:Array#at]] と同様に負のインデックスで末尾から位置を指定するこ
とができます。

@param pos 削除したい要素のインデックスを整数で指定します。

    array = [0, 1, 2, 3, 4]
    array.delete_at 2
    p array             #=> [0, 1, 3, 4]

--- delete_if {|x| ... }    -> self
--- reject! {|x| ... }      -> self | nil
#@since 1.8.7
#@since 1.8.8
--- delete_if               -> Enumerator
--- reject!                 -> Enumerator
#@else
--- delete_if               -> Enumerable::Enumerator
--- reject!                 -> Enumerable::Enumerator
#@end
#@end

要素を順番にブロックに渡して評価し、その結果が真になった要素をすべて削除します。
delete_if は常に self を返しますが、reject! は要素が 1 つ以上削除されれば self を、
1 つも削除されなければ nil を返します。

#@since 1.8.7
ブロックが与えられなかった場合は、自身と reject! から生成した
#@since 1.8.8
[[c:Enumerator]] オブジェクトを返します。
#@else
[[c:Enumerable::Enumerator]] オブジェクトを返します。
#@end
返された Enumerator オブジェクトの each メソッドには、
もとの配列に対して副作用があることに注意してください。
#@end

例:
  a = [0, 1, 2, 3, 4, 5]
  a.delete_if{|x| x % 2 == 0}
  p a #=> [1, 3, 5]

#@since 1.8.7
  a = [0, 1, 2, 3, 4, 5]
  e = a.reject!
  e.each{|i| i % 2 == 0}
  p a                    #=> [1, 3, 5]  もとの配列から削除されていることに注意。
#@end

--- each {|item| .... }    -> self
#@since 1.8.7
#@since 1.8.8
--- each                   -> Enumerator
#@else
--- each                   -> Enumerable::Enumerator
#@end
#@end

各要素に対してブロックを評価します。

#@since 1.8.7
ブロックが与えられなかった場合は、自身と each から生成した
#@since 1.8.8
[[c:Enumerator]] オブジェクトを返します。
#@else
[[c:Enumerable::Enumerator]] オブジェクトを返します。
#@end
#@end

    [1, 2, 3].each do |i|
      puts i
    end
    #=> 1
        2
        3

#@#
#@#each により(また、標準のメソッドで)複数の値を取得しながら繰り返す
#@#ことはできません。現在のところ以下のようなメソッドを定義する必要が
#@#あります。
#@#
#@#    class Array
#@#      def every(&block)
#@#        arity = block.arity
#@#        return self.each(&block) if arity <= 0
#@#
#@#        i = 0
#@#        while i < self.size
#@#          yield(*self[i, arity])
#@#          i += arity
#@#        end
#@#        self
#@#      end
#@#    end
#@#
#@#    ary = [1,2,3]
#@#    ary.every {|i| p i}
#@#    # => 1
#@#    #    2
#@#    #    3
#@#    ary.every {|i,j| p [i,j]}
#@#    # => [1, 2]
#@#    #    [3, nil]
#@#    ary.every {|i,j,k| p [i,j,k]}
#@#    # => [1, 2, 3]
#@#    ary.every {|*i| p *i}
#@#    # => 1
#@#    #    2
#@#    #    3

--- each_index {|index| .... }    -> self
#@since 1.8.7
#@since 1.8.8
--- each_index                    -> Enumerator
#@else
--- each_index                    -> Enumerable::Enumerator
#@end
#@end

各要素のインデックスに対してブロックを評価します。

以下と同じです。

    (0 ... ary.size).each {|index| ....  }

#@since 1.8.7
ブロックが与えられなかった場合は、自身と each_index から生成した
#@since 1.8.8
[[c:Enumerator]] オブジェクトを返します。
#@else
[[c:Enumerable::Enumerator]] オブジェクトを返します。
#@end
#@end

--- empty?    -> bool

自身の要素の数が 0 の時に真を返します。そうでない場合に false を返します。

  p [].empty?         #=> true
  p [1, 2, 3].empty?  #=> false

--- eql?(other)    -> bool

自身と other の各要素をそれぞれ順に
[[m:Object#eql?]] で比較して、全要素が等しければ真を返
します。そうでない場合に false を返します。

@param other 自身と比較したい配列を指定します。

  ["a", "b", "c"].eql? ["a", "b", "c"]      #=> true
  ["a", "b", "c"].eql? ["a", "c", "b"]      #=> false
  ["a", "b", 1].eql?   ["a", "b", 1.0]      #=> false (1.eql?(1.0) が false なので)

@see [[m:Object#eql?]]
 
--- fetch(nth)               -> object    
--- fetch(nth, ifnone)       -> object
--- fetch(nth) {|nth| ... }  -> object

nth 番目の要素を返します。

[[m:Array#[] ]](nth) とは nth 番目の要素が存在しない場合の振舞いが異
なります。最初の形式では、例外 [[c:IndexError]] が発生します。
二番目の形式では、引数 ifnone を返します。
三番目の形式では、ブロックを評価した結果を返します。

@param nth 取得したい要素のインデックスを整数で指定します。

@param ifnone 要素が存在しなかった場合に返すべき値を指定します。

例:

  a = [1, 2, 3, 4, 5]
  begin
    p a.fetch(10)
  rescue IndexError => err
    puts err #=> index 10 out of array
  end
  
  p a.fetch(10, 999) #=> 999
  
  result = a.fetch(10){|nth|
    print "#{nth} はありません。\n"
    999
  }
  p result #=> 999

--- fill(val)            -> self
#@since 1.8.0
--- fill {|index| ... }  -> self
#@end

すべての要素に val をセットします。

このメソッドが val のコピーでなく val 自身をセットする
ことに注意してください([[trap:Array]])。
val の代わりにブロックを指定するとブロックの評価結果を値とします。

@param val 自身にセットしたいオブジェクトを指定します。

  a = [0, 1, 2, 3, 4]
  a.fill(10)
  p a #=> [10, 10, 10, 10, 10]
  
  a = [0, 1, 2, 3, 4]
  a.fill("a")
  p a #=> ["a", "a", "a", "a", "a"]
  a[0].capitalize!
  p a #=> ["A", "A", "A", "A", "A"]

--- fill(val, start, length = nil)             -> self
--- fill(val, range)                     -> self
#@since 1.8.0
--- fill(start, length = nil) {|index| ... }    -> self
--- fill(range) {|index| ... }            -> self
#@end

配列の指定された範囲すべてに val をセットします。

範囲の始点が自身の末尾を越える時には配列の長さを自動的に拡張し、拡張した領域を nil で初期化します。
範囲の終点が自身の末尾を越える時は長さを自動的に拡張し、拡張した部分を val で初期化します。
このメソッドが val のコピーでなく val 自身をセットすることに注意してください([[trap:Array]])。
  a = [0, 1, 2]
  a.fill("x", 5..10)
  p a #=> [0, 1, 2, nil, nil, "x", "x", "x", "x", "x", "x"]

#@since 1.8.0
val の代わりにブロックを指定するとブロックの評価結果を値とし
ます。ブロックは要素毎に実行されるので、セットする値のそれぞれをあ
るオブジェクトの複製にすることができます。
ブロックのパラメータには start からのインデックスが渡されます。

    ary = []
    p ary.fill(1..2) {|i| i}         # => [nil, 1, 2]
    p ary.fill(0,3) {|i| i}          # => [0, 1, 2]
    p ary.fill { "foo" }             # => ["foo", "foo", "foo"]
    p ary.collect {|v| v.object_id } # => [537770124, 537770112, 537770100]
#@end

@param val 自身に設定したいオブジェクトを指定します。

@param start val を設定する範囲の始点のインデックスを整数で指定します。start の値が負の時には末尾からのインデックスと見倣します。末尾の要素が -1 番目になります。

@param length val を設定する要素の個数を指定します。nil が指定された時は配列の終りまでの長さを意味します。

@param range val を設定する範囲を [[c:Range]] オブジェクトで指定します。

#@##@since 1.8.0
#@#version 1.8.0 には、ブロックに渡されるパラ
#@#メータが仕様と異なる不具合がありました。
#@#
#@#    ary = []
#@#    p ary.fill(1..2) {|i| i}         # => [2, 4, 6]  <- bug
#@#    p ary.fill(0,3) {|i| i}          # => [1, 3, 5]  <- bug
#@#    p ary.fill { "foo" }             # => ["foo", "foo", "foo"]
#@#    p ary.collect {|v| v.object_id } # => [537770124, 537770112, 537770100]
#@##@end

--- first       -> object | nil

配列の先頭の要素を返します。要素がなければ nil を返します。

    p [0, 1, 2].first   #=> 0
    p [].first          #=> nil

@see [[m:Array#last]]

#@since 1.8.0
--- first(n)    -> Array

先頭の n 要素を配列で返します。n は 0 以上でなければなりません。

@param n 取得したい要素の個数を整数で指定します。

@raise ArgumentError n が負値の場合発生します。

    ary =  [0, 1, 2]
    p ary.first(0)
    p ary.first(1)
    p ary.first(2)
    p ary.first(3)
    p ary.first(4)
    # => []
         [0]
         [0, 1]
         [0, 1, 2]
         [0, 1, 2]

@see [[m:Array#last]]
#@end

#@since 1.8.7
--- flatten(lv = nil)     -> Array
--- flatten!(lv = nil)    -> self | nil
#@else
--- flatten               -> Array
--- flatten!              -> self | nil
#@end

flatten は自身を再帰的に平滑化した配列を生成して返します。flatten! は
自身を再帰的かつ破壊的に平滑化し、平滑化が行われた場合は self をそうでない
場合は nil を返します。
#@since 1.8.7
lv が指定された場合、lv の深さまで再帰的に平滑化します。
#@end

#@since 1.8.7
@param lv 平滑化の再帰の深さを整数で指定します。nil を指定した場合、再帰の深さの制限無しに平滑化します。
#@end

@raise ArgumentError 配列要素が自身を含むような無限にネストした配列に対して flatten を呼んだ場合に発生します。

    # 自身を再帰的に平滑化する例。
    a = [1, [2, 3, [4], 5]]
    p a.flatten                     #=> [1, 2, 3, 4, 5]
    p a                             #=> [1, [2, 3, [4], 5]]

    # 自身を破壊的に平滑化する例。
    a = [[[1, [2, 3]]]]
    p a.flatten!                    #=> [1, 2, 3]
    p a                             #=> [1, 2, 3]

    # 平滑化が行われない場合は nil を返す。
    p [1, 2, 3].flatten!            #=> nil
 
#@since 1.8.7
    # 平滑化の再帰の深さを指定する例。
    a = [ 1, 2, [3, [4, 5] ] ]
    a.flatten(1)              #=> [1, 2, 3, [4, 5]]
#@end

--- hash    -> Integer

自身のハッシュ値を整数で返します。ハッシュ値は自身の各要素のハッシュ値から
計算されます。[[m:Array#eql?]] で比較して等しい配列同士は同じハッシュ値を返します。

  a = ["a", "b", 1]
  a.hash                #=>  321
  b = a.dup
  b.hash                #=>  321
  
  ["a", 1, "b"].hash    #=>  491
  ["a", 1.0, "b"].hash  #=>  466227

--- include?(val)    -> bool

配列が val と == において等しい要素を持つ時に真を返します。

@param val オブジェクトを指定します。

   a = [ "a", "b", "c" ]
   a.include?("b")       #=> true
   a.include?("z")       #=> false

--- index(val)           -> Integer | nil
#@since 1.8.7
--- index {|item| ...}   -> Integer | nil
#@end

指定された val と == で等しい最初の要素の位置を返します。
等しい要素がひとつもなかった時には nil を返します。

#@since 1.8.7
ブロックが指定された場合は、各要素を引数として順にブロックを実行し、
ブロックが真を返した最初の要素の位置を返します。
#@end

@param val インデックスを知りたいオブジェクトを指定します。

    p [1, 0, 0, 1, 0].index(1)   #=> 0
    p [1, 0, 0, 0, 0].index(1)   #=> 0
    p [0, 0, 0, 0, 0].index(1)   #=> nil
#@since 1.8.7
    p [0, 1, 0, 1, 0].index {|v| v > 0}   #=> 1
#@end

@see [[m:Array#rindex]]

--- indexes(*index)     
--- indices(*index)     

#@since 1.8.0
このメソッド obsolete です。
代わりに [[m:Array#values_at]] を使用します。
使用すると警告メッセージが表示されます。
#@end

各引数の値をインデックスとする要素の配列を返します。範囲外の
インデックス指定に対しては nil が対応します。

    ary = %w( a b c d e )
    p ary.indexes( 0, 2, 4 )          #=> ["a", "c", "e"]
    p ary.indexes( 3, 4, 5, 6, 35 )   #=> ["d", "e", nil, nil]
    p ary.indexes( 0, -1, -2 )        #=> ["a", "e", "d"]
    p ary.indexes( -4, -5, -6, -35 )  #=> ["b", "a", nil, nil]


#@since 1.8.0
--- insert(nth, *val)    -> self

インデックス nth の要素の直前(nth が負の場合は直後)に第 2 引数以降の値を挿入します。
引数 val を一つも指定しなければ何もしません。

@param nth val を挿入する位置を整数で指定します。

@param val 自身に挿入するオブジェクトを指定します。

    ary = [1, 2, 3]
    ary.insert(2, "a", "b")
    p ary                  # => [1, 2, "a", "b", 3]
    ary.insert(-2, "X")
    p ary                  # => [1, 2, "a", "b", "X", 3]

#@end

--- join(sep = $,)    -> String

配列の要素を文字列 sep を間に挟んで連結した文字列を返します。

文字列でない要素に対しては to_s した結果を連結します。
要素がまた配列であれば再帰的に (同じ sep を利用して)
join した文字列を連結します。
ただし、配列要素が自身を含むような無限にネストした配列に対しては、以下
のような結果になります。

    ary = [1,2,3]
    ary.push ary
    p ary           # => [1, 2, 3, [...]]
    p ary.join      # => "123123[...]"

@param sep 間に挟む文字列を指定します。nil のときは空文字列を使います。

  [1, 2, 3].join('-') #=> "1-2-3"

@see [[m:Array#*]], [[m:$,]]

--- last    -> object | nil

配列の末尾の要素を返します。配列が空のときは nil を返します。

    p [0, 1, 2].last   #=> 2
    p [].last          #=> nil

@see [[m:Array#first]] 

#@since 1.8.0
--- last(n)    -> Array

末尾の n 要素を配列で返します。n は 0 以上でなければなりません。

@param n 取得したい要素の個数を整数で指定します。

@raise ArgumentError n が負値の場合発生します。

    ary =  [0, 1, 2]
    p ary.last(0)
    p ary.last(1)
    p ary.last(2)
    p ary.last(3)
    p ary.last(4)
    # => []
         [2]
         [1, 2]
         [0, 1, 2]
         [0, 1, 2]

@see [[m:Array#first]]
#@end

--- length    -> Integer
--- size      -> Integer

配列の長さを返します。配列が空のときは 0 を返します。

  p [1, nil, 3, nil].size    #=> 4

#@until 1.9.1
--- nitems    -> Integer
#@since 1.8.7
--- nitems{|obj| ... } -> Integer
#@end


nil でない要素の数を返します。

#@since 1.8.7
ブロックが与えられた場合は、各要素を引数として評価し nil でない値を返した
要素の数を返します。
#@end

例:
  p [1, nil, 3, nil].nitems              #=> 2
#@since 1.8.7
  p [1, nil, 3, nil].nitems{|e| e == 1}  #=> 2
#@end
#@end

--- pack(template)    -> String

配列の内容を template で指定された文字列にしたがって、
バイナリとしてパックした文字列を返します。

テンプレートは
型指定文字列とその長さ(省略時は1)を並べたものです。長さと
して * が指定された時は「残りのデータ全て」の長さを
表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。

@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。

#@include(pack-template)

#@since 1.8.7
--- pop(n = 1)    -> Array | nil
#@else
--- pop    -> object | nil
#@end

#@since 1.8.7
自身の末尾から指定された n 個だけ要素を取り除いてそれを返します。
自身が空配列の時は nil を返します。

@param n 自身から取り除きたい要素の個数を整数で指定します。

#@else
末尾の要素を取り除いてそれを返します。自身が空配列の時は
nil を返します。
#@end

例:
      array = [1, [2, 3], 4]
      p array.pop      # => 4
      p array.pop      # => [2, 3]
      p array          # => [1]

      p array.pop      # => 1
      p array.pop      # => nil
      p array          # => []
#@since 1.8.7
      array = [1, 2, 3]
      p array.pop(2)   #=> [2, 3]
      p array          #=> [1]
#@end

@see [[m:Array#push]], [[m:Array#shift]], [[m:Array#unshift]] 

#@since 1.8.0
--- push(*obj)        -> self
#@else
--- push(obj, *rest)  -> self
#@end

指定された obj を順番に配列の末尾に追加します。
#@since 1.8.0
引数を指定しなければ何もしません。
#@end

@param obj 自身に追加したいオブジェクトを指定します。

      array = [1, 2, 3]
      array.push 4
      array.push [5, 6]
      array.push 7, 8
      p array          # => [1, 2, 3, 4, [5, 6], 7, 8]

@see [[m:Array#pop]], [[m:Array#shift]], [[m:Array#unshift]] 

--- rassoc(obj)    -> Array | nil

自身が配列の配列であると仮定して、要素の配列でインデックス
1 の要素が obj に等しいものを検索し見つかった最初の要素を返
します。該当する要素がなければ nil を返します。

比較は == 演算子を使って行われます。

@param obj オブジェクトを指定します。

    a = [[15,1], [25,2], [35,3]]
    p a.rassoc(2)    # => [25, 2]

@see [[m:Array#assoc]] 

--- replace(another)    -> self

配列の内容を配列 another の内容で置き換えます。

@param another 配列を指定します。

    a = [1, 2, 3]
    a.replace [4, 5, 6]
    p a                 #=> [4, 5, 6]

--- reverse     -> Array
#@since 1.8.0
--- reverse!    -> self
#@end

reverse は自身の要素を逆順に並べた新しい配列を生成して返します。
reverse! は自身を破壊的に並べ替えます。
#@since 1.8.0
reverse! は self を返します。
#@end

 a = ["a", 2, true]
 p a.reverse         #=> [true, 2, "a"]
 p a                 #=> ["a", 2, true] (変化なし)
 
 a = ["a", 2, true]
 p a.reverse!        #=> [true, 2, "a"]
 p a                 #=> [true, 2, "a"]

--- reverse_each {|item| ... }    -> self
#@since 1.8.7
#@since 1.8.8
--- reverse_each                  -> Enumerator
#@else
--- reverse_each                  -> Enumerable::Enumerator
#@end
#@end

各要素に対して逆順にブロックを評価します。

#@since 1.8.7
ブロックが与えられなかった場合は、自身と reverse_each から生成した
#@since 1.8.8
[[c:Enumerator]] オブジェクトを返します。
#@else
[[c:Enumerable::Enumerator]] オブジェクトを返します。
#@end
#@end

--- rindex(val)           -> Integer | nil
#@since 1.8.7 
--- rindex {|item| ... }  -> Integer | nil
#@end

指定された val と == で等しい最後の要素の位置を返します。
等しい要素がひとつもなかった時には nil を返します。

#@since 1.8.7
ブロックが与えられた時には、ブロックが真を返した最後の要素の位置を返し
ます。ブロック引数には、要素が順に渡されます。
#@end

@param val オブジェクトを指定します。

    p [1, 0, 0, 1, 0].rindex(1)   #=> 3
    p [1, 0, 0, 0, 0].rindex(1)   #=> 0
    p [0, 0, 0, 0, 0].rindex(1)   #=> nil
#@since 1.8.7
    p [0, 1, 0, 1, 0].rindex {|v| v > 0}   #=> 3
#@end

@see [[m:Array#index]]

#@since 1.8.7
--- shift(n = 1) -> Array  | nil
#@else
--- shift        -> object | nil
#@end

#@since 1.8.7
自身の先頭から指定された n 個だけ要素を取り除いてそれを返します。

また、自身が空配列の時は n が指定されていない場合はnil を、
n が明示的に指定されている場合は空の配列を返します。

@param n 自身から取り除きたい要素の個数を非負整数で指定します。

#@else
配列の先頭の要素を取り除いてそれを返します。残りの要素はひとつずつ
前に詰められます。自身が空配列の時は nil を返します。
#@end

例:

  a = [0, 1, 2, 3, 4]
  p a.shift            #=> 0
  p a                  #=> [1, 2, 3, 4]

  p [].shift           #=> nil
#@since 1.8.7
  p [].shift(1)        #=> []
#@end

@see [[m:Array#push]], [[m:Array#pop]], [[m:Array#unshift]]

--- slice(nth)       -> object | nil

指定された自身の要素を返します。[[m:Array#[] ]] と同じです。

@param nth 要素のインデックスを整数で指定します。[[m:Array#[] ]] と同じです。

例:

  p [0, 1, 2].slice(1)    #=> 1
  p [0, 1, 2].slice(2)    #=> 2
  p [0, 1, 2].slice(10)   #=> nil

--- slice(pos, len)  -> Array | nil
--- slice(range)     -> Array | nil

指定された自身の部分配列を返します。[[m:Array#[] ]] と同じです。

@param pos [[m:Array#[] ]] と同じです。

@param len [[m:Array#[] ]] と同じです。

@param range [[m:Array#[] ]] と同じです。

例:

  p [0, 1, 2].slice(0, 2)    #=> [0, 1]
  p [0, 1, 2].slice(2..3)    #=> [2]
  p [0, 1, 2].slice(10, 1)   #=> nil

--- slice!(nth)       -> object | nil

指定した要素を自身から取り除き、取り除いた要素を返します。取り除く要素がなければ nil
を返します。

@param nth 取り除く要素のインデックスを整数で指定します。[[m:Array#[] ]] と同じです。

例:

   a = [ "a", "b", "c" ]
   a.slice!(1)     #=> "b"
   a               #=> ["a", "c"]
   a.slice!(-1)    #=> "c"
   a               #=> ["a"]
   a.slice!(100)   #=> nil
   a               #=> ["a"]

--- slice!(start, len)  -> Array | nil
--- slice!(range)     -> Array | nil

指定した部分配列を自身から取り除き、取り除いた部分配列を返します。取り除く要素がなければ nil
を返します。

以下のコードと同値です。

     def slice!(*args)
        result = self[*args]
        self[*args] = nil
        result
     end

ですので以下のように配列の長さが拡張される場合もありえます。

  a = [ "a", "b", "c" ]
  p a.slice!(5, 1)       #=> nil
  p a                    #=> ["a", "b", "c", nil, nil]

@param start 削除したい部分配列の先頭のインデックスを整数で指定します。[[m:Array#[] ]] と同じです。

@param len 削除したい部分配列の長さを整数で指定します。[[m:Array#[] ]] と同じです。

@param range 削除したい配列の範囲を [[c:Range]] オブジェクトで指定します。[[m:Array#[] ]] と同じです。

@raise IndexError 指定された範囲の始点が自身の始点より前にある場合に発生します。

例:

   a = [ "a", "b", "c" ]
   a.slice!(1, 2)     #=> ["b", "c"]
   a                  #=> ["a"]
   
   a = [ "a", "b", "c" ]
   a.slice!(1, 0)     #=> []
   a                  #=> [ "a", "b", "c" ]
 
   a = [ "a", "b", "c" ]
   a.slice!(-10, 1)   #=> IndexError

--- sort                -> Array
--- sort!               -> self
--- sort {|a, b| ... }  -> Array
--- sort! {|a, b| ... } -> self

配列の内容をソートします。要素同士の比較は <=> 演算子を使って行います。sort はソートされた配列を生成して返します。
#@since 1.8.0
sort! は self を破壊的にソートし、self を返します。
#@else
sort! は self を破壊的に変更し、self を返します。ただし、要素の数が 2 より小さい場合には nil を返します。
#@end

ブロックとともに呼び出された時には、要素同士の比較をブロックを用いて行います。
ブロックに2つの要素を引数として与えて評価し、その結果で比較します。
ブロックは <=> 演算子と同様に整数を返すことが期待されています。つまり、
ブロックは第1引数が大きいなら正の整数、両者が等しいなら0、そして第1引数の方が小さいなら
負の整数を返さなければいけません。両者を比較できない時は nil を返します。

   a = [ "d", "a", "e", "c", "b" ]
   p a.sort                                #=> ["a", "b", "c", "d", "e"]
   
   b = ["9", "7", "10", "11", "8"]
   p b.sort                                #=> ["10", "11", "7", "8", "9"] (文字列としてソートするとこうなる)
   p b.sort{|x, y| x.to_i <=> y.to_i }     #=> ["7", "8", "9", "10", "11"] (ブロックを使って数字としてソート)

   # sort_by を使っても良い
   p b.sort_by{|x| x.to_i }                #=> ["7", "8", "9", "10", "11"]

@see [[m:Enumerable#sort_by]]

#@since 1.9.2
--- sort_by!               -> Enumerator
--- sort_by! {|a, b| ... } -> self
#@todo
sort_by の破壊的バージョンです。

@see [[m:Enumerable#sort_by]]
#@end

--- to_a       -> Array
#@since 1.9.1
--- to_splat   -> Array
#@# ない？
#@end

self を返します。ただし、Array のサブクラスのインスタンスに対して呼ばれた時は、
自身を Array に変換したものを返します。

--- to_ary  -> self

self をそのまま返します

--- to_s    -> String

#@since 1.9.1
[[m:Array#inspect]] と同じです。
#@else
[[m:Array#join]]([[m:$,]]) と同じです。
#@end

#@since 1.8.0
--- transpose    -> Array

自身を行列と見立てて、行列の転置(行と列の入れ換え)を行いま
す。転置した配列を生成して返します。空の配列に対しては空の配列を生
成して返します。

それ以外の一次元の配列に対しては、例外
[[c:TypeError]] が発生します。各要素のサイズが不揃いな配列に対して
は、例外 [[c:IndexError]] が発生します。

    p [[1,2],
       [3,4],
       [5,6]].transpose
    # => [[1, 3, 5], [2, 4, 6]]

    p [].transpose
    # => []

    p [1,2,3].transpose

    # => -:1:in `transpose': cannot convert Fixnum into Array (TypeError)
            from -:1

    p [[1,2],
       [3,4,5],
       [6,7]].transpose
    # => -:3:in `transpose': element size differ (3 should be 2) (IndexError)
#@end

--- uniq     -> Array
--- uniq!    -> self | nil
#@since 1.9.2
--- uniq {|item| ... } -> Array
--- uniq! {|item| ... } -> self | nil
#@end

uniq は配列から重複した要素を取り除いた新しい配列を返します。
取り除かれた要素の部分は前に詰められます。uniq! は削除を破壊
的に行い、削除が行われた場合は self を、そうでなければ
nil を返します。

要素の重複判定は、[[m:Object#eql?]] により行われます。

    p [1, 1, 1].uniq         #=> [1]
    p [1, 4, 1].uniq         #=> [1, 4]
    p [1, 3, 2, 2, 3].uniq   #=> [1, 3, 2]


#@since 1.8.0
--- unshift(*obj)        -> self
#@else
--- unshift(obj, *rest)  -> self
#@end

指定された obj を順番に配列の先頭に挿入します。
#@since 1.8.0
引数を指定しなければ何もしません。
#@end

@param obj 自身に追加したいオブジェクトを指定します。

    arr = [1,2,3]
    arr.unshift 0
    p arr             #=> [0, 1, 2, 3]
    arr.unshift [0]
    p arr             #=> [[0], 0, 1, 2, 3]
    arr.unshift 1, 2
    p arr             #=> [1, 2, [0], 0, 1, 2, 3]

@see [[m:Array#push]], [[m:Array#pop]], [[m:Array#shift]]

#@since 1.8.0
--- values_at(*index)    -> Array | nil

引数で指定されたインデックスに対応する要素を配列で返します。インデッ
クスに対応する値がなければ nil が要素になります。

@param index インデックスを整数で指定します。

    ary = %w( a b c d e )
    p ary.values_at( 0, 2, 4 )          #=> ["a", "c", "e"]
    p ary.values_at( 3, 4, 5, 6, 35 )   #=> ["d", "e", nil, nil, nil]
    p ary.values_at( 0, -1, -2 )        #=> ["a", "e", "d"]
    p ary.values_at( -4, -5, -6, -35 )  #=> ["b", "a", nil, nil]

#@# ([[m:Array#indexes]], [[m:Array#indices]] と同じです)

#@end

#@since 1.8.0
--- zip(*lists)  -> [[Object]]
--- zip(*lists) {|v1, v2, ...| ...} -> nil

自身と引数に渡した配列の各要素からなる配列の配列を生成して返します。
生成される配列の要素数は self の要素数と同じです。

ブロック付きで呼び出した場合は、
self と引数に渡した配列の各要素を順番にブロックに渡します。

@param lists 配列を指定します。配列でない場合は [[m:Enumerable#zip]] 
             と違い to_ary メソッドにより配列に変換します。

例:
    p [1,2,3].zip([4,5,6], [7,8,9])
        # => [[1, 4, 7], [2, 5, 8], [3, 6, 9]]

    p [1,2].zip([:a,:b,:c], [:A,:B,:C,:D])
        # => [[1, :a, :A], [2, :b, :B]]

    p (1..5).zip([:a,:b,:c], [:A,:B,:C,:D])
        # => [[1, :a, :A], [2, :b, :B],
        #     [3, :c, :C], [4, nil, :D], [5, nil, nil]]
    
    p [1,2,3].zip([4,5,6], [7,8,9]) {|ary|
      p ary
    }
        # => [1, 4, 7]
        #    [2, 5, 8]
        #    [3, 6, 9]
        #    nil
#@end

#@if (version == "1.8.7")
--- choice        -> object

配列の要素を1個ランダムに選んで返します。

配列が空の場合は nil を返します。

srand()が有効です。

このメソッドは Ruby 1.8.7 と Ruby 1.9.0 にしか存在しないメソッドです。
Ruby 1.8.8 以降では Array#sample を使ってください。

例:

  a = (1..10).to_a
  p a.choice        #=>  9
  p a.choice        #=> 10
  p a               #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#@end

#@since 1.8.8
#@if (version != "1.9.0")
--- sample        -> object
--- sample(n)     -> Array

配列の要素を1個(引数を指定した場合は n 個)ランダムに選んで返します。

配列が空の場合、無引数の場合は nil を、個数を指定した場合は空配列を返します。

srand()が有効です。

例:

  a = (1..10).to_a
  p a.sample        #=>  9
  p a.sample        #=> 10
  p a.sample(3)     #=> [1, 9, 3]
  p a               #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#@end
#@end

#@since 1.8.7
--- cycle {|obj| block }

Enumerable オブジェクトの要素を、繰り返し無限に生成し続けます。

例:

   a = ["a", "b", "c"]
   a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.

--- shuffle -> Array

配列の要素をシャッフルして，その結果を配列として返します。

srand()が有効です。

例:

   a = [ 1, 2, 3 ]           #=> [1, 2, 3]
   a.shuffle                 #=> [2, 3, 1]

--- shuffle!        -> self
#@todo

配列を破壊的にシャッフルします。

例:

   a = [ 1, 2, 3 ]           #=> [1, 2, 3]
   a.shuffle!                #=> [2, 3, 1]
   a                         #=> [2, 3, 1]

--- combination(n) {|c| block }    -> Array
#@since 1.8.8
--- combination(n)                 -> Enumerator
#@else
--- combination(n)                 -> Enumerable::Enumerator
#@end

サイズ n の組み合わせをすべて生成し、それを引数としてブロックを実行します。

得られる組み合わせの順序は保証されません。ブロックなしで呼び出されると、組み合わせ
#@since 1.8.8
を生成する [[c:Enumerator]] オブジェクトを返します。
#@else
を生成する [[c:Enumerable::Enumerator]] オブジェクトを返します。
#@end

@param n 生成される配列のサイズ。

例:

    a = [1, 2, 3, 4]
    a.combination(1).to_a  #=> [[1],[2],[3],[4]]
    a.combination(2).to_a  #=> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
    a.combination(3).to_a  #=> [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
    a.combination(4).to_a  #=> [[1,2,3,4]]
    a.combination(0).to_a  #=> [[]]: one combination of length 0
    a.combination(5).to_a  #=> []  : no combinations of length 5

--- permutation(n) { |p| block }       -> Array
#@since 1.8.8
--- permutation(n)                     -> Enumerator
#@else
--- permutation(n)                     -> Enumerable::Enumerator
#@end

サイズ n の順列をすべて生成し，それを引数としてブロックを実行します。

得られる順列の順序は保証されません。ブロックなしで呼び出されると， 順列
#@since 1.8.8
を生成する [[c:Enumerator]] オブジェクトを返します。
#@else
を生成する [[c:Enumerable::Enumerator]] オブジェクトを返します。
#@end

@param n 生成する配列のサイズ

例:

    a = [1, 2, 3]
    a.permutation(1).to_a  #=> [[1],[2],[3]]
    a.permutation(2).to_a  #=> [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
    a.permutation(3).to_a  #=> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
    a.permutation(0).to_a  #=> [[]]: one permutation of length 0
    a.permutation(4).to_a  #=> []  : no permutations of length 4


--- product(*lists)    -> Array

レシーバの配列と引数で与えられた配列（複数可）のそれぞれから要素を1
個ずつとって配列とし，それらのすべての配列を要素とする配列を返します。

返される配列の長さは，レシーバと引数で与えられた配列の長さのすべての積にな
ります。


@param lists 配列。複数指定可能。

例:

   [1,2,3].product([4,5])     # => [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
   [1,2].product([1,2])       # => [[1,1],[1,2],[2,1],[2,2]]
   [1,2].product([3,4],[5,6]) # => [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
                              #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
   [1,2].product()            # => [[1],[2]]
   [1,2].product([])          # => []

#@end

#@since 1.9.2
--- rotate(cnt=1) -> Array
#@todo

Returns new array by rotating _self_, whose first element is the
element at +cnt+ in _self_.  If +cnt+ is negative then it rotates
in counter direction.

   a = [ "a", "b", "c", "d" ]
   a.rotate         #=> ["b", "c", "d", "a"]
   a                #=> ["a", "b", "c", "d"]
   a.rotate(2)      #=> ["c", "d", "a", "b"]
   a.rotate(-3)     #=> ["b", "c", "d", "a"]

@see [[m:Array#rotate!]]
--- rotate!(cnt=1) -> self
#@todo

Rotates _self_ in place so that the element at +cnt+ comes first,
and returns _self_.  If +cnt+ is negative then it rotates in
counter direction.

   a = [ "a", "b", "c", "d" ]
   a.rotate!        #=> ["b", "c", "d", "a"]
   a                #=> ["b", "c", "d", "a"]
   a.rotate!(2)     #=> ["d", "a", "b", "c"]
   a.rotate!(-3)    #=> ["a", "b", "c", "d"]

@see [[m:Array#rotate]]
#@end
