= reopen Object

== Methods

--- to_enum(method = :each, *args)
--- enum_for(method = :each, *args)

(({Enumerable::Enumerator.new(self, method, *args)}))を返す。

//ex{
str = "xyz"

enum = str.enum_for(:each_byte)
a = enum.map {|b| '%02x' % b } #=> ["78", "79", "7a"]

# protects an array from being modified
a = [1, 2, 3]
some_method(a.to_enum)
//}



= reopen Enumerable

== Methods

--- each_slice(n) {...}

n 要素ずつにわけてブロックに渡して繰り返す。

//ex{
(1..10).each_slice(3) {|a| p a}
# outputs below
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[10]
//}

--- enum_slice(n)

(({Enumerable::Enumerator.new(self, :each_slice, n)})) を返す。

--- each_cons(n) {...}

連続した n 要素ずつの配列をブロックに渡して繰り返す。

//ex{
(1..10).each_cons(3) {|a| p a}
# outputs below
[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 10]
//}

--- enum_cons(n)

(({Enumerable::Enumerator.new(self, :each_cons, n)}))を返す。

--- enum_with_index

(({Enumerable::Enumerator.new(self, :each_with_index)}))を返す。



= class Enumerable::Enumerator < Object

include Enumerable

each 以外のメソッド、つまり each_byte 等も enumerate できる
ようにするためのラッパークラス。

== Class Methods

--- new(obj, method = :each, *args)

オブジェクト obj について、 each の代わりに method という
名前のメソッドを使って繰り返すオブジェクトを生成して返す。
args を指定すると、 method の呼び出し時に渡される。

//ex{
str = "xyz"

enum = Enumerable::Enumerator.new(str, :each_byte)
p enum.map {|b| '%02x' % b }   # => ["78", "79", "7a"]
//}

== Methods

--- each {...}

生成時のパラメータに従って繰り返す。
