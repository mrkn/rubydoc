= class Module < Object

モジュールのクラスです。

== Class Methods

--- constants -> [String]

このメソッドを呼び出した時点で参照可能な定数名の配列を返します。

例:

  class C
    FOO = 1
  end
  p Module.constants   # => ["RUBY_PLATFORM", "STDIN", ..., "C", ...]
                       # 出力中に "FOO" は現われない

@see [[m:Module#constants]], [[m:Kernel#local_variables]], [[m:Kernel#global_variables]], [[m:Object#instance_variables]], [[m:Module#class_variables]]

--- nesting -> [Class, Module]

このメソッドを呼び出した時点でのクラス/モジュールのネスト情
報を配列に入れて返します。

例:

  module Foo
    module Bar
      module Baz
        p Module.nesting   # => [Foo::Bar::Baz, Foo::Bar, Foo]
      end
    end
  end

--- new -> Module
#@since 1.8.0
--- new {|mod| ... } -> Module
#@end

名前の付いていないモジュールを新しく生成して返します。

#@since 1.8.0
ブロックが与えられると生成したモジュールをブロックの引数に渡し、
モジュールのコンテキストでブロックを実行します。

  mod = Module.new
  mod.module_eval {|m| ... }
  mod

と同じです。
ブロックの実行は Module#initialize が行います。

ブロックを与えた場合も生成したモジュールを返します。
#@end

このメソッドで生成されたモジュールは、
最初に名前が必要になったときに名前が決定します。
モジュールの名前は、
そのモジュールが代入されている定数名のいずれかです。

  m = Module.new
  p m               # => #<Module 0lx40198a54>
#@since 1.9.0
  p m.name          # => nil   # まだ名前は未定
#@else
  p m.name          # => ""    # まだ名前は未定
#@end
  Foo = m
  # m.name          # ここで m.name を呼べば m の名前は "Foo" に確定する
  Bar = m
  m.name            # "Foo" か "Bar" のどちらかに決まる

== Instance Methods

--- <=>(other) -> Integer | nil

self と other の親子関係を比較します。

@param other 比較対象のクラスやモジュール

self と other を比較して、
self が other の子孫であるとき -1、
同一のクラス／モジュールのとき 0、
self が other の先祖であるとき 1
を返します。

親子関係にないクラス同士の比較では
#@since 1.8.0
nil を返します。
#@else
その動作は不定です。
#@end

other がクラスやモジュールでなければ
#@since 1.8.0
nil を返します。
#@else
例外 [[c:TypeError]] が発生します。
#@end

  module Foo
  end
  class Bar
    include Foo
  end
  class Baz < Bar
  end
  class Qux
  end
  p Bar <=> Foo     # => -1
  p Baz <=> Bar     # => -1
  p Baz <=> Foo     # => -1
#@since 1.8.0
  p Baz <=> Qux     # => -1
  p Qux <=> Baz     # => -1
#@end
#@since 1.8.0
  p Baz <=> Qux     # => nil
  p Qux <=> Baz     # => nil
#@else
  p Baz <=> Qux     # => 1
  p Qux <=> Baz     # => 1
#@end

#@since 1.8.0
  p Baz <=> Object.new  # => nil
#@else
  p Baz <=> Object.new  # => :in `<=>': <=> requires Class or Module (Object given) (TypeError)
#@end

--- <(other)  -> bool | nil
--- <=(other) -> bool | nil
--- >(other)  -> bool | nil
--- >=(other) -> bool | nil
#@todo

比較演算子。self が other の子孫である時、
self < other が成立します。

@param other 比較対象のモジュールやクラス

@raise other がクラスやモジュールでなければ例外 [[c:TypeError]] が発生します。


親子関係にないクラス同士の比較ではいずれの関係も
#@since 1.8.0
nil を返します。
#@else
false を返します。
#@end




  module Foo
  end
  class Bar
    include Foo
  end
  class Baz < Bar
  end
  class Qux
  end
  p Bar < Foo     # => true
  p Baz < Bar     # => true
  p Baz < Foo     # => true
#@since 1.8.0
  p Baz < Qux     # => nil
  p Baz > Qux     # => nil
#@else
  p Baz < Qux     # => false
  p Baz > Qux     # => false
#@end

  p Foo < Object.new # => in `<': compared with non class/module (TypeError)

--- ===(obj) -> bool
#@todo
obj が self と [[m:Object#kind_of?]] の関係がある時、真になります。

@param obj 任意のオブジェクト

このメソッドは主に [[unknown:制御構造/case]] 文での比較に用いられます。
[[unknown:制御構造/case]] ではクラス、モジュールの
所属関係をチェックすることになります。



  str = String.new
  case str
  when String     # String === str を評価する
    p true        # => true
  end

--- ancestors -> [Class, Module]

クラス、モジュールのスーパークラスとインクルードしているモジュール
を優先順位順に配列に格納して返します。



  module Foo
  end
  class Bar
    include Foo
  end
  class Baz < Bar
    p ancestors
    p included_modules
    p superclass
  end
  # => [Baz, Bar, Foo, Object, Kernel]
  # => [Foo, Kernel]
  # => Bar

#@since 1.8.0
--- autoload(const_name, feature) -> nil
#@todo

定数 const_name を最初に参照した時に feature を [[m:Kernel#require]] するように設定します。

@param const_name [[c:String]] または [[c:Symbol]] で指定します。
なお、const_name には、"::" 演算子を含めることはできません (つまり、トップレベルの定数しか指定できません)。

@param feature [[m:Kernel#require]] と同様な方法で autoload する対象を指定する。

詳しくは [[m:Kernel#autoload]] を参照。
#@end

--- autoload?(const_name) -> String | nil
autoload 定数がまだ定義されてない(ロードされていない) ときにそのパス名を返します。
また、ロード済みなら nil を返します。

@param const_name [[c:String]] または [[c:Symbol]] で指定します。

詳しくは [[m:Kernel#autoload?]] を参照。

--- class_variables -> [String]

クラス／モジュールに定義されているクラス変数の名前の配列を返します。

スーパークラスやインクルードしているモジュールのクラス変数も含みます。

@see [[m:Module.constants]], [[m:Kernel#local_variables]], [[m:Kernel#global_variables]], [[m:Object#instance_variables]], [[m:Module#constants]]

#@since 1.9.0
--- const_defined?(name, inherit = true) -> bool
#@todo

モジュールに name で指定される名前の定数が定義されている時真
を返します。

@param name [[c:String]], [[c:Symbol]] で指定される定数名。

@param inherit false を指定するとスーパークラスや include したモジュールで
定義された定数は対象にはなりません。

#@else
--- const_defined?(name) -> bool
#@todo

モジュールに name で指定される名前の定数が定義されている時真
を返します。

@param name [[c:String]], [[c:Symbol]] で指定される定数名。

#@end

#@since 1.9.0
スーパークラスや include したモジュールで定義された定数を検索対象
にするかどうかは第二引数で制御することができます。
#@else
スーパークラスや include したモジュールで定義された定数は対象には
なりません。(ただし、[[c:Object]] だけは例外)
#@# あらい 2002-04-10: バグ?制限?
#@end

  module Kernel
    FOO = 1
  end

  # Object は include したモジュールの定数に対しても
  # true を返す
  p Object.const_defined?(:FOO)   # => true

  module Bar
    BAR = 1
  end
  class Object
    include Bar
  end
  # ユーザ定義のモジュールに対しても同様
  p Object.const_defined?(:BAR)   # => true

  class Baz
    include Bar
  end
#@since 1.9.0
  # Object 以外でも同様になった
  # 第二引数のデフォルト値が true であるため
  p Baz.const_defined?(:BAR)      # => true

  # 第二引数を false にした場合
  p Baz.const_defined?(:BAR, false)   # => false
#@else
  # Object 以外では自身の定数だけがチェック対象
  p Baz.const_defined?(:BAR)      # => false
#@end

#@since 1.9.0
--- const_get(name, inherit = true) -> object
#@todo

モジュールに定義されている name で指定される名前の定数の値を
取り出します。

@param name 定数名。[[c:String]] か [[c:Symbol]] で指定します。

@param inherit false を指定するとスーパークラスや include したモジュールで
定義された定数は対象にはなりません。

#@else
--- const_get(name) -> object
#@todo

モジュールに定義されている name で指定される名前の定数の値を
取り出します。

@param name 定数名。[[c:String]] か [[c:Symbol]] で指定します。

#@end

@raise NameError 定数が定義されていないときに発生します。

[[m:Module#const_defined?]] と違って [[c:Object]] を特別扱いすることはありません。



  module Bar
    BAR = 1
  end
  class Object
    include Bar
  end
  # Object では include されたモジュールに定義された定数を見付ける
  p Object.const_get(:BAR)   # => 1

  class Baz
    include Bar
  end
  # Object以外でも同様
  p Baz.const_get(:BAR)      # => 1
  # 定義されていない定数
  p Baz.const_get(:NOT_DEFINED) #=> raise NameError
#@since 1.9.0
  # 第二引数に false を指定すると自分自身に定義された定数から探す
  p Baz.const_get(:BAR, false) #=> raise NameError
#@end

#@since 1.8.0
--- const_missing(name)
#@todo
定義されていない定数を参照したときに Ruby がこのメソッドを呼びます。

@param name 参照した定数名の [[c:Symbol]]

デフォルトではこのメソッドは例外 [[c:NameError]] を発生させます。



  class Foo
    def Foo.const_missing(id)
      warn "undefined constant #{id.inspect}"
    end

    Bar
  end
  Foo::Bar

  # => undefined constant :Bar
       undefined constant :Bar
#@end

--- const_set(name, value) -> object
#@todo

モジュールに name で指定された名前の定数を value とい
う値として定義し、value を返します。

@param name  [[c:Symbol]],[[c:String]] で定数の名前を指定します。
@param value セットしたい値を指定します。

そのモジュールにおいてすでにその名前の定数が定義されている場合、警
告メッセージが出力されます。

#@since 1.9.0
--- constants(inherit = true) -> [String]
#@todo

@param inherit false を指定するとスーパークラスや include したモジュールで
定義された定数は対象にはなりません。

#@else
--- constants
#@todo
#@end

そのモジュール(またはクラス)で定義されている定数名の配列を返
します。
#@if version <= "1.9.0"
スーパークラスやインクルードしているモジュールの定数も含みます。
#@end

@see [[m:Module.constants]], [[m:Kernel#local_variables]], [[m:Kernel#global_variables]], [[m:Object#instance_variables]], [[m:Module#class_variables]]

 Module.constants と Module#constants の違い

  # 出力の簡略化のため起動時の定数一覧を取得して後で差し引く
  $clist = Module.constants

  class Foo
    FOO = 1
  end
  class Bar
    BAR = 1

    # Bar は BAR を含む
    p constants - $clist                # => ["BAR"]
    # 出力に FOO は含まれない
    p Module.constants - $clist         # => ["BAR", "Bar", "Foo"]
    class Baz
      # Baz は定数を含まない
      p constants - $clist              # => []

      # ネストしたクラスでは、外側のクラスで定義した定数は
      # 参照可能なので、BAR は、Module.constants には含まれる
      # (クラス Baz も Bar の定数なので同様)
      p Module.constants - $clist       # => ["BAR", "Baz", "Bar", "Foo"]
    end
  end

#@since 1.8.0
--- include?(mod) -> bool
#@todo

self かその親クラス / 親モジュールがモジュール mod を
インクルードしていれば true を返します。

@param mod [[c:Module]] を指定します。



  module M
  end
  class C1
    include M
  end
  class C2 < C1
  end

  p C1.include?(M)   # => true
  p C2.include?(M)   # => true
#@end

--- included_modules -> [Module]
#@todo

インクルードされているモジュールの配列を返します。
[[m:Module#ancestors]] の例も参照してください

--- instance_method(name) -> UnboundMethod
#@todo

self のインスタンスメソッドをオブジェクト化した [[c:UnboundMethod]] を返します。

@param name [[c:Symbol]] か [[c:String]] です。

@raise NameError self に存在しないメソッドを指定した場合に発生します。

@see [[m:Object#method]]

#@since 1.9.0
--- method_defined?(name, inherit = true)
#@todo
#@else
--- method_defined?(name) -> bool
#@todo
#@end

モジュールにインスタンスメソッド name が定義されているとき
true を返します。

@param name [[c:Symbol]] か [[c:String]] を指定します。

@see [[m:Module#public_method_defined?]], [[m:Module#private_method_defined?]], [[m:Module#protected_method_defined?]]

--- module_eval(expr, fname = '(eval)', lineno = 1) -> object
--- module_eval{|mod| .... } -> object
--- class_eval(expr, fname = '(eval)', lineno = 1) -> object
--- class_eval{|mod| ... } -> object

モジュールのコンテキストで文字列 expr を評価してその結果を返します。

@param expr 評価される文字列。
@param fname スタックトレースに表示するファイル名。
@param lineno スタックトレースに表示する行番号。

@return expr を評価した結果。

fname、lineno が与えられた場合は、ファイル fname、
行番号 lineno にその文字列があるかのようにコンパイルされ、
スタックトレース表示などのファイル名／行番号を差し替えることができます。

ブロックが与えられた場合にはそのブロックを
モジュールのコンテキストで評価してその結果を返します。
ブロックの引数 mod には self が渡されます。

モジュールのコンテキストで評価するとは、
実行中そのモジュールが self になるということです。
つまり、そのモジュールの定義文の中にあるかのように
実行されます。

ただし、ローカル変数は module_eval/class_eval の外側のスコープと共有します。

ブロックが与えられた場合は、
定数とクラス変数のスコープも外側のスコープになります。

=== 注意
module_eval のブロック中でメソッドを定義する場合、
[[m:Object#instance_eval]] と同様の制限があります。
詳細はそちらの説明を参照してください。

@see [[m:Object#instance_eval]], [[m:Module.new]]

--- name -> String
--- to_s -> String
#@todo

モジュールやクラスの名前を文字列で返します。

#@since 1.9.0
@return 名前のないモジュール / クラスに対しては nil を返します。
#@else
@return 名前のないモジュール / クラスに対しては空文字列を返します。
#@end

このメソッドが返す「モジュール / クラスの名前」とは、
より正確には「クラスパス」を指します。
クラスパスとは、ネストしているモジュールすべてを
「::」を使って表示した名前のことです。
クラスパスの例としては「CGI::Session」「Net::HTTP」が挙げられます。



  module A
    module B
    end

    p B.name  #=> "A::B"

    class C
    end
  end

  p A.name    #=> "A"
  p A::B.name #=> "A::B"
  p A::C.name #=> "A::C"

  # 名前のないモジュール / クラス
#@since 1.9.0
  p Module.new.name   #=> nil
  p Class.new.name    #=> nil
#@else
  p Module.new.name   #=> ""
  p Class.new.name    #=> ""
#@end

#@since 1.9.0
--- instance_methods(inherited_too = true) -> [Symbol]
#@else
--- instance_methods(inherited_too = true) -> [String]
#@end

そのモジュールで定義されている public および protected メソッド名
の一覧を配列で返します。

@param inherited_too false を指定するとそのモジュールで定義されているメソッドのみ返します。

@see [[m:Object#methods]]

例1:

  class Foo
    private;   def private_foo()   end
    protected; def protected_foo() end
    public;    def public_foo()    end
  end

  # あるクラスのインスタンスメソッドの一覧を得る
  p Foo.instance_methods(false)
  p Foo.public_instance_methods(false)
  p Foo.private_instance_methods(false)
  p Foo.protected_instance_methods(false)

  class Bar < Foo
  end

実行結果

#@since 1.8.0
     ["protected_foo", "public_foo"]
#@else
     ["public_foo"]
#@end
     ["public_foo"]
     ["private_foo"]
     ["protected_foo"]

例2:

  # あるクラスのインスタンスメソッドの一覧を得る。
  # 親のクラスのインスタンスメソッドも含めるため true を指定して
  # いるが、Object のインスタンスメソッドは一覧から排除している。
  p Bar.instance_methods(true)           - Object.instance_methods(true)
  p Bar.public_instance_methods(true)    - Object.public_instance_methods(true)
  p Bar.private_instance_methods(true)   - Object.private_instance_methods(true)
  p Bar.protected_instance_methods(true) - Object.protected_instance_methods(true)

実行結果

#@since 1.8.0
     ["protected_foo", "public_foo"]
#@else
     ["protected_foo"]
#@end
     ["public_foo"]
     ["private_foo"]
     ["protected_foo"]

#@since 1.9.0
--- public_instance_methods(inherited_too = true) -> [Symbol]
#@else
--- public_instance_methods(inherited_too = true) -> [String]
#@end

そのモジュールで定義されている public メソッド名
の一覧を配列で返します。

@param inherited_too false を指定するとそのモジュールで定義されているメソッドのみ返します。

@see [[m:Object#public_methods]], [[m:Module#instance_methods]]

#@since 1.9.0
--- private_instance_methods(inherited_too = true) -> [Symbol]
#@else
--- private_instance_methods(inherited_too = true) -> [String]
#@end

そのモジュールで定義されている private メソッド名
の一覧を配列で返します。

@param inherited_too false を指定するとそのモジュールで定義されているメソッドのみ返します。

@see [[m:Object#private_methods]], [[m:Module#instance_methods]]

#@since 1.9.0
--- protected_instance_methods(inherited_too = true) -> [Symbol]
#@else
--- protected_instance_methods(inherited_too = true) -> [String]
#@end

そのモジュールで定義されている protected メソッド名
の一覧を配列で返します。

@param inherited_too false を指定するとそのモジュールで定義されているメソッドのみ返します。

@see [[m:Object#protected_methods]], [[m:Module#instance_methods]]

--- private_class_method(*name) -> self
#@todo

name で指定したクラスメソッド (クラスの特異メソッド) の
可視性を private に変更します。

@param name 一つ以上の [[c:String]] か [[c:Symbol]] を指定します。

--- public_class_method(*name) -> self
#@todo

name で指定したクラスメソッド (クラスの特異メソッド) の
可視性を public に変更します。

@param name 一つ以上の [[c:String]] か [[c:Symbol]] を指定します。

#@since 1.8.0
--- private_method_defined?(name) -> bool
#@todo

インスタンスメソッド name がモジュールに定義されており、
しかもその可視性が private であるときに true を返します。
そうでなければ false を返します。

@param name [[c:Symbol]] か [[c:String]] を指定します。

@see [[m:Module#method_defined?]]

--- protected_method_defined?(name) -> bool
#@todo

インスタンスメソッド name がモジュールに定義されており、
しかもその可視性が protected であるときに true を返します。
そうでなければ false を返します。

@param name [[c:Symbol]] か [[c:String]] を指定します。

@see [[m:Module#method_defined?]]

--- public_method_defined?(name) -> bool
#@todo

インスタンスメソッド name がモジュールに定義されており、
しかもその可視性が public であるときに true を返します。
そうでなければ false を返します。

@param name [[c:Symbol]] か [[c:String]] を指定します。

@see [[m:Module#method_defined?]]

#@end

#@since 1.8.6
--- class_variable_defined?(name) -> bool
#@todo

name で与えられた名前のクラス変数がモジュールに存在する場合 true を
返します。
#@# Returns true if the given class variable is defined in obj.

@param name [[c:Symbol]] か [[c:String]] を指定します。

   class Fred
     @@foo = 99
   end
   Fred.class_variable_defined?(:@@foo)    #=> true
   Fred.class_variable_defined?(:@@bar)    #=> false
   Fred.class_variable_defined?('@@foo')    #=> true
   Fred.class_variable_defined?('@@bar')    #=> false

#@end

== Private Instance Methods

--- alias_method(new, original) -> self
#@todo

メソッドの別名を定義します。

@param new 新しいメソッド名。[[c:String]] または [[c:Symbol]] で指定します。

@param original 元のメソッド名。[[c:String]] または [[c:Symbol]] で指定します。

[[unknown:クラス／メソッドの定義/alias]] との違いは以下の通りです。

  * メソッド名は [[c:String]] または [[c:Symbol]] で指定します
  * グローバル変数の別名をつけることはできません

また、クラスメソッドに対して使用することはできません。

--- append_features(module_or_class) -> self
#@todo

モジュール(あるいはクラス)に self の機能を追加します。
このメソッドは [[m:Module#include]] の実体であり、
include を Ruby で書くと以下のように定義できます。

  def include(*modules)
    modules.each {|mod|
      # append_features はプライベートメソッドなので
      # 直接 mod.append_features(self) とは書けない
#@since 1.9.0
      mod.__send!(:append_features, self)
      mod.__send!(:included, self)
#@else
      mod.__send__(:append_features, self)
#@since 1.8.0
      mod.__send__(:included, self)
#@end
#@end
    }
  end

--- attr(name, assignable = false) -> nil
#@todo

インスタンス変数読み取りのためのインスタンスメソッド name を定義します。

@param name [[c:String]] または [[c:Symbol]] で指定します。

@param assignable true を指定するとインスタンス変数書き込み用のインスタンスメソッドも定義します。

このメソッドで定義されるアクセスメソッドの定義は次の通りです。

  def name
    @name
  end

省略可能な第 2 引数 assignable が指定されその値が真である
場合には、属性の書き込み用メソッド name= も同時に定義されます。
その定義は次の通りです。

  def name=(val)
    @name = val
  end

--- attr_accessor(*name) -> nil
#@todo

インスタンス変数 name に対する読み取りメソッドと書き込みメソッドの両方を
定義します。

@param name [[c:String]] または [[c:Symbol]] を 1 つ以上指定します。

このメソッドで定義されるメソッドの定義は以下の通りです。

  def name
    @name
  end
  def name=(val)
    @name = val
  end

--- attr_reader(*name) -> nil
#@todo

インスタンス変数 name の読み取りメソッドを定義します。

@param name [[c:String]] または [[c:Symbol]] を 1 つ以上指定します。

このメソッドで定義されるメソッドの定義は以下の通りです。

  def name
    @name
  end

--- attr_writer(*name) -> nil
#@todo

インスタンス変数 name への書き込みメソッド (name=) を定義します。

@param name [[c:String]] または [[c:Symbol]] を 1 つ以上指定します。

このメソッドで定義されるメソッドの定義は以下の通りです。

  def name=(val)
    @name = val
  end

#@since 1.8.3
--- class_variable_get(name) -> object
#@todo

クラス／モジュールに定義されているクラス変数 name の値を返します。

@param name [[c:String]] または [[c:Symbol]] を指定します。

@raise NameError クラス変数 name が定義されていない場合、発生します。

  class Fred
    @@foo = 99
  end

  def Fred.foo
    class_variable_get(:@@foo)
  end

  p Fred.foo #=> 99

#@end

#@since 1.8.3
--- class_variable_set(name, val) -> object
#@todo

クラス／モジュールにクラス変数 name を定義して、その値として
val をセットします。val を返します。

@param name [[c:String]] または [[c:Symbol]] を指定します。

  class Fred
    @@foo = 99
    def foo
      @@foo
    end
  end

  def Fred.foo(val)
    class_variable_set(:@@foo, val)
  end

  p Fred.foo(101)   # => 101
  p Fred.new.foo    # => 101
#@end

--- define_method(name, method) -> Proc|Method|UnboundMethod
--- define_method(name) { ... } -> Proc
#@todo

インスタンスメソッド name を定義します。

@param name [[c:String]] または [[c:Symbol]] を指定します。

@param method [[c:Proc]]、[[c:Method]] あるいは [[c:UnboundMethod]] の
いずれかのインスタンスを指定します。

@return 引数 method を与えたときはそれを、ブロック付きで
呼びだしたときはブロックを [[c:Proc]] 化したオブジェクトを、
それぞれ返します。

  class Foo
    def foo() p :foo end
    define_method(:bar, instance_method(:foo))
  end
  Foo.new.bar    # => :foo

ブロックを与えた場合、定義したメソッドの実行時にブロックが
レシーバクラスのインスタンスの上で [[m:Module#instance_eval]] されます。

--- extend_object(module) -> Module
#@todo

[[m:Kernel#extend]] の実体です。オブジェクトにモジュールの機能を追加します。

@param module [[c:Enumerable]] など [[c:Module]] クラスのインスタンスを指定します。

@return module で指定されたモジュールを返します。

[[m:Kernel#extend]] は、Ruby で書くと以下のように定義できます。

  def extend(*modules)
    modules.each {|mod| mod.__send__ :extend_object, self }
  end

extend_object のデフォルトの実装では、self に定義されて
いるメソッドを object の特異メソッドとして追加します。

#@since 1.8.0
--- extended(class_or_module) -> ()
#@todo

self が他のオブジェクト に [[m:Kernel#extend]] されたときに
呼ばれます。引数には extend を行ったオブジェクトが渡されます。

@param class_or_module [[m:Kernel#extend]] を行ったオブジェクト

  module Foo
    def self.extended(mod)
      p "#{mod} extend #{self}"
    end
  end

  Object.new.extend Foo

  # => "#<Object:0x401cbc3c> extend Foo"
#@end

--- include(*mod) -> self
#@todo

モジュール mod をインクルードします。

@param mod [[c:Module]] のインスタンス( [[c:Enumerable]] など)を指定します。

@raise ArgumentError 継承関係が循環してしまうような include を行った場合に発生します。

  module M
  end
  module M2
    include M
  end
  module M
    include M2
  end

実行結果:

  -:3:in `append_features': cyclic include detected (ArgumentError)
          from -:3:in `include'
          from -:3


インクルードとは、指定されたモジュールの定義
#@since 1.9.0
(メソッド、定数) を引き継ぐことです。
#@else
(メソッド、定数、クラス変数) を引き継ぐことです。
#@end
インクルードは多重継承の代わりに用いられており、 mix-in とも呼びます。

  class C
    include FileTest
    include Math
  end

  p C.ancestors

  # => [C, Math, FileTest, Object, Kernel]

モジュールの機能追加は、クラスの継承関係の間にそのモジュールが挿入
されることで実現されています。従って、メソッドの探索などは
スーパークラスよりもインクルードされたモジュールのほうが
先に行われます
(上の例の [[m:Module#ancestors]] の結果がメソッド探索の順序です)。

同じモジュールを二回以上 include すると二回目以降は無視されます。

  module M
  end
  class C1
    include M
  end
  class C2 < C1
    include M   # この include は無視される
  end

  p C2.ancestors  # => [C2, C1, M, Object, Kernel]

#@since 1.8.0
引数に複数のモジュールを指定した場合、
最後の引数から順にインクルードします。
#@end

#@since 1.8.0
--- included(class_or_module) -> ()
#@todo

self が [[m:Module#include]] されたときに対象のクラスまたはモジュー
ルを引数にしてインタプリタがこのメソッドを呼び出します。

@param class_or_module [[m:Module#include]] を実行したオブジェクト

  module Foo
    def self.included(mod)
      p "#{mod} include #{self}"
    end
  end
  class Bar
    include Foo
  end
  # => "Bar include Foo"
#@end

--- method_added(name) -> ()
#@todo

メソッド name が追加された時にインタプリタがこのメソッドを呼び出します。

@param name 追加されたメソッドの名前が [[c:Symbol]] で渡されます。

  class Foo
    def Foo.method_added(name)
      puts "method \"#{name}\" was added"
    end

    def foo
    end
    define_method :bar, instance_method(:foo)
  end

  => method "foo" was added
     method "bar" was added

特異メソッドの追加に対するフックには
[[m:Kernel#singleton_method_added]]
を使います。

#@since 1.8.0
--- method_removed(name) -> ()
#@todo

メソッドが [[m:Module#remove_method]] により削除
された時にインタプリタがこのメソッドを呼び出します。

@param name 削除されたメソッド名が [[c:Symbol]] で渡されます。

  class Foo
    def Foo.method_removed(name)
      puts "method \"#{name}\" was removed"
    end

    def foo
    end
    remove_method :foo
  end

  => method "foo" was removed

特異メソッドの削除に対するフックには
[[m:Kernel#singleton_method_removed]]
を使います。
#@end

#@since 1.8.0
--- method_undefined(name) -> ()
#@todo

このモジュールのインスタンスメソッド name が
[[m:Module#undef_method]] によって削除されるか、
undef 文により未定義にされると、インタプリタがこのメソッドを呼び出します。

@param name 削除/未定義にされたメソッド名が [[c:Symbol]] で渡されます。

  class C
    def C.method_undefined(name)
      puts "method C\##{name} was undefined"
    end

    def foo
    end
    def bar
    end

    undef_method :foo
    undef bar
  end

実行結果:

  method C#foo was undefined
  method C#bar was undefined

特異メソッドの削除をフックするには
[[m:Kernel#singleton_method_undefined]]
を使います。
#@end

--- module_function(*name) -> self
#@todo

メソッドをモジュール関数にします。

@param *name [[c:String]] または [[c:Symbol]] を 0 個以上指定します。

引数が与えられた時には、
引数で指定されたメソッドをモジュール関数にします。
引数なしのときは今後このモジュール定義文内で
新しく定義されるメソッドをすべてモジュール関数にします。

モジュール関数とは、プライベートメソッドであると同時に
モジュールの特異メソッドでもあるようなメソッドです。
例えば [[c:Math]] モジュールのメソッドはすべてモジュール関数です。

self を返します。

=== 注意
module_function はメソッドに「モジュール関数」という属性をつけるメ
ソッドではなく、プライベートメソッドとモジュールの特異メソッドの 2
つを同時に定義するメソッドです。
そのため、以下のように書いてもモジュール関数の別名は定義できません。

  module M
    def foo
      p "foo"
    end
    module_function :foo
    alias bar foo
  end

  M.foo   # => "foo"
  M.bar   # => undefined method `bar' for Foo:Module (NoMethodError)

このコードでは、モジュール関数 foo と
プライベートインスタンスメソッド bar を定義してしまいます。

正しくモジュール関数に別名を付けるには、
以下のように、先に別名を定義してから
それぞれをモジュール関数にしなければいけません。

  module M
    def foo
      p "foo"
    end

    alias bar foo
    module_function :foo, :bar
  end

  M.foo   # => "foo"
  M.bar   # => "foo"

--- private(*name) -> self
#@todo

メソッドを private に設定します。

@param *name [[c:String]] または [[c:Symbol]] を 0 個以上指定します。

@raise NameError 存在しないメソッド名を指定した場合に発生します。

引数なしのときは今後このクラスまたはモジュール定義内で新規に定義さ
れるメソッドを関数形式でだけ呼び出せるように(private)設定します。

引数が与えられた時には引数によって指定されたメソッドを private に
設定します。

  class Foo
    def foo1() 1 end      # デフォルトでは public
    private               # 可視性を private に変更
    def foo2() 2 end      # foo2 は private メソッド
  end

  foo = Foo.new
  p foo.foo1          # => 1
  p foo.foo2          # => private method `foo2' called for #<Foo:0x401b7628> (NoMethodError)

--- protected(*name) -> self
#@todo

メソッドを protected に設定します。

@param *name [[c:String]] または [[c:Symbol]] を 0 個以上指定します。

@raise NameError 存在しないメソッド名を指定した場合に発生します。

引数なしのときは今後このクラスまたはモジュール定義内で新規に定義さ
れるメソッドを protected に設定します。

引数が与えられた時には引数によって指定されたメソッドを protected
に設定します。

--- public(*name) -> self
#@todo

メソッドを public に設定します。

@param *name [[c:String]] または [[c:Symbol]] を 0 個以上指定します。

@raise NameError 存在しないメソッド名を指定した場合に発生します。

引数なしのときは今後このクラスまたはモジュール定義内で新規に定義さ
れるメソッドをどんな形式でも呼び出せるように(public)設定します。

引数が与えられた時には引数によって指定されたメソッドを public に設
定します。

  def foo() 1 end
  p foo             # => 1
  # the toplevel default is private
  p self.foo        # => private method `foo' called for #<Object:0x401c83b0> (NoMethodError)

  def bar() 2 end
  public :bar       # visibility changed (all access allowed)
  p bar             # => 2
  p self.bar        # => 2

--- remove_class_variable(name) -> object
#@todo

引数で指定したクラス変数を取り除き、そのクラス変数に設定さ
れていた値を返します。

@param name [[c:String]] または [[c:Symbol]] を指定します。

@return 引数で指定されたクラス変数に設定されていた値を返します。

@raise NameError 引数で指定されたクラス変数がそのモジュールやクラスに定義されていない場合に発生します。

  class Foo
    @@foo = 1
    remove_class_variable(:@@foo)   # => 1
    p @@foo   # => uninitialized class variable @@foo in Foo (NameError)
  end

@see [[m:Module#remove_const]], [[m:Kernel#remove_instance_variable]]


--- remove_const(name) -> object
#@todo

name で指定した定数を取り除き、その定数に設定されていた値を
返します。

@param name [[c:String]] または [[c:Symbol]] を指定します。

@return 引数で指定された定数に設定されていた値を返します。

@raise NameError 引数で指定された定数がそのモジュールやクラスに定義されていない場合に発生します。

  class Foo
    FOO = 1
    p remove_const(:FOO)    # => 1
    p FOO     # => uninitialized constant FOO at Foo (NameError)
  end

現在のところ組み込みクラス/モジュールを設定している定数や
[[m:Kernel#autoload]] を指定した(まだロードしてない)定数を削除
できないという制約があります。

  class Object
    remove_const :Array
  end
  => -:2:in `remove_const': cannot remove Object::Array (NameError)

@see [[m:Module#remove_class_variable]], [[m:Object#remove_instance_variable]]

#@since 1.8.0
--- remove_method(*name) -> self
#@todo
#@end

インスタンスメソッド name をモジュールから削除します。

@param name [[c:String]] または [[c:Symbol]] を一つ以上指定します。

@raise NameError 指定したメソッドが定義されていない場合に発生します。

  class C
    def foo
    end

    remove_method :foo
    remove_method :no_such_method   # 例外 NameError が発生
  end

#@since 1.8.0
Ruby 1.8.0 以降は複数のメソッド名を指定して一度に削除できます。
#@end

@see [[m:Module#undef_method]]

#@since 1.8.0
--- undef_method(*name) -> self
#@todo
#@end

このモジュールのインスタンスメソッド *name を未定義にします。

@params *name [[c:String]] または [[c:Symbol]] を一つ以上指定します。

@raise NameError 指定したインスタンスメソッドが定義されていない場合に発生します。

=== 「未定義にする」とは
このモジュールのインスタンスに対して name という
メソッドを呼び出すことを禁止するということです。
スーパークラスの定義が継承されるかどうかという点において、
「未定義」は「メソッドの削除」とは区別されます。
以下のコード例を参照してください。

  class A
    def ok
      puts 'A'
    end
  end
  class B < A
    def ok
      puts 'B'
    end
  end

  B.new.ok   # => B

  # undef_method の場合はスーパークラスに同名のメソッドがあっても
  # その呼び出しはエラーになる
  class B
    undef_method :ok
  end
  B.new.ok   # => NameError

  # remove_method の場合はスーパークラスに同名のメソッドがあると
  # それが呼ばれる
  class B
    remove_method :ok
  end
  B.new.ok   # => A

#@since 1.8.0
#@#see [ruby-dev:17894]
また、undef 文と undef_method の違いは、
メソッド名を [[c:String]] または [[c:Symbol]] で与えられることです。

  module M1
    def foo
    end
    def self.moo
      undef foo
    end
  end
  M1.instance_methods false #=> ["foo"]
  M1.moo
  M1.instance_methods false #=> []
  module M2
    def foo
    end
    def self.moo
      undef_method :foo
    end
  end
  M2.instance_methods false #=> ["foo"]
  M2.moo
  M2.instance_methods false #=> []

#@end

