= class IO < Object

include Enumerable
#@if (version >="1.8.0")
include File::Constants
#@end

IO クラスは基本的な入出力機能を実装します。

  * [[unknown:Traps: IO ポートのオープンに関わる問題|trap::IO]]

#@if (version >="1.8.0")
File::Constants は、[[c:File]] から IO へ移動しました。
#@end

=== EOF での読み込みメソッドの振る舞いの違い

空ファイルや EOF での各読み込みメソッドの振る舞いは以下のとおりです。
ただし、length を指定できるメソッドに関しては、length に 0 を指定した場合、
EOF であっても常に空文字列 "" を返します。
#@if (version < "1.9.0")
ただし、[[m:IO#read]](0) は EOF では nil を返します。
#@end

//emlist{
メソッド                      空のファイルに対して

IO.read(空ファイル)           ""
IO.read(空ファイル, length)   nil
IO.readlines(空ファイル)      []
IO.foreach(空ファイル)        何もしない
//}

//emlist{
メソッド                      既にEOFだったら

IO#each                       何もしない
IO#each_byte                  何もしない
IO#getc                       nil
IO#gets                       nil
IO#read()                     ""
IO#read(length)               nil
#@since 1.8.5
IO#read_nonblock              EOFError
#@end
IO#readchar                   EOFError
IO#readline                   EOFError
IO#readlines                  []
#@since 1.8.3
IO#readpartial                EOFError
#@end
IO#sysread                    EOFError
#@since 1.9.0
IO#bytes                      通常どおり
IO#lines                      通常どおり
#@end
//}

== Class Methods

--- new(fd, mode = "r")                -> IO
#@if (version >="1.8.0")
--- for_fd(fd, mode = "r")             -> IO
--- open(fd, mode = "r")               -> IO
--- open(fd, mode = "r") {|io| ... }   -> object
#@end
#@todo
オープン済みのファイルディスクリプタ fd に対する新しい
IO オブジェクトを生成して返します。

#@if (version >="1.8.0")
#@#IO.for_fd は、IO.new と同じです。IO.open はブロックを持てる
#@#点だけが異なります(ブロックの終了とともに fd はクローズされます)。
ブロックが与えられた場合、IO オブジェクトを生成しそれを引数としてブロックを
実行します。ブロックの終了とともに fd はクローズされます。ブロックの結果を返します。

#@#ブロックつき IO.open は、ブロックの結果を返します。
#@end

#@if (version >="1.8.0")
@param mode [[m:File.open]] と同じ形式で IO のモードを指定します。[[m:File::RDONLY]] などの定数(数値)でモードを指定できます。詳細は組み込み関数 [[m:Kernel.#open]] を参照してください。
#@else
@param mode [[m:File.open]] と同じ形式で IO のモードを指定します(ただし、文字列形式のみ)。詳細は組み込み関数[[m:Kernel.#open]]を参照してください。
#@end

@raise Errno::EXXX IO オブジェクトの生成に失敗した場合に発生します。

--- foreach(path, rs = $/) {|line| ... }    -> nil
#@todo

path で指定されたファイルの各行に対して繰り返します。
path のオープンに成功すれば nil を返します。

path が空ファイルの場合、何もせずに nil を返します。
[[m:Kernel.#open]] と同様 path の先頭が "|" ならば、"|" に続くコマンドの出力を読み取ります。

@param path ファイル名を表す文字列か "|コマンド名" を指定します。

@param rs 行の区切りを文字列で指定します。rs に nil を指定すると行区切りなしとみなします。空文字列 "" を指定すると連続する改行を行の区切りとみなします(パラグラフモード)。

@raise Errno::EXXX path のオープンに失敗した場合、発生します。

--- pipe    -> [IO]
#@todo

[[man:pipe(2)]] を実行して、相互につながった2つの
[[c:IO]] オブジェクトを要素とする配列を返します。

戻り値の配列は最初の要素が読み込み側で、次の要素が書き込み側です。

  p pipe = IO.pipe    # => [#<IO:0x401b90f8>, #<IO:0x401b7718>]
  pipe[1].puts "foo"
  p pipe[0].gets      # => "foo\n"

@raise Errno::EXXX IO オブジェクトの作成に失敗した場合に発生します。

--- popen(command, mode = "r")                -> IO
--- popen(command, mode = "r") {|io| ... }    -> object
#@todo

command をサブプロセスとして実行し、そのプロセスの標準入出力
との間にパイプラインを確立します。

生成したパイプを [[c:IO]] オブジェクトとして返します。

#@since 1.9.0
command が配列の場合は、シェルを経由せずに子プロセスを実行します。
#@end

  p io = IO.popen("cat", "r+")  # => #<IO:0x401b75c8>
  io.puts "foo"
  p io.gets  # => "foo\n"

ブロックが与えられた場合は生成した IO オブジェクトを引数にブ
ロックを実行し、その結果を返します。ブロックの実行後、生成したパイ
プは自動的にクローズされます。

  p IO.popen("cat", "r+") {|io|
    io.puts "foo"
    io.gets
  }
  # => "foo\n"

@param mode オープンする IO ポートのモードを指定します。mode の詳細は [[m:Kernel.#open]] 参照して下さい。

@raise Errno::EXXX パイプ、あるいは子プロセスの生成に失敗した場合に発生します。

--- popen("-", mode = "r")                -> IO
--- popen("-", mode = "r") {|io| ... }    -> object

コマンド名が "-" の時、Ruby は [[man:fork(2)]] を
行い子プロセスの標準入出力との間にパイプラインを確立します。
親プロセスでは IO オブジェクトを返し、子プロセスでは
nil を返します。

  io = IO.popen("-", "r+")
  if io  # parent
    io.puts "foo"
    p io.gets                   # => "child output: foo\n"
    io.close
  else   # child
    s = gets
    print "child output: " + s
    exit
  end
  
ブロックを与えられた場合、親プロセスでは生成した IO オブジェクトを引数に
ブロックを実行し、その結果を返します。ブロックの実行後、生成したパイ
プは自動的にクローズされます。
子プロセスでは nil を引数にブロックを実行し終了します。  

  p IO.popen("-", "r+") {|io|
    if io   # parent
      io.puts "foo"
      io.gets
    else    # child
      s = gets
      puts "child output: " + s
    end
  }
  # => "child output: foo\n"

@param mode オープンする IO ポートのモードを指定します。mode の詳細は [[m:Kernel.#open]] 参照して下さい。

@raise Errno::EXXX パイプ、あるいは子プロセスの生成に失敗した場合に発生します。

#@if (version >="1.8.0")
--- read(path, length = nil, offset = 0)     -> String | nil
#@todo

path で指定されたファイルを offset 位置から
length バイト分読み込んで返します。

IO が既に EOF に達している場合は nil を返します。ただし、length に nil か 0 が指定されている場合は、空文字列 "" を返します。例えば、IO.read(空ファイル) は "" を返します。

  IO.read(empty_file)             #=> ""
  IO.read(empty_file, 1)          #=> nil
  IO.read(one_byte_file, 0, 10)   #=> ""
  IO.read(one_byte_file, nil, 10) #=> "" 
  IO.read(one_byte_file, 1, 10)   #=> nil

[[m:Kernel.#open]] と同様 path の先頭が "|" ならば、"|" に続くコマンドの出力を読み取ります。

@param path ファイル名を表す文字列か "|コマンド名" を指定します。

@param length 読み込む長さを整数で指定します。nil であるか省略した場合には、EOF まで読み込みます。

@raise Errno::EXXX path のオープン、offset 位置への設定、ファイルの読み込みに失敗した場合に発生します。

@raise ArgumentError length が負の場合に発生します。

#@end

--- readlines(path, rs = $/)    -> [String]
#@todo

path で指定されたファイルを全て読み込んで、その各行を要素としてもつ配列を返します。

IO が既に EOF に達していれば空配列 [] を返します。
[[m:Kernel.#open]] と同様 path の先頭が "|" ならば、"|" に続くコマンドの出力を読み取ります。

@param path ファイル名を表す文字列か "|コマンド名" を指定します。

@param rs 行の区切りを文字列で指定します。rs に nil を指定すると行区切りなしとみなします。空文字列 "" を指定すると連続する改行を行の区切りとみなします(パラグラフモード)。

@raise Errno::EXXX path のオープン、ファイルの読み込みに失敗した場合に発生します。

--- select(reads, writes = [], excepts = [], timeout = nil)    -> [[IO]] | nil
#@todo

[[man:select(2)]] を実行します。
与えられた入力/出力/例外待ちの  IO オブジェクトの中から準備ができたものを
それぞれ配列にして、配列の配列として返します。
タイムアウトした時には nil を返します。

[[m:Kernel.#select]] と同じです。

 rp, wp = IO.pipe
 mesg = "ping "
 100.times{
   rs, ws, = IO.select([rp], [wp])
   if r = rs[0]
     ret = r.read(5)
     print ret
     case ret
     when /ping/
       mesg = "pong\n"
     when /pong/
       mesg = "ping "
     end
   end
   if w = ws[0]
     w.write(mesg)
   end
 }

@param reads 入力待ちする [[c:IO]] オブジェクトの配列を渡します。

@param writes 出力待ちする [[c:IO]] オブジェクトの配列を渡します。

@param excepts 例外待ちする [[c:IO]] オブジェクトの配列を渡します。

@param timeout 数値または nil を指定します。数値で指定したときの単位は秒です。nil を指定した時には IO がどれかひとつレディ状態になるまで待ち続けます。

@raise IOError 与えられた IO オブジェクトが閉じられていた時に発生します。

@raise Errno::EXXX [[man:select(2)]] に失敗した場合に発生します。

#@if (version >="1.8.0")
--- sysopen(path, mode = "r", perm = 0666)     -> Integer
#@todo

path で指定されるファイルをオープンし、ファイル記述子を返しま
す。

[[m:IO.for_fd]] などで IO オブジェクトにしない限り、このメソッ
ドでオープンしたファイルをクローズする手段はありません。

@path path ファイル名を表す文字列を指定します。

@param mode 組み込み関数 [[m:Kernel.#open]] と同じです。

@param perm 組み込み関数 [[m:Kernel.#open]] と同じです。

@raise Errno::EXXX ファイルのオープンに失敗した場合に発生します。

#@end

== Instance Methods

--- <<(object)    -> self
#@todo

object を出力します。object が文字列でない時にはメソッ
ド to_s を用いて文字列に変換します。

以下のような << の連鎖を使うことができます。

  STDOUT << 1 << " is a " << Fixnum << "\n"

@param object 出力したいオブジェクトを与えます。

@raise Errno::EXXX 出力に失敗した場合に発生します。

--- binmode    -> self
#@todo

ストリームをバイナリモードにします。MSDOS などバイナリモードの存在
する OS でのみ有効です。そうでない場合このメソッドは何もしません。

バイナリモードから通常のモードに戻す方法は再オープンしかありません。

--- clone    -> IO
--- dup      -> IO
#@todo

レシーバと同じ IO を参照する新しい IO オブジェクトを返します。
参照しているファイル記述子は [[man:dup(2)]] されます。

clone の際に self は一旦 [[m:IO#flush]] されます。

フリーズした IO の clone は同様にフリーズされた IO を返しますが、
dup は内容の等しいフリーズされていない IO を返します。

--- close    -> nil
#@todo

入出力ポートをクローズします。

以後このポートに対して入出力を行うと例外 [[c:IOError]] が発生しま
す。ガーベージコレクトの際にはクローズされていない IO ポートはクロー
ズされます。[[unknown:Traps:closeをGCにまかせる|trap::IO]]

self がパイプでプロセスにつながっていれば、そのプロセスの終
了を待ち合わせます。

@raise Errno::EXXX close に失敗した場合に発生します。

@raise IOError 既に close されていた場合に発生します。

--- close_read    -> nil
#@todo

読み込み用の IO を close します。主にパイプや読み書き両用に作成し
た IO オブジェクトで使用します。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

@raise Errno::EXXX close に失敗した場合に発生します。

--- close_write    -> nil
#@todo

書き込み用の IO を close します。

@raise IOError 自身が書き込み用にオープンされていなければ発生します。

@raise Errno::EXXX close に失敗した場合に発生します。

--- closed?    -> boolean
#@todo

ポートがクローズされている時に真を返します。

--- each(rs = $/) {|line| ... }         -> self
--- each_line(rs = $/) {|line| ... }    -> self
#@todo

IO の現在位置から 1 行ずつ文字列として読み込み、それを引数として与えられたブロックを実行します。

@param rs 行の区切りを文字列で指定します。rs に nil を指定すると行区切りなしとみなします。空文字列 "" を指定すると連続する改行を行の区切りとみなします(パラグラフモード)。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

--- each_byte {|ch| ... }    -> self
#@todo

IO の現在位置から 1 バイトずつ読み込み、それを整数として与え、ブロックを実行します。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

--- eof     -> boolean
--- eof?    -> boolean
#@todo

ストリームがファイルの終端に達した場合、true を返します。そうでない場合、false を返します。

--- fcntl(cmd, arg = 0)    -> Integer
#@todo

IOに対してシステムコール fcntl を実行します。
機能の詳細は [[man:fcntl(2)]] を参照してください。

fcntl(2) が返した整数を返します。

@param cmd IO に対するコマンドを、添付ライブラリ [[lib:fcntl]] が提供している定数で指定します。

@param arg cmd に対する引数を整数、boolean、文字列のいずれかで指定します。整数の時にはその値をそのまま [[man:fcntl(2)]] に渡します。true または false の場合はそれぞれ 1 または 0 を渡します。文字列の場合には pack した構造体だとみなしてそのまま渡します。

@raise Errno::EXXX fcntl の実行に失敗した場合に発生します。

@raise IOError 既に close されている場合に発生します。

#@since 1.8.0
--- fsync    -> 0 | nil
#@todo

書き込み用の IO に対して、システムコール [[man:fsync(2)]]
を実行します。[[m:IO#flush]] を行ったあと、(OSレベルで)まだディスクに
書き込まれていないメモリ上にあるデータをディスクに書き出します。

成功すれば 0 を返します。
[[man:fsync(2)]] がサポートされていない場合は nil を返します。

@raise Errno::EXXX 失敗した場合に発生します。

@raise IOError 既に close されている場合に発生します。

#@end

--- fileno    -> Integer
--- to_i      -> Integer
#@todo

ファイル記述子を表す整数を返します。

@raise IOError 既に close されている場合に発生します。

--- flush    -> self
#@todo

IO ポートの内部バッファをフラッシュします。

@raise IOError 自身が書き込み用にオープンされていなければ発生します。

--- getc    -> Integer | nil
#@todo

IO ポートから 1 文字読み込んで、その文字に対応する [[c:Fixnum]] を
返します。EOF に到達した時には nil を返します。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

--- gets(rs = $/)    -> String | nil
#@todo

一行読み込んで、読み込みに成功した時にはその文字列を返します。
EOF に到達した時には nil を返します。

[[m:IO#each]] と同じように動作しますが、こちらは 1 行返すだけで繰り返しません。

[[m:Kernel.#gets]] 同様、読み込んだ文字列を変数 [[m:$_]] にセットします。

@param rs 行の区切りを文字列で指定します。rs に nil を指定すると行区切りなしとみなします。空文字列 "" を指定すると連続する改行を行の区切りとみなします(パラグラフモード)。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

@see [[m:$/]]

--- ioctl(cmd, arg = 0)    -> Integer
#@todo

IO に対してシステムコール ioctl を実行し、その結果を返します。
機能の詳細は [[man:ioctl(2)]] を参照してください。

@param cmd IO に対するコマンドを整数で指定します。どのようなコマンドが使えるかはプラットフォームに依存します。

@param arg cmd に対する引数を指定します。整数の時にはその値を ioctl に渡します。文字列の場合には [[m:Array#pack]] した構造体だとみなして渡します。arg が nil か false の場合には 0を、true の場合には 1 を渡します。

@raise IOError 既に close されている場合に発生します。

--- isatty    -> boolean
--- tty?      -> boolean
#@todo

入出力ポートがttyに結合している時、真を返します。そうでない場合 false を返します。

@raise IOError 既に close されている場合に発生します。

--- lineno    -> Integer
#@todo

Returns the current line number in ios. The stream must be opened for reading. lineno counts the number of times gets is called, rather than the number of newlines encountered. The two values will differ if gets is called with a separator other than newline. See also the $. variable.

@raise IOError 読み込み用にオープンされていなければ発生します。

--- lineno=(number)
#@todo

Manually sets the current line number to the given value. $. is updated only on the next read.

@raise IOError 読み込み用にオープンされていなければ発生します。

--- pid    -> Integer | nil
#@todo

[[m:IO.popen]] で作られたIOポートなら、子プロセスのプロセス ID を
返します。それ以外は nil を返します。

@raise IOError 既に close されている場合に発生します。

--- pos    -> Integer
--- tell   -> Integer
#@todo

ファイルポインタの現在の位置を返します。

@raise IOError 既に close されている場合に発生します。

--- pos=(n)
#@todo

ファイルポインタを指定位置に移動します。
[[m:IO#seek]](n, IO::SEEK_SET)と同じです。

@raise IOError 既に close されている場合に発生します。

--- print(*arg)    -> nil
#@todo

引数を IO ポートに順に出力します。引数を省略した場合は、
[[m:$_]] を出力します。
引数の扱いは [[m:Kernel.#print]] と同じです。詳細はこちらを参照
してください。

@raise IOError 自身が書き込み用にオープンされていなければ発生します。

--- printf(format, *arg)    -> nil
#@todo

C 言語の printf と同じように、format に従い引数
を文字列に変換して、self に出力します。

第一引数に IO を指定できないこと、引数を省略できないことを除
けば [[m:Kernel.#printf]] と同じです。
引数の扱いの詳細については [[unknown:sprintfフォーマット]] を参照してください。

@raise IOError 自身が書き込み用にオープンされていなければ発生します。

--- putc(ch)    -> object
#@todo

文字 ch を self に出力します。
引数の扱いは [[m:Kernel.#putc]] と同じです。詳細はこちらを参照し
てください。

ch を返します。

@param ch 出力したい文字を、文字列か文字コード(整数)で与えます。

@raise IOError 自身が書き込み用にオープンされていなければ発生します。

--- puts(*obj)    -> nil
#@todo

各 obj を self に出力した後、改行します。
引数の扱いは [[m:Kernel.#puts]] と同じです。詳細はこちらを参照し
てください。

@raise IOError 自身が書き込み用にオープンされていなければ発生します。

#@since 1.8.0
--- read(length = nil, outbuf = "")    -> String | nil
#@else
--- read(length = nil)            -> String | nil
#@end
#@todo

length バイト読み込んで、その文字列を返します。

IO が既に EOF に達していれば nil を返します。
#@since 1.9.0
ただし、length に nil か 0 が指定されている場合は、空文字列 "" を返します。
#@else
ただし、length に nil が指定されている場合は、空文字列 "" を返します。
#@end
例えば、open(空ファイル) {|f| f.read } は "" となります。

@param length 読み込むサイズを整数で指定します。nil が指定された場合、EOF までの全てのデータを読み込んで、その文字列を返します。

#@since 1.8.0
@param outbuf 出力用のバッファを文字列で指定します。読み込んだデータをその文字列オブジェクトに上書きして返します。指定した文字列オブジェクトがあらかじめ length 長の領域であれば、余計なメモリの割当てが行われません。指定した文字列の長さが length と異なる場合、その文字列は一旦 length 長に拡張(あるいは縮小)されたあと、実際に読み込んだデータのサイズになります。

第二引数を指定した read の呼び出しでデータが空であった場合
(read が nil を返す場合)、outbuf は空文字列になりま
す。

  outbuf = "x" * 20;
  io = File.open("/dev/null")
  p io.read(10,outbuf)
  p outbuf
  => nil
     ""
#@end

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

@raise Errno::EXXX データの読み込みに失敗した場合に発生します。

@raise ArgumentError length が負の場合に発生します。

--- readchar    -> Integer
#@todo

[[m:IO#getc]] と同様に 1 文字読み込んで、その文字に対応す
る [[c:Fixnum]] を返します。

@raise EOFError EOF に到達した時に発生します。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

--- readline(rs = $/)    -> String
#@todo

[[m:IO#gets]] と同様に 1 行読み込みその文字列を返します。

readline は gets 同様読み込んだ文字列を変数 $_
にセットします。

@param rs 行の区切りを文字列で指定します。rs に nil を指定すると行区切りなしとみなします。空文字列 "" を指定すると連続する改行を行の区切りとみなします(パラグラフモード)。

@raise EOFError EOF に到達した時に発生します。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

@see [[m:$/]]

--- readlines(rs = $/)    -> [String]
#@todo

データを全て読み込んで、その各行を要素としてもつ配列を返します。
IO が既に EOF に達していれば空配列 [] を返します。

@param rs 行の区切りを文字列で指定します。rs に nil を指定すると行区切りなしとみなします。空文字列 "" を指定すると連続する改行を行の区切りとみなします(パラグラフモード)。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

@see [[m:$/]]

#@since 1.8.5
--- read_nonblock(maxlen, outbuf = "")    -> String
#@todo

IO をノンブロッキングモードに設定し、
その後で [[man:read(2)]] システムコールにより
長さ maxlen を上限として読み込み、文字列として返します。
EAGAIN, EINTR などは [[c:Errno::EXXX]] 例外として呼出元に報告されます。

なお、バッファが空でない場合は、
read_nonblock はバッファから読み込みます。
この場合、read(2) システムコールは呼ばれません。

@param outbuf 文字列で指定します。読み込んだデータを outbuf に破壊的に格納し、返り値は outbuf となります。outbuf は一旦 maxlen 長に拡張(あるいは縮小)されたあと、実際に読み込んだデータのサイズになります。read(2) システムコールが 0 を返した場合は、空文字列になります。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

@raise Errno::EXXX read(2) システムコールの結果としてエラーが起きた場合に発生します。

@raise EOFError read(2) システムコールが 0 を返した場合に発生します。 これは、IO が既に EOF に達していることを意味します。

#@end

#@since 1.8.3
--- readpartial(maxlen, outbuf = "")    -> String
#@todo

IO から長さ maxlen を上限として読み込み、文字列として返します。
即座に得られるデータが存在しないときにはブロックしてデータの到着を待ちます。
即座に得られるデータが 1byte でも存在すればブロックしません。

readpartial はブロックを最小限に抑えることによって、
パイプ、ソケット、端末などのストリームに対して適切に動作するよう設計されています。
readpartial がブロックするのは次の全ての条件が満たされたときだけです。
  * IO オブジェクト内のバッファが空
  * ストリームにデータが到着していない
  * ストリームが EOF になっていない
これらの条件が満たされる場合、何らかのデータが到着するか EOF になるまで readpartial はブロックします。

readpartial の結果は以下のようになります。
  (1) バッファが空でなければ、そのバッファのデータを読み込んで返します。
  (2) ストリームにデータがあれば、ストリームからデータを読み込んで返します。
  (3) ストリームが EOF になっていれば、例外 [[c:EOFError]] を発生させます。

例えば、パイプに対しては次のように動作します。

  r, w = IO.pipe           #               buffer          pipe content
  w << "abc"               #               ""              "abc".
  r.readpartial(4096)      #=> "abc"       ""              ""
  r.readpartial(4096)      # バッファにもパイプにもデータがないのでブロックする
  
  r, w = IO.pipe           #               buffer          pipe content
  w << "abc"               #               ""              "abc"
  w.close                  #               ""              "abc" EOF
  r.readpartial(4096)      #=> "abc"       ""              EOF
  r.readpartial(4096)      # 例外 EOFError 発生
  
  r, w = IO.pipe           #               buffer          pipe content
  w << "abc\ndef\n"        #               ""              "abc\ndef\n"
  r.gets                   #=> "abc\n"     "def\n"         ""
  w << "ghi\n"             #               "def\n"         "ghi\n"
  r.readpartial(4096)      #=> "def\n"     ""              "ghi\n"
  r.readpartial(4096)      #=> "ghi\n"     ""              ""

なお、readpartial は nonblock フラグに影響されません。
つまり、nonblock フラグが設定されていて sysread であれば Errno::EAGAIN になる場合でもブロックします。

また、readpartial の挙動は sysread によく似ています。
とくに、バッファが空の場合には同じ挙動を示します。
ただし、EAGAIN および EINTR エラーは内部で発生したとしても通知されず、データが到着するまでブロックし続けます。

@param outbuf 文字列で指定します。読み込んだデータを outbuf に破壊的に格納し、返り値は outbuf となります。outbuf は一旦 maxlen 長に拡張(あるいは縮小)されたあと、実際に読み込んだデータのサイズになります。IO が既に EOF に達していれば、空文字列になります。

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

@raise EOFError IO が既に EOF に達していれば発生します。

#@end

--- reopen(io)                   -> self
#@todo
自身を io に繋ぎ換えます。クラスも io に等しくなることに
注意してください。

--- reopen(path)                 -> self
--- reopen(path, mode)     -> self
#@todo

path で指定されたファイルにストリームを繋ぎ換えます。

#@if (version >= "1.8.0")
第二引数を省略したとき self のモードをそのまま引き継ぎます。
#@end

--- rewind    -> 0
#@todo

ファイルポインタを先頭に移動します。[[m:IO#lineno]] は 0 になります。

--- seek(offset, whence = IO::SEEK_SET)    -> 0
#@todo

ファイルポインタを whence の位置から offset だけ移動させます。
whence の値は以下のいずれかです。

  * IO::SEEK_SET: ファイルの先頭から (デフォルト)
  * IO::SEEK_CUR: 現在のファイルポインタから
  * IO::SEEK_END: ファイルの末尾から

whence の省略値は IO::SEEK_SET です。

offset 位置への移動が成功すれば 0 を返します。

@raise Errno::EXXX 失敗した場合に発生します。

--- stat    -> File::Stat
#@todo

ファイルのステータスを含む [[c:File::Stat]] オブジェクトを生成して
返します。

[[m:File#lstat]], [[m:File.stat]], [[m:File.lstat]] も参照してください。

@raise Errno::EXXX ステータスの読み込みに失敗した場合に発生します。

--- sync    -> boolean
#@todo

現在の出力同期モードを真偽値で返します。同期モードが真の時は、
出力関数の呼出毎にバッファがフラッシュされます。

--- sync=(newstate)
#@todo

出力同期モードを設定します。
newstate が真なら同期モード、偽なら非同期モードになります。
newstate を返します。

#@if (version >= "1.8.0")
--- sysread(maxlen, outbuf = "")   -> String
#@else
--- sysread(maxlen)           -> String
#@end
#@todo

[[man:read(2)]] を用いて入力を行ない、入力されたデータを
含む文字列を返します。

stdio を経由しないので gets や getc や eof? などと混用すると思わぬ動作
をすることがあります。

#@since 1.8.0
第二引数として文字列を指定すると、読み込ん
だデータをその文字列オブジェクトに上書きして返します。指定した文字
列オブジェクトがあらかじめ maxlen 長の領域であれば、余計なメ
モリの割当てが行われません。指定した文字列の長さが maxlen と
異なる場合、その文字列は一旦 maxlen 長に拡張(あるいは縮小)さ
れたあと、実際に読み込んだデータのサイズになります。

第二引数を指定した sysread の呼び出しでデータが空であった場
合(sysread が例外 [[c:EOFError]] を発生させる場合)、
outbuf は空文字列になります。

  outbuf = "x" * 20;
  io = File.open("/dev/null")
  p((io.sysread(10,outbuf) rescue nil))
  p outbuf
  => nil
     ""
#@end

@raise IOError 自身が読み込み用にオープンされていなければ発生します。

@raise EOFError IO が既に EOF に達していれば発生します。

@raise Errno::EXXX データの読み込みに失敗した場合に発生します。

#@if (version >="1.8.0")
--- sysseek(offset, whence = IO::SEEK_SET)    -> Integer
#@todo

[[man:lseek(2)]] と同じです。[[m:IO#seek]] では、
[[m:IO#sysread]], [[m:IO#syswrite]] と併用すると正しく動作しないの
で代わりにこのメソッドを使います。

書き込み用にバッファリングされた IO に対して実行すると警告が出ます。

  File.open("/dev/zero") {|f|
    buf = f.read(3)
    f.sysseek(0)
  }
  # => -:3:in `sysseek': sysseek for buffered IO (IOError)
  
  File.open("/dev/null", "w") {|f|
    f.print "foo"
    f.sysseek(0)
  }
  # => -:3: warning: sysseek for buffered IO

引数は [[m:IO#seek]] と同じです。

位置 offset への移動が成功すれば移動した位置(ファイル先頭から
のオフセット)を返します。

@raise IOError 読み込み用にバッファリングされた IO に対して実行すると発生します。

@raise Errno::EXXX 移動に失敗した場合に発生します。

#@end

--- syswrite(string)    -> Integer    
#@todo

[[man:write(2)]] を用いて string を出力します。
string が文字列でなければ to_s による文字列化を試みます。
実際に出力できたバイト数を返します。

stdio を経由しないので他の出力メソッドと混用すると思わぬ動作
をすることがあります。

@param string 自身に書き込みたい文字列を指定します。

@raise IOError 自身が書き込み用にオープンされていなければ発生します。

@raise Errno::EXXX 出力に失敗した場合に発生します。

--- to_io    -> self
#@todo

self を返します。

--- ungetc(char)     -> nil
#@todo

char を読み戻します。2バイト以上の読み戻しは保証されません。

@param char 読み戻したい文字に対応する [[c:Fixnum]] を指定します。

@raise IOError 読み戻しに失敗した場合に発生します。また、自身が読み込み用にオープンされていない時、自身がまだ一度も read されていない時に発生します。

  f = File.new("testfile")   #=> #<File:testfile>
  c = f.getc                 #=> 84
  f.ungetc(c)                #=> nil
  f.getc                     #=> 84
   
--- write(str)     -> Integer
#@todo

IOポートに対して str を出力します。str が文字列でなけ
れば to_s による文字列化を試みます。
実際に出力できたバイト数を返します。

[[m:IO#syswrite]] を除く全ての出力メソッドは、最終的に
"write" という名のメソッドを呼び出すので、このメソッドを置き換える
ことで出力関数の挙動を変更することができます。
#@##@since 1.8.0
#@#以前は [[m:Kernel.#putc]], 
#@#[[m:IO#putc]] に対してだけこのことは適用されませんでした
#@#([[ruby-dev:16305]])が、修正されました([[ruby-dev:18038]])。
#@##@end

@param str 自身に書き込みたい文字列を指定します。

@raise IOError 自身が書き込み用にオープンされていなければ発生します。

@raise Errno::EXXX 出力に失敗した場合に発生します。

#@if (version >= "1.8.5")
--- write_nonblock(string)    -> Integer
#@todo

IO をノンブロッキングモードに設定し、
その後で string を [[man:write(2)]] システムコールで書き出します。
ここで、EAGAIN, EINTR なども例外 [[c:Errno::EXXX]] として呼出元に報告されます。

write(2) が成功した場合、返り値は書き込んだ長さとなります。

@param string 自身に書き込みたい文字列を指定します。

@raise IOError 自身が書き込み用にオープンされていなければ発生します。

@raise Errno::EXXX [[man:write(2)]] が失敗した場合に発生します。
#@end

#@since 1.9.0
--- bytes    -> Enumerator
#@todo

Returns an enumerator that gives each byte in the string.

   "hello".bytes.to_a        #=> [104, 101, 108, 108, 111]

--- lines(separator=$/)    -> Enumerator
#@todo

Returns an enumerator that gives each line in the string.

   "foo\nbar\n".lines.to_a   #=> ["foo\n", "bar\n"]
   "foo\nb ar".lines.sort    #=> ["b ar", "foo\n"]

@see [[m:$/]]

#@end

== Constants

--- SEEK_CUR
#@todo

--- SEEK_END
#@todo

--- SEEK_SET
#@todo

[[m:IO#seek]] を参照してください。
