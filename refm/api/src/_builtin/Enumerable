= module Enumerable

繰り返しを行なうクラスのための Mix-in。このモジュールの
メソッドは全て each を用いて定義されているので、インクルード
するクラスには each が定義されていなければなりません。

== Instance Methods

#@since 1.8.0
--- all?               -> bool
--- all? {|item| ... } -> bool

すべての要素が真である場合に true を返します。
偽である要素があれば、ただちに false を返します。

ブロックを伴う場合は、各要素に対してブロックを評価し、すべての結果
が真である場合に true を返します。ブロックが偽を返した時点で、
ただちに false を返します。

例:
    # すべて正の数か？
    p [5,  6, 7].all? {|v| v > 0 }   # => true
    p [5, -1, 7].all? {|v| v > 0 }   # => false
#@end

#@since 1.8.0
--- any?               -> bool
--- any? {|item| ... } -> bool

すべての要素が偽である場合に false を返します。
真である要素があれば、ただちに true を返します。

ブロックを伴う場合は、各要素に対してブロックを評価し、すべての結果
が偽である場合に false を返します。ブロックが真を返した時点
で、ただちに true を返します。

例:
    p [1, 2, 3].any? {|v| v > 3 }   # => false
    p [1, 2, 3].any? {|v| v > 1 }   # => true
#@end

--- collect {|item| ... } -> [Object]
--- map {|item| ... }     -> [Object]

各要素に対してブロックを評価した結果を全て含む配列を返します。

ブロックを省略した場合、
obj.collect {|item| item } を実行します。
これは [[m:Enumerable#to_a]] と同じです。

例:
    # すべて 3 倍にする
    p [1, 2, 3].map {|n| n * 3 }  # => [3, 6, 9]

--- each_with_index {|item, index| ... } -> self

要素とそのインデックスをブロックに渡して繰り返します。

self を返します。

例:
    [5, 10, 15].each_with_index do |n, idx|
      p [n, idx]
    end
        # => [5, 0]
        #    [10, 1]
        #    [15, 2]

#@since 1.8.4
@see enum_with_index
#@end

#@since 1.8.4
--- enum_with_index -> Enumerable::Enumerator

要素とそのインデックスに対して繰り返す Enumerator を返します。
Enumerable::Enumerator.new(self, :each_with_index) と同じです。

@see [[m:Enumerable#each_with_index]]
#@end

--- find(ifnone = nil) {|item| ... }   -> Object
--- detect(ifnone = nil) {|item| ... } -> Object

要素に対してブロックを評価した値が真になった最初の要素を返します。

真になる要素が見つからず、
ifnone も指定されていないときは nil を返します。
真になる要素が見付からず、ifnone が指定されているときは
ifnone を eval または call して実行し、nil を返します。
#@# 1.7 featureかも。いつから?
#@# あらい: ifnone に文字列が指定できなくなってからみたい
#@# http://www.ruby-lang.org/cgi-bin/cvsweb.cgi/ruby/enum.c.diff?r1=1.28&r2=1.29

#@since 1.8.0
@arg ifnone  call メソッドを持つオブジェクト (例えば [[c:Proc]]) を指定します。

例:
    # 最初の 3 の倍数を探す
    p [1, 2, 3, 4, 5].find {|i| i % 3 == 0 }   # => 3
    p [2, 2, 2, 2, 2].find {|i| i % 3 == 0 }   # => nil

    # ifnone の使用例
    ifnone = proc { raise ArgumentError, "item not found" }
    p [1, 2, 3, 4, 5].find(ifnone) {|i| i % 7 == 0 }
        # ArgumentError: item not found
#@else
@arg ifnone  文字列または call メソッドを持つオブジェクト (例えば [[c:Proc]]) を指定します。

    [1, 2, 3].find("raise") {|v| v > 4 }
        # => -:1: unhandled exception
#@end

--- find_all {|item| ... } -> [Object]
--- select {|item| ... }   -> [Object]

各要素に対してブロックを評価した値が真であった要素を全て含む配列を
返します。真になる要素がひとつもなかった場合は空の配列を返します。

--- grep(pattern)                -> [Object]
--- grep(pattern) {|item| ... }  -> [Object]

pattern === item が成立する要素を全て含んだ配列を返します。
ブロックとともに呼び出された時には条件の成立した要素に対して
それぞれブロックを評価し、その結果の配列を返します。
マッチする要素がひとつもなかった場合は空の配列を返します。

@arg pattern	「===」メソッドを持つオブジェクトを指定します。

例:
    p ['aa', 'bb', 'cc', 'dd', 'ee'].grep(/[bc]/)  # => ["bb", "cc"]

#@since 1.8.0
--- inject(init = self.first) {|result, item| ... } -> Object

リストのたたみこみ演算を行います。

最初に初期値 init と self の最初の要素を引数にブロックを実行します。
2 回目以降のループでは、前のブロックの実行結果と
self の次の要素を引数に順次ブロックを実行します。
そうして最後の要素まで繰り返し、最後のブロックの実行結果を返します。

要素が存在しない場合は init を返します。

初期値 init を省略した場合は、
最初に先頭の要素と 2 番目の要素をブロックに渡します。
また要素が 1 つしかなければブロックを実行せずに最初の要素を返します。
要素がなければブロックを実行せずに nil を返します。

@arg init    最初の result の値です。任意のオブジェクトが渡せます。

例:

  # 合計を計算する
  p [1, 2,3, 4, 5].inject(0) {|result, item| result + item }  # => 15

この式は以下のように書いても同じ結果が得られます。

  result = 0
  [1, 2, 3, 4, 5].each {|v| result += v }
  p result   # => 15
#@end

--- member?(val)  -> bool
--- include?(val) -> bool

val と == の関係にある要素を含むとき真を返します。

@arg val   任意のオブジェクト

--- max -> Object

最大の要素を返します。
全要素が互いに <=> メソッドで比較できることを仮定しています。

要素が存在しなければ nil を返します。

--- max {|a, b| ... } -> Object

ブロックの評価結果で各要素の大小判定を行い、最大の要素を返します。
要素が存在しなければ nil を返します。

ブロックの値は、a > b のとき正、
a == b のとき 0、a < b のとき負の整数を、期待しています。
ブロックが整数以外を返したときは
例外 [[c:TypeError]] が発生します。

@raise TypeError    ブロックが整数以外を返したときに発生します。

#@since 1.9.0
--- max_by {|item| ... } -> Object

各要素を順番にブロックに渡して実行し、
その評価結果を <=> で比較して、
最大であった値に対応する元の要素を返します。

要素が存在しないときは nil を返します。

max と max_by の違いは sort と sort_by の違いと同じです。
詳細は [[m:Enumerable#sort_by]] を参照してください。
#@end

--- min -> Object

最小の要素を返します。
全要素が互いに <=> メソッドで比較できることを仮定しています。

要素が存在しなければ nil を返します。

--- min {|a, b| ... } -> Object

ブロックの評価結果で各要素の大小判定を行い、最小の要素を返します。
要素が存在しなければ nil を返します。

ブロックの値は、a > b のとき正、a == b のとき 0、
a < b のとき負の整数を、期待しています。
ブロックが整数以外を返したときは例外 TypeError が発生します。

@raise TypeError    ブロックが整数以外を返したとき

#@since 1.9.0
--- min_by {|item| ... } -> Object

各要素を順番にブロックに渡して実行し、
その評価結果を <=> で比較して、
最大であった値に対応する元の要素を返します。

要素が存在しないときは nil を返します。

min と min_by の違いは sort と sort_by の違いと同じです。
詳細は[[m:Enumerable#sort_by]] を参照してください。
#@end

--- partition {|item| ... } -> [[Object], [Object]]

各要素を、ブロックの条件を満たす要素と満たさない要素に分割します。
各要素に対してブロックを評価して、その値が真であった要素の配列と、
偽であった要素の配列の 2 つを配列に入れて返します。

例:

  [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0].partition {|i| i % 3 == 0 }
   #=> [[9, 6, 3, 0], [10, 8, 7, 5, 4, 2, 1]]

--- reject {|item| ... } -> [Object]

各要素に対してブロックを評価し、
その値が偽であった要素を集めた新しい配列を返します。
条件を反転させた select です。

例:

  # 偶数を除外する (奇数を集める)
  [1, 2, 3, 4, 5, 6].reject {|i| i % 2 == 0 }  # => [1, 3, 5]

@see [[m:Enumerable#select]]

--- sort               -> [Object]
--- sort {|a, b| ... } -> [Object]

全ての要素を昇順にソートした配列を生成して返します。

ブロックなしのときは <=> メソッドを要素に対して呼び、
その結果をもとにソートします。

<=> 以外でソートしたい場合は、ブロックを指定します。
この場合、ブロックの評価結果を元にソートします。
ブロックの値は、a > b のとき正、a == b のとき 0、
a < b のとき負の整数を、期待しています。
ブロックが整数以外を返したときは例外 [[c:TypeError]] が発生します。

Enumerable#sort は安定ではありません (unstable sort)。
安定なソートが必要な場合は [[m:Enumerable#sort_by]] を使って工夫する必要があります。
詳しくは [[m:Enumerable#sort_by]] の項目を参照してください。

※ 比較結果が同じ要素は元の順序通りに並ぶソートを
「安定なソート (stable sort)」と言います。

@see [[m:Enumerable#sort_by]]

#@since 1.8.0
--- sort_by {|item| ... } -> [Object]

ブロックの評価結果を <=> メソッドで比較することで、self を昇
順にソートします。ソートされた配列を新たに生成して返します。
つまり、以下とほぼ同じ動作をします。

  class Array
    def sort_by
      self.map {|i| [yield(i), i] }.
         sort {|a, b| a[0] <=> b[0] }.
         map {|i| i[1]}
    end
  end

[[m:Enumerable#sort]] と比較して sort_by が優れている点として、
比較条件が複雑な場合の速度が挙げられます。
sort_by を使わない以下の例では比較を行う度に downcase が実行されます。
従って downcase の実行速度が遅ければ sort の速度が致命的に低下します。

  p ["BAR", "FOO", "bar", "foo"].sort {|a, b| a.downcase <=> b.downcase }

一方、次のように sort_by を使うと downcase の実行回数は要素数と同じです。
つまり、その部分の実行時間は O(n) のオーダーです。

  p ["BAR", "FOO", "bar", "foo"].sort_by {|v| v.downcase }

以下の、実行回数の検証結果を参照してみてください。

  class Integer
    def count
      $n += 1
      self
    end
  end

  ary = []
  1.upto(1000) {|v| ary << rand(v) }

  $n = 0
  ary.sort {|a,b| a.count <=> b.count }
  p $n          # => 18200

  $n = 0
  ary.sort_by {|v| v.count }
  p $n          # => 1000

Enumerable#sort_by は安定ではありません (unstable sort)。
ただし、sort_by を以下のように使うと安定なソートを実装できます。

  i = 0
  ary.sort_by {|v| [v, i += 1] }

※ 比較結果が同じ要素は元の順序通りに並ぶソートを
「安定なソート (stable sort)」と言います。

@see [[m:Enumerable#sort]]
#@end

--- to_a    -> [Object]
--- entries -> [Object]

全ての要素を含む配列を返します。

#@since 1.8.0
--- zip(*lists)  -> [[Object]]

self と引数に渡した配列の各要素からなる配列の配列を生成して返します。
生成される配列の要素数は self の要素数と同じです。

例:
    p [1,2,3].zip([4,5,6], [7,8,9])
        # => [[1, 4, 7], [2, 5, 8], [3, 6, 9]]

    p [1,2].zip([:a,:b,:c], [:A,:B,:C,:D])
        # => [[1, :a, :A], [2, :b, :B]]

    p (1..5).zip([:a,:b,:c], [:A,:B,:C,:D])
        # => [[1, :a, :A], [2, :b, :B],
        #     [3, :c, :C], [4, nil, :D], [5, nil, nil]]
#@end

#@since 1.8.0
--- zip(*lists) {|v1, v2, ...| ...} -> nil

zip をブロック付きで呼び出した場合は、
self と引数に渡した配列の各要素を順番にブロックに渡します。

常に nil を返します。

例:
    p [1,2,3].zip([4,5,6], [7,8,9]) {|ary|
      p ary
    }
        # => [1, 4, 7]
        #    [2, 5, 8]
        #    [3, 6, 9]
        #    nil
#@end

#@since 1.8.4
--- each_slice(n) {|list| ... } -> nil

n 要素ずつブロックに渡して繰り返します。
要素数が n で割り切れないときは、
最後の回だけ要素数が減ります。

nil を返します。

@arg n   区切る要素数を示す整数です。

例:

  (1..10).each_slice(3) {|a| p a}
      # => [1, 2, 3]
      #    [4, 5, 6]
      #    [7, 8, 9]
      #    [10]

@see [[m:Enumerable#each_cons]]

--- enum_slice(n) -> Enumerable::Enumerator

n 要素ずつ繰り返す Enumerator を返します。
Enumerable::Enumerator.new(self, :each_slice, n) と同じです。

@arg n   区切る要素数を示す整数です。
@see [[m:Enumerable#each_cons]]

--- each_cons(n) {|list| ... } -> nil

要素を重複ありで n 要素ずつに区切り、
ブロックに渡して繰り返します。

nil を返します。

@arg n   区切る要素数を示す整数です。

例:

  [1, 2, 3, 4, 5].each_cons(3) {|a| p a }
      # => [1, 2, 3]
      #    [2, 3, 4]
      #    [3, 4, 5]

@see [[m:Enumerable#each_slice]]

--- enum_cons(n) -> Enumerable::Enumerator

要素を重複ありで n 要素ずつに区切って繰り返す Enumerator を返します。

Enumerable::Enumerator.new(self, :each_cons, n) を返します。

@arg n   区切る要素数を示す整数です。
@see [[m:Enumerable#each_slice]]
#@end

#@since 1.9.0

--- count(item)             -> Integer
--- count {| obj | block }  -> Integer
#@todo

Returns the number of items in enum for which equals to item.
If a block is given, counts the number of elements yielding a
true value.

   ary = [1, 2, 4, 2]
   ary.count(2)          # => 2
   ary.count{|x|x%2==0}  # => 3


--- cycle {|obj| block }
#@todo

Calls block for each element of enum repeatedly forever. Returns
nil if and only if the collection is empty. Enumerable#cycle
saves elements in an internal array so changes to enum after
the first pass have no effect.

   a = ["a", "b", "c"]
   a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.


--- drop(n)               -> Array
#@todo

Drops first n elements from enum, and returns rest elements in
an array.

   a = [1, 2, 3, 4, 5, 0]
   a.drop(3)             # => [4, 5, 0]


--- drop_while {|arr| block }   -> Array
#@todo

Drops elements up to, but not including, the first element for
which the block returns nil or false and returns an array containing
the remaining elements.

   a = [1, 2, 3, 4, 5, 0]
   a.drop {|i| i < 3 }   # => [3, 4, 5, 0]


--- find_index   {| obj | block }  -> Integer
#@todo

Passes each entry in enum to block. Returns the index for the
first for which block is not false. If no object matches, returns
nil

   (1..10).find_index  {|i| i % 5 == 0 and i % 7 == 0 }   #=> nil
   (1..100).find_index {|i| i % 5 == 0 and i % 7 == 0 }   #=> 34


--- first      -> object or nil
--- first(n)   -> Array
#@todo

Returns the first element, or the first n elements, of the enumerable.
If the enumerable is empty, the first form returns nil, and the
second form returns an empty array.


--- group_by {| obj | block }  -> Hash
#@todo

Returns a hash, which keys are evaluated result from the block,
and values are arrays of elements in enum corresponding to the
key.

   (1..6).group_by {|i| i%3}   #=> {0=>[3, 6], 1=>[1, 4], 2=>[2, 5]}


--- minmax                   -> [min,max]
--- minmax {|a,b| block }    -> [min,max]
#@todo

Returns two elements array which contains the mininum and the
maxinum value in the enumerable. The first form assumes all objects
implement Comparable; the second uses the block to return a <=>
b.

   a = %w(albatross dog horse)
   a.minmax                                  #=> ["albatross", "horse"]
   a.minmax {|a,b| a.length <=> b.length }   #=> ["dog", "albatross"]


--- minmax_by {| obj| block }   -> [min, max]
#@todo

Returns two elements array array containing the objects in enum
that gives the minmum and maximum values respectively from the
given block.

   a = %w(albatross dog horse)
   a.minmax_by {|x| x.length }   #=> ["dog", "albatross"]


--- none? [{|obj| block }]   -> bool
#@todo

Passes each element of the collection to the given block. The
method returns true if the block never returns true for all elements.
If the block is not given, none? will return true only if none
of the collection members is true.

   %w{ant bear cat}.none? {|word| word.length == 5}  #=> true
   %w{ant bear cat}.none? {|word| word.length >= 4}  #=> false
   [].none?                                          #=> true
   [nil].none?                                       #=> true
   [nil,false].none?                                 #=> true

--- one? [{|obj| block }]   -> bool
#@todo

Passes each element of the collection to the given block. The
method returns true if the block returns true exactly once. If
the block is not given, one? will return true only if exactly
one of the collection members is true.

   %w{ant bear cat}.one? {|word| word.length == 4}   #=> true
   %w{ant bear cat}.one? {|word| word.length >= 4}   #=> false
   [ nil, true, 99 ].one?                            #=> false
   [ nil, true, false ].one?                         #=> true

--- take(n)               -> Array
#@todo

Returns first n elements from enum.

   a = [1, 2, 3, 4, 5, 0]
   a.take(3)             # => [1, 2, 3]

--- take_while {|arr| block }   -> Array
#@todo

Passes elements to the block until the block returns nil or false,
then stops iterating and returns an array of all prior elements.

   a = [1, 2, 3, 4, 5, 0]
   a.take {|i| i < 3 }   # => [1, 2]

#@end
